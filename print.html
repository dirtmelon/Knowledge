<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Knowledge</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="programming-languages/programming-languages.html"><strong aria-hidden="true">1.</strong> 编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Objective-C.html"><strong aria-hidden="true">1.1.</strong> Objective-C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-languages/Objective-C/associated-objects.html"><strong aria-hidden="true">1.1.1.</strong> Associated Objects</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/initialize.html"><strong aria-hidden="true">1.1.2.</strong> initialize</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/load.html"><strong aria-hidden="true">1.1.3.</strong> load</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Block.html"><strong aria-hidden="true">1.1.4.</strong> Block</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Category.html"><strong aria-hidden="true">1.1.5.</strong> Category</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Message-Sending-And-Forwarding.html"><strong aria-hidden="true">1.1.6.</strong> Message Sending And Forwarding</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/KVO.html"><strong aria-hidden="true">1.1.7.</strong> KVO</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/KVC.html"><strong aria-hidden="true">1.1.8.</strong> KVC</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/AutoreleasePool.html"><strong aria-hidden="true">1.1.9.</strong> AutoreleasePool</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/dealloc.html"><strong aria-hidden="true">1.1.10.</strong> dealloc</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Tagged-Pointer.html"><strong aria-hidden="true">1.1.11.</strong> Tagged Pointer</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/weak.html"><strong aria-hidden="true">1.1.12.</strong> weak</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Object.html"><strong aria-hidden="true">1.1.13.</strong> Object</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Knowledge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dirtmelon/Knowledge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="编程语言"><a class="header" href="#编程语言">编程语言</a></h1>
<ul>
<li><a href="programming-languages/./Objective-C/Objective-C.html">Objective-C</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c"><a class="header" href="#objective-c">Objective-C</a></h1>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Runtime 官方文档</a></p>
<ul>
<li><a href="programming-languages/Objective-C/./associated-objects.html">Associated Objects</a></li>
<li><a href="programming-languages/Objective-C/./initialize.html">initialize</a></li>
<li><a href="programming-languages/Objective-C/./load.html">load</a></li>
<li><a href="programming-languages/Objective-C/./Block.html">Block</a></li>
<li><a href="programming-languages/Objective-C/./Category.html">Category</a></li>
<li><a href="programming-languages/Objective-C/./Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li>
<li><a href="programming-languages/Objective-C/./KVO.html">KVO</a></li>
<li><a href="programming-languages/Objective-C/./KVC.html">KVC</a></li>
<li><a href="programming-languages/Objective-C/./AutoreleasePool.html">AutoreleasePool</a></li>
<li><a href="programming-languages/Objective-C/./dealloc.html">dealloc</a></li>
<li><a href="programming-languages/Objective-C/./Tagged-Pointer.html">Tagged Pointer</a></li>
<li><a href="programming-languages/Objective-C/./weak.html">weak</a></li>
<li><a href="programming-languages/Objective-C/./Object.html">Object</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-objects"><a class="header" href="#associated-objects">Associated Objects</a></h1>
<p><a href="https://nshipster.com/associated-objects/">Associated Objects</a></p>
<p>通过以下三个函数可以进行关联对象的相关操作：</p>
<pre><code class="language-objectivec">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
void objc_removeAssociatedObjects(id object);
</code></pre>
<p><code>key</code> 应该是常量的，唯一的，在 <code>setter</code> 和 <code>getter</code> 方法中可以进行访问：</p>
<pre><code class="language-objectivec">static char kAssociatedObjectKey;

objc_getAssociatedObject(self, &amp;kAssociatedObjectKey);
</code></pre>
<p>但是由于 <code>selector</code> 是唯一的，所以可以直接使用 <code>selector</code> ：</p>
<p><a href="https://twitter.com/bbum/status/3609098005">https://twitter.com/bbum/status/3609098005</a></p>
<p>不要调用 <code>objc_removeAssociatedObjects</code> 来移除关联对象，因为会移除所有关联对象。正确的做法是调用 <code>objc_setAssociatedObject</code> 方法并传入 <code>nil</code> 来清除关联。</p>
<blockquote>
<p>比起其他解决问题的方法，关联对象应该被视为最后的选择（事实上关联对象也不应该作为首选方法）。</p>
</blockquote>
<h2 id="associatedobject-解析"><a class="header" href="#associatedobject-解析">AssociatedObject 解析</a></h2>
<p><a href="https://draveness.me/ao/">关联对象 AssociatedObject 完全解析 - 面向信仰编程</a></p>
<ul>
<li>关联对象其实就是 <code>ObjcAssociation</code> 对象</li>
<li>关联对象由 <code>AssociationsManager</code> 管理并在 <code>AssociationsHashMap</code> 存储</li>
<li>对象的指针以及其对应 <code>ObjectAssociationMap</code> 以键值对的形式存储在 <code>AssociationsHashMap</code> 中</li>
<li><code>ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li>
<li>每一个对象都有一个标记位 <code>has_assoc</code> 指示对象是否含有关联对象</li>
</ul>
<h2 id="ios-中的关联对象"><a class="header" href="#ios-中的关联对象">iOS 中的关联对象</a></h2>
<p><a href="https://kingcos.me/posts/2019/associated_objects_in_ios/">iOS 中的关联对象</a></p>
<p><img src="programming-languages/Objective-C/media/16295230050442.jpg" alt="" /></p>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p><a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor">ChenYilong/CYLDeallocBlockExecutor</a></p>
<p>通过 <code>Associated Objects</code> 在对象 <code>dealloc</code> 会释放的原理，可以给对象添加一个属性，然后在这个属性 <code>dealloc</code> 时进行相关操作，可以达到对象 <code>dealloc</code> 进行对应操作的目的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialize"><a class="header" href="#initialize">initialize</a></h1>
<h2 id="官方文档"><a class="header" href="#官方文档">官方文档</a></h2>
<p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize">Apple Developer Documentation</a></p>
<ol>
<li><code>initialize</code> 会在第一次给当前类发送消息（即调用方法）时调用；</li>
<li>先调用父类的，再调用子类的；</li>
<li><code>initialize</code> 是线程安全的，它会在第一次给类发送消息的当前线程中运行，而其它线程尝试给类发送消息的线程则需要等待 <code>initialize</code> 执行完毕；</li>
<li>如果子类没有实现 <code>initialize</code> 方法，则会调用父类的，所以一个 <code>initialize</code> 有可能会多次调用，我们可以通过对当前类进行判断来防止多次调用；</li>
<li>因为 <code>initialize</code> 有阻塞机制，所以尽量不要执行复杂的初始化方法，不然有可能会造成死锁；</li>
<li>每个类的 <code>initialize</code> 方法只会调用一次，如果需要分类和类的初始化方法都执行，可以使用 <code>load</code> 方法。</li>
</ol>
<p>如何防止 <code>initialize</code> 方法多次调用：</p>
<pre><code class="language-objectivec">+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre>
<h2 id="源码解析"><a class="header" href="#源码解析">源码解析</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E6%87%92%E6%83%B0%E7%9A%84%20initialize%20%E6%96%B9%E6%B3%95.md">draveness/analyze</a></p>
<p><code>initialize</code> 的源码解析，与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都<strong>已经加载</strong>到了内存中。</p>
<h2 id="如何在-swift-中使用-initialize"><a class="header" href="#如何在-swift-中使用-initialize">如何在 Swift 中使用 <code>initialize</code></a></h2>
<p><a href="http://jordansmith.io/handling-the-deprecation-of-initialize/">Handling the Deprecation of initialize()</a></p>
<p><code>load</code> 和 <code>initialize</code> 方法在 Swift 中都不会调用，所以需要一个替代的方案，在 Swift 中也可以起到 <code>load</code> 或者 <code>initialize</code> 的作用。</p>
<p>一个简单的替代方案：</p>
<p>直接在 <code>delegate</code> 的 <code>application(_:didFinishLaunchingWithOptions:)</code> 的方法中调用对应的方法，但是这样会有不少缺点：</p>
<ul>
<li>可能有大量的类需要处理，这会使得 <code>delegate</code> 变得笨重，因为它直接依赖了这些类，即使说把这部分的方法调用挪至单独的功能模块中，这个模块也是直接依赖这些类；</li>
<li>可能说没有权限来获取 <code>delegate</code> ，在只是负责开发其中一小部分或者只是一个 SDK 时会有这种情况发生。</li>
</ul>
<p>一个不简单的替代方案：</p>
<p>这个方案和 <code>load</code> 或者 <code>initialize</code> 方法类似，不需要主动调用，也不会影响 <code>delegate</code> 。</p>
<p>首先定义以下类和协议：</p>
<pre><code class="language-swift">protocol SelfAware: class {
    static func awake()
}

class NothingToSeeHere {

    static func harmlessFunction() {

        let typeCount = Int(objc_getClassList(nil, 0))
        let types = UnsafeMutablePointer&lt;AnyClass?&gt;.allocate(capacity: typeCount)
        let safeTypes = AutoreleasingUnsafeMutablePointer&lt;AnyClass?&gt;(types)
        objc_getClassList(safeTypes, Int32(typeCount))
        for index in 0 ..&lt; typeCount { (types[index] as? SelfAware.Type)?.awake() }
        types.deallocate(capacity: typeCount)

    }

}
</code></pre>
<p>可以看到 <code>harmlessFunction</code> 方法通过 <code>objc_getClassList</code> 来获取所有的类，如果类支持 <code>SelfAware</code> 的 <code>awake</code> 方法，那么就会进行调用，接下来需要无侵入地调用 <code>harmlessFunction</code> 方法：</p>
<pre><code class="language-swift">extension UIApplication {

    private static let runOnce: Void = {
        NothingToSeeHere.harmlessFunction()
    }()

    override open var next: UIResponder? {
        // Called before applicationDidFinishLaunching
        UIApplication.runOnce
        return super.next
    }

} 
</code></pre>
<p>但是这里有个不好的地方，就是需要通过 <code>objc_getClassList</code> 来获取所有的类，也就是只能是 <code>Objective-C</code> 的类，如果是纯 Swift 的类，是不支持的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load"><a class="header" href="#load">load</a></h1>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc">Apple Developer Documentation</a></p>
<p>The order of initialization is as follows:</p>
<ol>
<li>All initializers in any framework you link to.</li>
<li>All <code>+load</code> methods in your image.</li>
<li>All C++ static initializers and C/C++ <code>__attribute__(constructor)</code> functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>
<p>In addition:</p>
<ul>
<li>A class’s <code>+load</code> method is called after all of its superclasses’ <code>+load</code> methods.</li>
<li>A category <code>+load</code> method is called after the class’s own <code>+load</code> method.</li>
</ul>
<p>运行时机： Objective-C 运行时会收集所有 <code>+load</code> 方法的类，然后在镜像加载完成后调用，时机在主函数运行前。</p>
<p>初始化顺序：</p>
<ol>
<li>执行全部链接到的框架中的所有构造器；</li>
<li>镜像（ Image ) 中所有的 <code>+load</code> 方法；</li>
<li>镜像 （ Image ）中所有 C++ 静态构造器，以及 C/C++ 的 <code>__attribute__(constructor)</code> 方法；</li>
<li>执行全部链接到当前框架的全部框架的所有构造器.</li>
</ol>
<p>特点：</p>
<ol>
<li>类的 <code>+load</code> 方法会在父类的 <code>+load</code> 方法调用后再调用；</li>
<li>分类 <code>Category</code> 的 <code>+load</code> 方法会在类的 <code>+load</code> 方法后调用；</li>
<li>Swift 中桥接到 Objective-C 的类不会自动调用 <code>+load</code> 方法。</li>
</ol>
<h2 id="你真的了解-load-方法么"><a class="header" href="#你真的了解-load-方法么">你真的了解 <code>load</code> 方法么？</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md">draveness/analyze</a></p>
<p>详细说明了 <code>+load</code> 方法的调用时机：</p>
<pre><code class="language-c">0  +[XXObject load]
1  call_class_loads()
2  call_load_methods
3  load_images
4  dyld::notifySingle(dyld_image_states, ImageLoader const*)
11 _dyld_start
</code></pre>
<p>在有新的镜像加载后，都会调用 <code>load_images</code> 方法进行回调，这个方法是运行时在 <code>_objc_init</code> 方法中进行注册的：</p>
<pre><code class="language-objectivec">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);
</code></pre>
<p>类的 <code>+load</code> 方法会在父类的 <code>+load</code> 方法调用后再调用：</p>
<pre><code class="language-objectivec">static void schedule_class_load(Class cls)
{
    if (!cls) return;
    // 类是否已经 realized
    assert(cls-&gt;isRealized());
		// 判断类是否有调用过 +load
    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;
		// 递归调用，先执行父类的 +load 方法
    schedule_class_load(cls-&gt;superclass);
		// 添加当前类至列表
    add_class_to_loadable_list(cls);
    // 设置为已调用过 +load
    cls-&gt;setInfo(RW_LOADED); 
}
</code></pre>
<p>分类的 <code>+load</code> 方法在类之后调用：</p>
<pre><code class="language-objectivec">void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    loadMethodLock.assertLocked();

    // 加载中，直接返回
    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        // 调用类的 +load 方法，直到列表为空
        while (loadable_classes_used &gt; 0) {
            // ➡️ 调用类的 +load 方法
            call_class_loads();
        }

        // 调用分类的 +load 方法一次
        more_categories = call_category_loads();

        // 如果有类或者分类未调用 +load 方法，则尝试再调用一次
    } while (loadable_classes_used &gt; 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}
</code></pre>
<p>调用分类 <code>+load</code> 方法时需要确保类已经加载：</p>
<pre><code class="language-objectivec">if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
    (*load_method)(cls, SEL_load);
    cats[i].cat = nil;
}
</code></pre>
<h2 id="ios-中的-load-方法"><a class="header" href="#ios-中的-load-方法">iOS 中的 <code>+load</code> 方法</a></h2>
<p><a href="https://kingcos.me/posts/2019/+load_in_ios/">iOS 中的 +load 方法</a></p>
<p><code>+load</code> 方法的执行时机非常靠前，而且只会执行一次，所以一般来说我们可能会通过 <code>+load</code> 方法来执行一些 <code>hook</code> 操作，但是如果 <code>+load</code> 方法过多或者方法执行时间较长，就会影响增加应用的启动时间，所以在编写 <code>+load</code> 方法时需要非常小心。</p>
<h2 id="监控-load-方法的耗时"><a class="header" href="#监控-load-方法的耗时">监控 <code>+load</code> 方法的耗时</a></h2>
<p>这篇文章讲述了如何监控 <code>+load</code> 方法的耗时：</p>
<p><a href="https://triplecc.github.io/2019/05/27/%E8%AE%A1%E7%AE%97load%E8%80%97%E6%97%B6/">计算 +load 方法的耗时</a></p>
<p>实现有以下这几点需要注意：</p>
<p>dyld 加载的镜像中包含系统的镜像，需要对这块做过滤；</p>
<pre><code class="language-objectivec">static bool isSelfDefinedImage(const char *imageName) {
    return !strstr(imageName, &quot;/Xcode.app/&quot;) &amp;&amp;
    !strstr(imageName, &quot;/Library/PrivateFrameworks/&quot;) &amp;&amp;
    !strstr(imageName, &quot;/System/Library/&quot;) &amp;&amp;
    !strstr(imageName, &quot;/usr/lib/&quot;);
}

static const struct mach_header **copyAllSelfDefinedImageHeader(unsigned int *outCount) {
    unsigned int imageCount = _dyld_image_count();
    unsigned int count = 0;
    const struct mach_header **mhdrList = NULL;
    
    if (imageCount &gt; 0) {
        mhdrList = (const struct mach_header **)malloc(sizeof(struct mach_header *) * imageCount);
        for (unsigned int i = 0; i &lt; imageCount; i++) {
            const char *imageName = _dyld_get_image_name(i);
            if (isSelfDefinedImage(imageName)) {
                const struct mach_header *mhdr = _dyld_get_image_header(i);
                mhdrList[count++] = mhdr;
            }
        }
        mhdrList[count] = NULL;
    }
    
    if (outCount) *outCount = count;
    
    return mhdrList;
}
</code></pre>
<p>如何获取定义了 <code>+load</code> 的类或者分类，在编译时期，包含 <code>+load</code> 的 <code>class</code> 和 <code>category</code> 会写入 Mach-O 文件 data 段的 <code>__objc_nlcslist</code> 和 <code>__objc_nlcatlist</code> 节，可以通过读取这两部分来获取 no lazy class 和 no lazy category 列表，即定义了 <code>+load</code> 方法的类或者分类</p>
<pre><code class="language-objectivec">static NSArray &lt;LMLoadInfo *&gt; *getNoLazyArray(const struct mach_header *mhdr) {
    NSMutableArray *noLazyArray = [NSMutableArray new];
    unsigned long bytes = 0;
    Class *clses = (Class *)getDataSection(mhdr, &quot;__objc_nlclslist&quot;, &amp;bytes);
    for (unsigned int i = 0; i &lt; bytes / sizeof(Class); i++) {
        LMLoadInfo *info = [[LMLoadInfo alloc] initWithClass:clses[i]];
        if (!shouldRejectClass(info.clsname)) [noLazyArray addObject:info];
    }
    
    bytes = 0;
    Category *cats = getDataSection(mhdr, &quot;__objc_nlcatlist&quot;, &amp;bytes);
    for (unsigned int i = 0; i &lt; bytes / sizeof(Category); i++) {
        LMLoadInfo *info = [[LMLoadInfo alloc] initWithCategory:cats[i]];
        if (!shouldRejectClass(info.clsname)) [noLazyArray addObject:info];
    }
    
    return noLazyArray;
}
</code></pre>
<p>hook <code>+load</code> 方法：</p>
<pre><code class="language-objectivec">static void swizzleLoadMethod(Class cls, Method method, LMLoadInfo *info) {
retry:
    do {
        SEL hookSel = getRandomLoadSelector();
        Class metaCls = object_getClass(cls);
        IMP hookImp = imp_implementationWithBlock(^ {
            info-&gt;_start = CFAbsoluteTimeGetCurrent();
            ((void (*)(Class, SEL))objc_msgSend)(cls, hookSel);
            info-&gt;_end = CFAbsoluteTimeGetCurrent();
            if (!--LMAllLoadNumber) printLoadInfoWappers();
        });
        
        BOOL didAddMethod = class_addMethod(metaCls, hookSel, hookImp, method_getTypeEncoding(method));
        if (!didAddMethod) goto retry;
        
        info-&gt;_nSEL = hookSel;
        Method hookMethod = class_getInstanceMethod(metaCls, hookSel);
        method_exchangeImplementations(method, hookMethod);
    } while(0);
}

static void hookAllLoadMethods(LMLoadInfoWrapper *infoWrapper) {
    unsigned int count = 0;
    Class metaCls = object_getClass(infoWrapper.cls);
    Method *methodList = class_copyMethodList(metaCls, &amp;count);
    for (unsigned int i = 0; i &lt; count; i++) {
        Method method = methodList[i];
        SEL sel = method_getName(method);
        const char *name = sel_getName(sel);
        if (!strcmp(name, &quot;load&quot;)) {
            IMP imp = method_getImplementation(method);
            LMLoadInfo *info = [infoWrapper findLoadInfoByImp:imp];
            if (!info) {
                info = [infoWrapper findClassLoadInfo];
                if (!info) continue;
            }
            
            swizzleLoadMethod(infoWrapper.cls, method, info);
        }
    }
    free(methodList);
}
</code></pre>
<p>相应的实现：</p>
<p><a href="https://github.com/tripleCC/Laboratory/tree/master/HookLoadMethods">tripleCC/Laboratory</a></p>
<h2 id="使用-load-进行自动发通知和解耦"><a class="header" href="#使用-load-进行自动发通知和解耦">使用 load 进行自动发通知和解耦</a></h2>
<p><a href="https://blog.sunnyxx.com/2015/03/09/notification-once/">Notification Once</a></p>
<p>利用 <code>+load</code> 的方法调用时机较早，实现 <code>AppDelegate</code> 的瘦身：</p>
<pre><code class="language-objectivec">/// FooModule.m
+ (void)load
{
    __block id observer =
    [[NSNotificationCenter defaultCenter]
     addObserverForName:UIApplicationDidFinishLaunchingNotification
     object:nil
     queue:nil
     usingBlock:^(NSNotification *note) {
         [self setup]; // Do whatever you want
         [[NSNotificationCenter defaultCenter] removeObserver:observer];
     }];
}
</code></pre>
<ul>
<li><code>+ load</code>方法在足够早的时间点被调用；</li>
<li><code>block</code> 版本的通知注册会产生一个<code>__NSObserver *</code>对象用来给外部 <code>remove</code> 观察者；</li>
<li><code>block</code> 对 <code>observer</code> 对象的捕获早于函数的返回，所以若不加<code>__block</code>，会捕获到 <code>nil</code> ；</li>
<li>在 <code>block</code> 执行结束时移除 <code>observer</code> ，无需其他清理工作；</li>
<li>这样，在模块内部就完成了在程序启动点代码的挂载。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">Block</a></h1>
<h2 id="深入研究-block-捕获外部变量和-__block-实现原理"><a class="header" href="#深入研究-block-捕获外部变量和-__block-实现原理">深入研究 Block 捕获外部变量和 __block 实现原理</a></h2>
<p><a href="https://halfrost.com/ios_block/">深入研究 Block 捕获外部变量和 __block 实现原理</a></p>
<p>里面有提到作用域：</p>
<p><img src="programming-languages/Objective-C/media/16295345348106.jpg" alt="" /></p>
<ul>
<li><code>_NSConcreteStackBlock</code> ：只用到外部局部变量、成员属性变量，且没有强指针引用的 <code>block</code> 都是 <code>StackBlock</code> 。 <code>StackBlock</code> 的生命周期由系统控制的，一旦返回之后，就被系统销毁了。</li>
<li><code>_NSConcreteMallocBlock</code> ：有强指针引用或 <code>copy</code> 修饰的成员属性引用的 <code>block</code> 会被复制一份到堆中成为 <code>MallocBlock</code> ，没有强指针引用即销毁，生命周期由程序员控制</li>
<li><code>_NSConcreteGlobalBlock</code> ：没有用到外界变量或只用到全局变量、静态变量的 <code>block</code> 为 <code>_NSConcreteGlobalBlock</code> ，生命周期从创建到应用程序结束。</li>
</ul>
<p><code>__block</code> 结构体 <code>__forwarding</code> ：</p>
<p><img src="programming-languages/Objective-C/media/16295347079014.jpg" alt="" /></p>
<h2 id="block-技巧与底层解析"><a class="header" href="#block-技巧与底层解析">Block 技巧与底层解析</a></h2>
<p><a href="https://triplecc.github.io/2015/07/19/2015-08-27-blockji-qiao-yu-di-ceng-jie-xi/">Block技巧与底层解析</a></p>
<p>Block 的实际结构：</p>
<pre><code class="language-objectivec">/* Revised new layout. */
struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};

struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>
<p><code>_NSConcreteMallocBlock</code> 无法直接创建，只能 <code>_NSConcreteStackBlock</code> 拷贝得到，而 Block 的拷贝最终都会调用 <code>_Block_copy_internal</code> 函数，所以从 <code>_Block_copy_internal</code> 函数中可以得出 <code>_NSConcreteMallocBlock</code> 是如何创建的：</p>
<pre><code class="language-objectivec">static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
	...
    aBlock = (struct Block_layout *)arg;
	...
    // Its a stack block.  Make a copy.
    if (!isGC) {
    	// 申请block的堆内存
        struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
        if (!result) return (void *)0;
        // 拷贝栈中block到刚申请的堆内存中
        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
        // reset refcount
        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
        result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
        // 改变isa指向_NSConcreteMallocBlock，即堆block类型
        result-&gt;isa = _NSConcreteMallocBlock;
        if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
            //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
            (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
        }
        return result;
    }
    else {
        ...
    }
}
</code></pre>
<p>函数通过 <code>memmove</code> 将栈中的 Block 的内容拷贝到了堆中，并使 <code>isa</code> 指向了 <code>_NSConcreteMallocBlock</code> 。</p>
<p>Block 的拷贝代码在 <code>_Block_copy_internal</code> 函数中，根据 Block 的类型不同，拷贝过程中的操作也不同。</p>
<p>栈 Block 的拷贝不仅是拷贝了内容，而且由于从栈拷贝到堆中，还会进行一些额外的操作：</p>
<ol>
<li>往 <code>flags</code> 中并入 <code>BLOCK_NEEDS_FREE</code> ，并将引用计数设置为 1，表示 Block 需要释放，需要自行 <code>release</code> ；</li>
<li>如果有辅助 copy 函数 ( <code>BLOCK_HAS_COPY_DISPOSE</code> )，那么就会调用辅助  copy 函数来拷贝 Block 捕获的变量。</li>
</ol>
<pre><code class="language-objectivec">...
struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;
memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
// reset refcount
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
result-&gt;isa = _NSConcreteMallocBlock;
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
    (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
}
return result;
...
</code></pre>
<p>堆 Block 由于已经拷贝至堆中，所以其拷贝操作比较简单，首先需要判断是否有 <code>BLOCK_FREE</code> ，如果是，则表示是堆 Block ，那么只需要执行 <code>latching_incr_int</code> 操作，将 Block 的引用计数加 1 即可，只需要单纯地改变引用计数：</p>
<pre><code class="language-objectivec">...
if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
      // latches on high
      latching_incr_int(&amp;aBlock-&gt;flags);
      return aBlock;
}
...
</code></pre>
<p>全局 Block 不需要执行任何操作，只是直接返回了传入的 Block ：</p>
<pre><code class="language-objectivec">...
else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
      return aBlock;
}
...
</code></pre>
<pre><code class="language-objectivec">// flags/_flags类型
enum {
        /* See function implementation for a more complete description of these fields and combinations */
        // 是一个对象
        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */
        // 是一个block
        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */
        // 被__block修饰的变量
        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */
        // 被__weak修饰的变量，只能被辅助copy函数使用
        BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */
        // block辅助函数调用（告诉内部实现不要进行retain或者copy）
        BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */
    };

// 设置不同属性对应的flags/_flags值
__block id                   128+3
__weak block id              128+3+16
__block (^Block)             128+7
__weak __block (^Block)      128+7+16

struct Block_byref {
    void *isa;
    struct Block_byref *forwarding;
    int flags; /* refcount; */
    int size;
    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
    void (*byref_destroy)(struct Block_byref *);
    /* long shared[0]; */
};

// 做下对比
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};
</code></pre>
<p><code>__block</code> 将原来的基本类型包装成了对象。因为以上两个结构体的前 4 个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>
<pre><code class="language-objectivec">// 转换成C++代码
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

// _Block_object_assign源码
void _Block_object_assign(void *destAddr, const void *object, const int flags) {
...
    else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
...
}

// _Block_byref_assign_copy源码
static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    // 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
...
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) {
        // 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0
        // 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值
        // static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;
        // 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是包装对象的初始引用计数（栈上持有+堆上持有）
        ...
        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value;
        ...
    }
    // 已经拷贝到堆了，只增加引用计数
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);
    }
    // 普通的赋值，里面最底层就*destptr = value;这句表达式
    _Block_assign(src-&gt;forwarding, (void **)destp);
}
</code></pre>
<p>对象的辅助函数：</p>
<p>没有 <code>__block</code> 修饰：</p>
<pre><code class="language-objectivec">typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}
</code></pre>
<p>首先，在没有 <code>__block</code> 修饰时，对象编译转换的结果如下：</p>
<pre><code class="language-objectivec">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  NSObject *a = __cself-&gt;a; // bound by copy
            a;
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0),
</code></pre>
<p>对象在没有 <code>__block</code> 修饰时，并没有产生 <code>__Block_byref_a_0</code> 结构体，只是将标志位修改为 <code>BLOCK_FIELD_IS_OBJECT</code> 。而在 <code>_Block_object_assign</code> 中对应的判断分支代码如下：</p>
<pre><code class="language-objectivec"> v...
else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {
    _Block_retain_object(object);
    _Block_assign((void *)object, destAddr);
}
...
</code></pre>
<p>Block 在捕获对象时会进行 <code>retain</code> 操作，增加引用计数。</p>
<p>在有 <code>__block</code> 修饰时：</p>
<pre><code class="language-objectivec">typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}

// 转换后：
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 NSObject *a;
};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 33554432, sizeof(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131,....};
Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
}

// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）
static void __Block_byref_id_object_copy_131(void *dst, void *src) {
 _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);
}
static void __Block_byref_id_object_dispose_131(void *src) {
 _Block_object_dispose(*(void * *) ((char*)src + 40), 131);
}
</code></pre>
<p><code>__Block_byref_a_0</code> 新增两个内存管理的辅助函数 <code>__Block_byref_id_object_copy</code> 和 <code>__Block_byref_id_object_dispose</code> 。最后的 <code>131</code> 参数表示 <code>BLOCK_BYREF_CALLER|BLOCK_FIELD_IS_OBJECT</code> ， <code>BLOCK_BYREF_CALLER</code> 用于表明不需要对 <code>__block</code> 修饰的 <code>a</code> 对象进行 <code>retain</code> 或者 <code>copy</code> ：</p>
<pre><code class="language-objectivec">if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {
	...
    else {
        // do *not* retain or *copy* __block variables whatever they are
        _Block_assign((void *)object, destAddr);
    }
}
</code></pre>
<p><code>_Block_byref_assign_copy</code> 函数的以下代码会对上面的辅助函数 <code>__Block_byref_id_object_copy_131</code> 进行调用， <code>570425344</code> 表示 <code>BLOCK_HAS_COPY_DISPOSE|BLOCK_HAS_DESCRIPTOR</code> ，所以会执行以下相关源码：</p>
<pre><code class="language-objectivec">if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    // Trust copy helper to copy everything of interest
    // If more than one field shows up in a byref block this is wrong XXX
    copy-&gt;byref_keep = src-&gt;byref_keep;
    copy-&gt;byref_destroy = src-&gt;byref_destroy;
    (*src-&gt;byref_keep)(copy, src);
}
</code></pre>
<h2 id="一道-block-面试题的深入挖掘"><a class="header" href="#一道-block-面试题的深入挖掘">一道 Block 面试题的深入挖掘</a></h2>
<p><a href="https://juejin.im/post/5eaa2a87e51d454db7436726">一道Block面试题的深入挖掘</a></p>
<p>借由 <code>NSNotificationCenter</code> 和 <code>token</code> 说明实际编码中 Block 需要注意的地方以及原理。</p>
<h2 id="block-语法快速查询"><a class="header" href="#block-语法快速查询">Block 语法快速查询</a></h2>
<p>由于 Objective-C 的 Block 语法实在是太难记了，反观 Swift 😂 ，所以有了这么一个快速查看 Block 语法的网站：</p>
<p><a href="http://fuckingblocksyntax.com/">How Do I Declare A Block in Objective-C?</a></p>
<h2 id="obj-c-中的-block"><a class="header" href="#obj-c-中的-block">Obj-C 中的 Block</a></h2>
<p><a href="https://kingcos.me/posts/2019/block_in_obj-c/">Obj-C 中的 Block</a></p>
<p>Objective-C 中的 Block 相当于匿名函数。</p>
<p>通过 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 转换为 C++ 代码可以查看 Block 的结构体。</p>
<p><code>__main_3_block_impl_0</code> 为具体 Block 对应的 <code>struct</code> ，包含 <code>__block_impl</code> 和 <code>__main_3_block_desc_0</code> 。</p>
<pre><code class="language-objectivec">// Block 实现的结构体
struct __block_impl {
  void *isa;     // isa 指针，即 Block 也是 id 类型，即 Obj-C 对象
  int Flags;     // 标记，默认会被初始化为 0
  int Reserved;  // 保留域（ABI 兼容），默认 0
  void *FuncPtr; // Block 代码块的函数指针
};

// ➡️ Block 结构体
struct __main_3_block_impl_0 {
  struct __block_impl impl;           // 实现（非指针）
  struct __main_3_block_desc_0* Desc; // 描述信息（指针）
  // 构造函数
  __main_3_block_impl_0(void *fp, struct __main_3_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock; // Block 作为 Obj-C 对象，那么 isa 将指向其类对象，即 _NSConcreteStackBlock
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// Block 内代码块封装在该 C 语言静态函数中，函数命名规则：__CALLER_METHOD_NAME_block_func_NUMBER
// 类似 Obj-C 实例方法参数 self 或 C++ 实例方法参数 this，__cself 为指向 Block 结构体的变量
static void __main_3_block_func_0(struct __main_3_block_impl_0 *__cself) {
  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_b9596e_mi_0);
}

// Block 描述信息的结构体静态变量
static struct __main_3_block_desc_0 {
  size_t reserved;   // 保留域，默认 0
  size_t Block_size; // Block 大小，sizeof 整个 Block 结构体 ⬇️
} __main_3_block_desc_0_DATA = { 0, sizeof(struct __main_3_block_impl_0)};

// 主函数
int main_3(int argc, const char * argv[]) {
    // 通过 __main_3_block_impl_0 结构体的构造函数初始化，参数为静态函数和描述信息静态变量的地址，将地址存储在 block 变量中
    // 忽略类型转换：block = &amp;__main_3_block_impl_0(__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));
    void(*block)(void) = ((void (*)())&amp;__main_3_block_impl_0((void *)__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));

    // 执行 Block（参数 block 即静态函数中的参数 __cself）
    // 忽略类型转换：block-&gt;FuncPtr(block);
    // 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);

    return 0;
}
</code></pre>
<p><img src="programming-languages/Objective-C/media/16295350902641.jpg" alt="" /></p>
<p>Block 对于捕获变量的不同也会有不同的处理</p>
<ol>
<li>局部变量，进行值拷贝传递，修改原有的值不影响 Block 所捕获的值；</li>
<li>显式或者隐式捕获 <code>self</code> ，Block 会持有 <code>self</code> 的引用，有可能触发我们常说的循环引用；</li>
<li>静态局部变量， 虽然作用域在代码块内，但是其生命周期是全局的，所以 Block 直接持有对变量的引用；</li>
<li>全局变量，Block 不会捕获，使用时直接进行读取。</li>
</ol>
<p>Block 的类型：</p>
<p><code>__NSGlobalBlock__</code> ，不捕获自动变量，即运行时不依赖上下文，放在内存的数据段 (Data Section) ，和全局变量同一个 Section 。对 <code>__NSGlobalBlock__</code> 执行拷贝后得到的仍是 <code>__NSGlobalBlock__</code> 。</p>
<p><code>__NSStackBlock__</code> ，当 Block 捕获了外界自动变量时，则会被分配在栈区，变成 <code>__NSStackBlock__</code> ，开发者无需关心其生命周期。</p>
<p><code>__NSMallocBlock__</code> ，Block 分配在堆区，需要开发者手动管理其生命周期，ARC 下编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 copy 到堆上，将 Block 的 <code>isa</code> 设置为 <code>_NSConcreteMallocBlock</code> ，以下操作会将 Block copy 到堆上：</p>
<ol>
<li>强指针或者属性指向的 Block ；</li>
<li>Block 作为函数值会自动拷贝；</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code>  的参数时会自动拷贝；</li>
<li>Block 作为 GCD API 参数时会被自动拷贝；</li>
</ol>
<p><code>__block</code> 声明的变量：</p>
<p>Block 内可以直接修改</p>
<p><code>__block</code> 声明会将变量封装为对应的结构体，而不同的变量就会生成不同的结构体。 <code>__block</code> 变量从声明后，无论在 Block 内外去访问均是通过结构体的 <code>__forwarding</code> 指针即 <code>blockVar.__forwarding-&gt;blockVar</code> 。当 <code>__block</code> 变量在栈上时， <code>blockVar.__forwarding-&gt;blockVar</code> 就等同于直接通过 <code>blockVar-&gt;blockVar</code> 来访问的，因为此时 <code>__forwarding</code> 就指向栈上的结构体本身；而当 Block 拷贝到堆上时， <code>__block</code> 变量也会被拷贝到堆上，此时栈上的 <code>__forwarding</code> 将替换为指向堆上的结构体，而堆上的结构体里的 <code>__forwarding</code> 将指向堆上的结构体本身，从而保证后续的数据变动均是在堆上。</p>
<p>上面说到 Block 会生成不同的结构体，也就说使用 Block 实现的功能代码量会较多。</p>
<p><img src="programming-languages/Objective-C/media/16295351225941.jpg" alt="" /></p>
<p>循环引用：</p>
<pre><code class="language-objectivec">typedef void(^BlockType_5)(void);

@interface Foo_9 : NSObject
@property (nonatomic, assign) NSUInteger bar;
@property (nonatomic, copy) BlockType_5 block;
@end

@implementation Foo_9
- (void)dealloc
{
#if !__has_feature(objc_arc)
    [super dealloc];
#endifNSLog(@&quot;dealloc&quot;);
}

- (void)foo_1 {
    // Block 捕获了 self，其强引用了 Block，导致双方都无法释放
    self.block = ^{
        // WARNING: Capturing 'self' strongly in this block is likely to lead to a retain cycle
        NSLog(@&quot;%lu&quot;, (unsigned long)self.bar);
        // WARNING: Block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior
        NSLog(@&quot;%lu&quot;, (unsigned long)_bar); // self-&gt;_bar
    };
}
@end

int main_22(int argc, const char * argv[]) {
#if __has_feature(objc_arc)
    Foo_9 *f = [[Foo_9 alloc] init];
    f.bar = 20;

    f.block = ^{
        // Block 捕获了 f，其强引用了 Block，导致双方都无法释放
        // WARNING: Capturing 'f' strongly in this block is likely to lead to a retain cycle
        NSLog(@&quot;%lu&quot;, (unsigned long)f.bar);
    };

    f.block();
    [f foo_1];

    // Never call dealloc
#endifreturn 0;
}

// OUTPUT:
// 20
</code></pre>
<p><img src="programming-languages/Objective-C/media/16295351549792.jpg" alt="" /></p>
<h2 id="用-block-实现-delegate-方法"><a class="header" href="#用-block-实现-delegate-方法">用 Block 实现 delegate 方法</a></h2>
<p><a href="https://triplecc.github.io/2017/07/28/2017-07-28-blockhe-nsmethodsignature/">用 Block 实现委托方法</a></p>
<p>使用 <code>NSInvocation</code> ，消息转化机制和 Block 结构体获取 <code>NSMethodSignature</code> 。</p>
<p><code>NSInvocation</code> 需要注意的地方：</p>
<p>方法的自定义参数从 index 2 开始，前两个参数是接收消息的对象和方法的 SEL ；</p>
<p><code>-getArgument:atIndex:</code> 和 <code>-getReturnvalue:</code> 方法中获取的对象不会进行 <code>retain</code> ，所以不能直接使用具体的对象指针，只能使用 <code>vod *</code> ：</p>
<pre><code class="language-objectivec">// 错误代码
NSString *bar = nil;
[invocation getArgument:&amp;bar atIndex:2];

NSString *result = nil;
[invocation getReturnValue:&amp;result];

// 正确代码
void *bar = nil;
//__unsafe_unretained NSString *bar = nil;
//__weak NSString *bar = nil;
[invocation getArgument:&amp;bar atIndex:2];

void *result = nil;
//__unsafe_unretained NSString *result = nil;
//__weak NSString *result = nil;
[invocation getReturnValue:&amp;result];
</code></pre>
<p>如果是在两个 <code>NSInvocation</code> 对象间传递参数/返回值，可以直接传入指针获取和设置目标地址：</p>
<pre><code class="language-objectivec">....
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
NSInvocation *shadowInvocation = [NSInvocation invocationWithMethodSignature:signature];
....
void *resultBuffer = malloc(invocation.methodSignature.methodReturnLength);
memset(resultBuffer, 0, invocation.methodSignature.methodReturnLength);

[invocation getReturnValue:resultBuffer];
[shadowInvocation setReturnValue:resultBuffer];
....
free(resultBuffer);
</code></pre>
<p>从协议中获取方法签名，利用 <code>protocol_getMethodDescription</code> 函数，可以获取到描述类型的 C 字符串，再通过这个字符串构造方法签名。针对协议中的接口有 <code>required</code> 和 <code>optional</code> 两种，并且不允许重复这一特点，可以创建构造方法签名的函数：</p>
<pre><code class="language-objectivec">static NSMethodSignature *tbv_getProtocolMethodSignature(Protocol *protocol, SEL selector, BOOL isInstanceMethod) {
    struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, YES, isInstanceMethod);
    if (!methodDescription.name) {
        methodDescription = protocol_getMethodDescription(protocol, selector, NO, isInstanceMethod);
    }
    return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
}
</code></pre>
<p>第三个参数表示是否为 <code>required</code> ，如果从 <code>required</code> 中获取不到对应的 <code>objc_method_description</code> ，再从 <code>optional</code> 中获取：</p>
<p><a href="https://developer.apple.com/documentation/objectivec/1418830-protocol_getmethoddescription">Apple Developer Documentation</a></p>
<p>从 Block 中获取方法签名，虽然苹果没有提供公开的 API 给开发者获取，但是可以通过自定义一个与 Block 结构相同的 <code>struct</code> ，通过这个 <code>struct</code> 来获取方法签名：</p>
<pre><code class="language-objectivec">// Block internals.
typedef NS_OPTIONS(int, TBVBlockFlags) {
    TBVBlockFlagsHasCopyDisposeHelpers = (1 &lt;&lt; 25),
    TBVBlockFlagsHasSignature          = (1 &lt;&lt; 30)
};
typedef struct tbv_block {
    __unused Class isa;
    TBVBlockFlags flags;
    __unused int reserved;
    void (__unused *invoke)(struct tbv_block *block, ...);
    struct {
        unsigned long int reserved;
        unsigned long int size;
        // requires TBVBlockFlagsHasCopyDisposeHelpers
        void (*copy)(void *dst, const void *src);
        void (*dispose)(const void *);
        // requires TBVBlockFlagsHasSignature
        const char *signature;
        const char *layout;
    } *descriptor;
    // imported variables
} *TBVBlockRef;

// 使用自定义的 TBVBlockRef 获取 descriptor
static NSMethodSignature *tbv_signatureForBlock(id block) {
    TBVBlockRef layout = (__bridge TBVBlockRef)(block);
    
    // 没有签名，直接返回空
    if (!(layout-&gt;flags &amp; TBVBlockFlagsHasSignature)) {
        return nil;
    }
    
    // 获取 descriptor 指针
    void *desc = layout-&gt;descriptor;
    
    // 跳过 reserved 和 size 成员
    desc += 2 * sizeof(unsigned long int);
    
    // 如果有 Helpers 函数， 跳过 copy 和 dispose 成员
    if (layout-&gt;flags &amp; TBVBlockFlagsHasCopyDisposeHelpers) {
        desc += 2 * sizeof(void *);
    }
    
    // desc 为 signature 指针的地址，转换下给 objcTypes
    char *objcTypes = (*(char **)desc);
    
    return [NSMethodSignature signatureWithObjCTypes:objcTypes];
}
</code></pre>
<p>为了确保 Block 和方法两者的参数是相同的，需要对两者的签名进行匹配，即检验返回值类型和参数类型是否相同：</p>
<pre><code class="language-objectivec">static BOOL tbv_isCompatibleBlockSignature(NSMethodSignature *blockSignature, NSMethodSignature *methodSignature) {
    NSCParameterAssert(blockSignature);
    NSCParameterAssert(methodSignature);
    
    if ([blockSignature isEqual:methodSignature]) {
        return YES;
    }
    
    // block 参数个数需要小于 method 的参数个数 (针对 block 调用替换 method 调用)
    // 两者返回类型需要一致
    if (blockSignature.numberOfArguments &gt;= methodSignature.numberOfArguments ||
        blockSignature.methodReturnType[0] != methodSignature.methodReturnType[0]) {
        return NO;
    }
    
    // 参数类型需要一致
    BOOL compatibleSignature = YES;
    
    // 自定义参数从第二个开始
    for (int idx = 2; idx &lt; blockSignature.numberOfArguments; idx++) {

        // block 相比 method ，默认参数少了 SEL
        // method: id(@) SEL(:) ....
        // block: block(@?) ....
        const char *methodArgument = [methodSignature getArgumentTypeAtIndex:idx];
        const char *blockArgument = [blockSignature getArgumentTypeAtIndex:idx - 1];
        if (!methodArgument || !blockArgument || methodArgument[0] != blockArgument[0]) {
            compatibleSignature = NO;
            break;
        }
    }
    
    return compatibleSignature;
}
</code></pre>
<p>调用 Block 的 <code>NSInvocation</code> ，由于直接调用的是 <code>delegate</code> 方法，在转发时接收到的是方法对应的 <code>NSInvocation</code> ，所以需要将其的参数和返回值传递给 Block 的 <code>NSInvocation</code> ：</p>
<pre><code class="language-objectivec">- (void)invokeWithMethodInvocation:(NSInvocation *)methodInvocation {
    NSParameterAssert(methodInvocation);
    NSAssert([self.methodSignature isEqual:methodInvocation.methodSignature], @&quot;Method invocation's signature is not compatible with block signature&quot;);
    
    NSMethodSignature *methodSignature = methodInvocation.methodSignature;
    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];
    
    void *argumentBuffer = NULL;
    for (int idx = 2; idx &lt; methodSignature.numberOfArguments; idx++) {
        
        // 获取参数类型
        const char *type = [methodSignature getArgumentTypeAtIndex:idx];
        NSUInteger size = 0;
        
        // 获取参数大小
        NSGetSizeAndAlignment(type, &amp;size, NULL);
        
        // 参数缓存
        if (!(argumentBuffer = reallocf(argumentBuffer, size))) {
            return;
        }
        
        // 把 method 的参数传递给 block
        [methodInvocation getArgument:argumentBuffer atIndex:idx];
        [blockInvocation setArgument:argumentBuffer atIndex:idx - 1];
    }
    
    // 调用 block
    [blockInvocation invokeWithTarget:self.block];
    
    // 返回值缓存
    if (methodSignature.methodReturnLength &amp;&amp;
        (argumentBuffer = reallocf(argumentBuffer, methodSignature.methodReturnLength))) {
        
        // 把 block 的返回值传递给 method
        [blockInvocation getReturnValue:argumentBuffer];
        [methodInvocation setReturnValue:argumentBuffer];
    }
    
    // 释放缓存
    free(argumentBuffer);
}

// reallocf 函数是 realloc 函数的增强版，它可以在后者无法申请到堆空间时，释放旧的堆空间：
void *reallocf(void *p, size_t s) {
    void *tmp = realloc(p, s);
    if(tmp) return tmp;
    free(p);
    return NULL;
}
</code></pre>
<p>最后是通过消息转发的 <code>forwardInvocaion:</code> 方法进行转发：</p>
<pre><code class="language-objectivec">- (void)forwardInvocation:(NSInvocation *)invocation {
    TBVBlockInvocation *blockInvocation = self.selectorInvocationMap[NSStringFromSelector(invocation.selector)];
    [blockInvocation invokeWithMethodInvocation:invocation];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    return self.selectorInvocationMap[NSStringFromSelector(sel)].methodSignature;
}

- (BOOL)respondsToSelector:(SEL)aSelector {
    return !!self.selectorInvocationMap[NSStringFromSelector(aSelector)];
}
</code></pre>
<h2 id="如何获取-block-捕获的对象"><a class="header" href="#如何获取-block-捕获的对象">如何获取 Block 捕获的对象</a></h2>
<p><a href="https://triplecc.github.io/2019/08/15/%E8%81%8A%E8%81%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%A3%80%E6%B5%8B/">聊聊循环引用的检测</a></p>
<p>由于 Objective-C 使用引用计数作为内存管理方法，且 Block 会强引用所捕获的对象，所以 Block 经常会造成引用循环。本文讲述了如何通过 Block 的布局，捕获变量排序来获取 Block 强引用的对象。</p>
<p>Block 捕获的对象会统一放在 layout 的 <code>descriptor</code> 后面，即 <code>sr_block_layout</code> 结构体的 <code>imported variables</code> 部分，这种操作可以看作在 <code>sr_block_layout</code> 尾部定义了一个 0 长数组，可以根据实际捕获变量的大小，给捕获区域申请对应的内存空间，只不过这一操作由编译器完成 :</p>
<pre><code class="language-objectivec">struct sr_block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct sr_block_descriptor *descriptor;
    char captured[0];
};

// 标志位不一样，这个结构的实际布局也会有差别，这里简单地放在一起好阅读
struct sr_block_descriptor {
    unsigned long reserved; // Block_descriptor_1
    unsigned long size; // Block_descriptor_1
    void (*)(void *dst, void *src);  // Block_descriptor_2 BLOCK_HAS_COPY_DISPOSE
    void (*dispose)(void *); // Block_descriptor_2
    const char *signature; // Block_descriptor_3 BLOCK_HAS_SIGNATURE
    const char *layout; // Block_descriptor_3 contents depend on BLOCK_HAS_EXTENDED_LAYOUT
};
</code></pre>
<p>Block 的捕获区域布局有特定的排序规则：</p>
<p><a href="https://github.com/llvm-mirror/clang/blob/e870496ea61feb01aa0eb4dc599be0ddf2d03878/lib/CodeGen/CGBlocks.cpp#L366-L384">llvm-mirror/clang</a></p>
<p>在对齐字节数 ( <code>alignment</code> ) 不相等时，捕获的实体按照 <code>alignment</code> 降序排序 ( C 结构体比较特殊，即使整体占用空间比指针变量大，也排在对象指针后面)，否则按照以下类型排序：</p>
<ol>
<li><code>__strong</code> 修饰对象指针变量</li>
<li><code>__block</code> 修饰对象指针变量</li>
<li><code>__weak</code> 修饰对象指针变量</li>
<li>其他变量</li>
</ol>
<p>一个例子：</p>
<pre><code class="language-objectivec">NSObject *o1 = [NSObject new];
__weak NSObject *o2 = o1;
__block NSObject *o3 = o1;
unsigned long long j = 4;
int i = 3;
char c = 'a';
void (^blk)(void) = ^{
    i;
    c;
    o1;
    o2;
    o3;
    j;
};
</code></pre>
<p>输出：</p>
<pre><code class="language-objectivec">(lldb) x/69bx layout
0x10200d940: 0x70 0x21 0x7b 0xa6 0xff 0x7f 0x00 0x00
0x10200d948: 0x02 0x00 0x00 0xc3 0x00 0x00 0x00 0x00
0x10200d950: 0xf0 0x1b 0x00 0x00 0x01 0x00 0x00 0x00
0x10200d958: 0xf8 0x20 0x00 0x00 0x01 0x00 0x00 0x00
0x10200d960: 0xa0 0xf6 0x00 0x02 0x01 0x00 0x00 0x00  // o1
0x10200d968: 0x90 0xd9 0x00 0x02 0x01 0x00 0x00 0x00  // o3
0x10200d970: 0xa0 0xf6 0x00 0x02 0x01 0x00 0x00 0x00  // o2
0x10200d978: 0x04 0x00 0x00 0x00 0x00 0x00 0x00 0x00  // j
0x10200d980: 0x03 0x00 0x00 0x00 0x61                 // i c
(lldb) p o1
(NSObject *) $1 = 0x000000010200f6a0
</code></pre>
<p>可以看到，小端模式下，捕获的 o1 和 o2 指针变量值为 <code>0x10200f6a0</code> ，对应内存地址为 <code>0x10200d960</code> 和 <code>0x10200d970</code> ，而 o3 因为被 <code>__block</code> 修饰，编译器为 o3 捕获变量包装了一层 <code>byref</code> 结构，所以其值为 <code>byref</code> 结构的地址 0x102000d990 ，而不是 0x10200f6a0 ，捕获的 j 变量地址为 0x10200d978，i 变量地址为 0x10200d980，c 字符变量紧随其后。</p>
<p>通过分析 <code>descriptor</code> 的 <code>layout</code> 信息则可以获取捕获到的对象个数。</p>
<p><a href="https://github.com/tripleCC/Laboratory/blob/d5d98d343a918d3883a2d5274da212cd44f50414/AppleSources/libclosure-73/Block_private.h#L283-L314">tripleCC/Laboratory</a></p>
<p><a href="https://github.com/llvm-mirror/clang/blob/e5d2fdc902b0fb4e0a8f5a7d549728e1f2a648ad/lib/CodeGen/CGObjCMac.cpp#L2614-L2865">llvm-mirror/clang</a></p>
<pre><code class="language-objectivec">// block
// Extended layout encoding.

// Values for Block_descriptor_3-&gt;layout with BLOCK_HAS_EXTENDED_LAYOUT
// and for Block_byref_3-&gt;layout with BLOCK_BYREF_LAYOUT_EXTENDED

// If the layout field is less than 0x1000, then it is a compact encoding 
// of the form 0xXYZ: X strong pointers, then Y byref pointers, 
// then Z weak pointers.

// If the layout field is 0x1000 or greater, it points to a 
// string of layout bytes. Each byte is of the form 0xPN.
// Operator P is from the list below. Value N is a parameter for the operator.

enum {
    ...
    BLOCK_LAYOUT_NON_OBJECT_BYTES = 1,    // N bytes non-objects
    BLOCK_LAYOUT_NON_OBJECT_WORDS = 2,    // N words non-objects
    BLOCK_LAYOUT_STRONG           = 3,    // N words strong pointers
    BLOCK_LAYOUT_BYREF            = 4,    // N words byref pointers
    BLOCK_LAYOUT_WEAK             = 5,    // N words weak pointers
    ...
};

// clang 
/// InlineLayoutInstruction - This routine produce an inline instruction for the
/// block variable layout if it can. If not, it returns 0. Rules are as follow:
/// If ((uintptr_t) layout) &lt; (1 &lt;&lt; 12), the layout is inline. In the 64bit world,
/// an inline layout of value 0x0000000000000xyz is interpreted as follows:
/// x captured object pointers of BLOCK_LAYOUT_STRONG. Followed by
/// y captured object of BLOCK_LAYOUT_BYREF. Followed by
/// z captured object of BLOCK_LAYOUT_WEAK. If any of the above is missing, zero
/// replaces it. For example, 0x00000x00 means x BLOCK_LAYOUT_STRONG and no
/// BLOCK_LAYOUT_BYREF and no BLOCK_LAYOUT_WEAK objects are captured.`
</code></pre>
<p><code>descriptor-&gt;layout</code> 会包含捕获的对象个数，且会根据 <code>__strong</code> ， <code>__block</code> 和 <code>__weak</code> 进行区分。</p>
<pre><code class="language-objectivec">NSObject *o1 = [NSObject new];
__block NSObject *o3 = o1;
__weak NSObject *o2 = o1;
NSObject *o4 = o1;
... // 5 - 18
NSObject *o19 = o1;
void (^blk)(void) = ^{
    o1;
    o2;
    o3;
    o4;
    ... // 5 - 18
    o19;
};
</code></pre>
<pre><code class="language-objectivec">(lldb) p/x (long)layout-&gt;descriptor-&gt;layout
(long) $0 = 0x0000000100002f44
(lldb) x/8bx layout-&gt;descriptor-&gt;layout
0x100002f44: 0x3f 0x30 0x40 0x50 0x00 0x76 0x31 0x36
</code></pre>
<p>由于结构体的布局顺序在生命时就确定了，无法像 Block 那样在编译时再根据变量类型，修饰符进行调整，所以如果结构体中有类型为对象指针的字段，就需要额外的信息来进行记录，这也会影响 <code>layout</code> 。</p>
<p>使用 <code>__block</code> 修饰的捕获变量首先会转换成 <code>byref</code> 结构，然后再由这个结构去持有实际的变量， Block 只负责管理 <code>byref</code> ：</p>
<pre><code class="language-objectivec">struct sr_block_byref {
    void *isa;
    struct sr_block_byref *forwarding;
    volatile int32_t flags; // contains ref count
    uint32_t size;
    // requires BLOCK_BYREF_HAS_COPY_DISPOSE
    void (*byref_keep)(struct sr_block_byref *dst, struct sr_block_byref *src);
    void (*byref_destroy)(struct sr_block_byref *);
    // requires BLOCK_BYREF_LAYOUT_EXTENDED
    const char *layout;
};
</code></pre>
<p>这里使用 <code>layout</code> 的原因是需要根据不同的捕获变量记录不同的信息，具体的实现可以查看原文。</p>
<p>了解完 Block 的捕获区域的内存布局后，就可以通过内存布局来获取强引用对象了：</p>
<ol>
<li>被 Block 强引用</li>
<li>被 byref 结构强引用</li>
</ol>
<p>完整的代码在这里：</p>
<p><a href="https://github.com/tripleCC/Laboratory/blob/9982b333c6b8d1cd7cb9ed17430906afebf1f8bb/BlockStrongReferenceObject/BlockStrongReferenceObject/SRBlockStrongReferenceCollector.m">tripleCC/Laboratory</a></p>
<h2 id="另一种获取-block-强引用对象的方式"><a class="header" href="#另一种获取-block-强引用对象的方式">另一种获取 Block 强引用对象的方式</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/FBRetainCycleDetector/iOS%20%E4%B8%AD%E7%9A%84%20block%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84.md">draveness/analyze</a></p>
<p><a href="https://github.com/facebook/FBRetainCycleDetector/blob/ecd369ed1e03eb22178199091fecdba6c9964189/FBRetainCycleDetector/Layout/Blocks/FBBlockStrongLayout.m#L29-L102">facebook/FBRetainCycleDetector</a></p>
<p>FBRetainCycleDetector 也提供了获取 Block 强引用对象的功能，与上面的分析 Block 捕获区域的内存布局方式不同，使用了一种比较取巧的方式。</p>
<p>获取 <code>dispose_helper</code> ， <code>dispose_helper</code> 作为 Block 的辅助函数，在 Block 析构时会调用，然后给强引用对象发送 <code>release</code> 消息，借用这个特性进行处理。</p>
<pre><code class="language-objectivec">struct BlockDescriptor {
	unsigned long int reserved;                // NULL
	unsigned long int size;
	// optional helper functions
	void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25)
	void (*dispose_helper)(void *src);         // IFF (1&lt;&lt;25)
	const char *signature;                     // IFF (1&lt;&lt;30)
};
</code></pre>
<p>另外一个辅助类就是 <code>FBBlockStrongRelationDetector</code> ， <code>FBBlockStrongRelationDetector</code> 重写了 <code>release</code> 方法和新增了一个 <code>trueRelease</code> 方法：</p>
<pre><code class="language-objectivec">- (oneway void)release
{
  _strong = YES;
}

- (oneway void)trueRelease
{
  [super release];
}
</code></pre>
<p><code>FBBlockStrongRelationDetector</code> 同时也可以被当作 Block 来处理，当 Block  中又引用了 Block 时，它会尝试调用 <code>byref_dispose</code> ，所以 <code>FBBlockStrongRelationDetector</code> 也定义了和 Block 相同的变量布局：</p>
<pre><code class="language-objectivec">struct _block_byref_block;
@interface FBBlockStrongRelationDetector : NSObject
{
  // __block fakery
  void *forwarding;
  int flags;   //refcount;
  int size;
  void (*byref_keep)(struct _block_byref_block *dst, struct _block_byref_block *src);
  void (*byref_dispose)(struct _block_byref_block *);
  void *captured[16];
}
</code></pre>
<p>在获取强引用对象索引的实现中，会在自动释放迟中执行 <code>dispose_helper(obj)</code> 方法，给每个 强引用对象对应的 <code>FBBlockStrongRelationDetector</code> 发送 <code>release</code> 消息，这样就可以拿到它们的索引值，从而获取对应的对象。</p>
<pre><code class="language-objectivec">static NSIndexSet *_GetBlockStrongLayout(void *block) {
	...
	void (*dispose_helper)(void *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;
	const size_t ptrSize = sizeof(void *);	
	const size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize;
	
	void *obj[elements];
	void *detectors[elements];
	
	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];
		obj[i] = detectors[i] = detector;
	}
	
	@autoreleasepool {
		dispose_helper(obj);
	}
	NSMutableIndexSet *layout = [NSMutableIndexSet indexSet];
	
	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);
		if (detector.isStrong) {
			[layout addIndex:i];
		}
		
		[detector trueRelease];
	}
	
	return layout;
}
</code></pre>
<h2 id="llvm-关于-block-的文档"><a class="header" href="#llvm-关于-block-的文档">LLVM 关于 Block 的文档</a></h2>
<p><a href="https://clang.llvm.org/docs/Block-ABI-Apple.html">Clang 12 documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="category"><a class="header" href="#category">Category</a></h1>
<h2 id="官方文档-1"><a class="header" href="#官方文档-1">官方文档</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html">Category</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24925196">Objective-C Category</a></p>
<p>Category 的作用：</p>
<ol>
<li>为已存在的类添加方法；</li>
<li>将类的实现分开在不同的代码文件里，减少单个代码文件的行数，将不同的功能组织到不同的 Category ，可以由多个开发者共同开发同一个类，按需加载对应的 Category ；</li>
<li>声明私有方法，借此将私有方法公开，方便调用；</li>
<li>模拟多继承；</li>
<li>Method Swizzling ；</li>
<li>结合 Associated Objects 和 Category 给已有的类新增 Property ；</li>
<li>覆盖主类的实现（也可以说是副作用）。</li>
</ol>
<h2 id="深入理解-category"><a class="header" href="#深入理解-category">深入理解 Category</a></h2>
<p><a href="https://tech.meituan.com/2015/03/03/diveintocategory.html">深入理解Objective-C：Category</a></p>
<p>深入解析 Category ：</p>
<ol>
<li>Category 和 Extension 的不同；</li>
<li>源码解析，Category 生成的 <code>sturct</code> ；</li>
<li>Category 的属性，方法等是如何在通过 runtime 追加到主类中；</li>
<li>Category 的加载顺序；</li>
<li>Category 与 Associated Objects 。</li>
</ol>
<p>如何调用被覆盖掉的主类方法：</p>
<pre><code class="language-objectivec">Class currentClass = [MyClass class];
MyClass *my = [[MyClass alloc] init];

if (currentClass) {
    unsigned int methodCount;
    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);
    IMP lastImp = NULL;
    SEL lastSel = NULL;
    for (NSInteger i = 0; i &lt; methodCount; i++) {
        Method method = methodList[i];
        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) 
        								encoding:NSUTF8StringEncoding];
        if ([@&quot;printName&quot; isEqualToString:methodName]) {
            lastImp = method_getImplementation(method);
            lastSel = method_getName(method);
        }
    }
    typedef void (*fn)(id,SEL);
    
    if (lastImp != NULL) {
        fn f = (fn)lastImp;
        f(my,lastSel);
    }
    free(methodList);
}
</code></pre>
<p>这里是顺序遍历，可以使用逆序遍历，找到第一个 IMP 就返回，会快那么一点点。</p>
<h2 id="ios-中的-category"><a class="header" href="#ios-中的-category">iOS 中的 Category</a></h2>
<p><a href="https://kingcos.me/posts/2019/category_in_ios/">iOS 中的 Category</a></p>
<p>这篇文章非常详细，从 <code>realloc</code> 到 <code>memmove</code> 和 <code>memcpy</code> 都有讲：</p>
<p><img src="programming-languages/Objective-C/media/16295354687549.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-sending--forwarding"><a class="header" href="#message-sending--forwarding">Message Sending &amp; Forwarding</a></h1>
<h2 id="消息发送与转发"><a class="header" href="#消息发送与转发">消息发送与转发</a></h2>
<p><a href="https://halfrost.com/objc_runtime_objc_msgsend/">神经病院 Objective-C Runtime 住院第二天--消息发送与转发</a></p>
<p>作者画了一张非常清晰的流程图，可以先看图再看文章。</p>
<p><img src="programming-languages/Objective-C/media/16295369175812.jpg" alt="" /></p>
<h2 id="消息发送与转发机制原理"><a class="header" href="#消息发送与转发机制原理">消息发送与转发机制原理</a></h2>
<p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></p>
<p>这里有说到为什么 <code>objc_msgSend</code> 要使用汇编进行处理：</p>
<p>其实在 <a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Messengers.subproj/objc-msg-x86_64.s">objc-msg-x86_64.s</a> 中包含了多个版本的 <code>objc_msgSend</code> 方法，它们是根据返回值的类型和调用者的类型分别处理的：</p>
<ul>
<li><code>objc_msgSendSuper</code>:向父类发消息，返回值类型为 <code>id</code></li>
<li><code>objc_msgSend_fpret</code>:返回值类型为 floating-point，其中包含 <code>objc_msgSend_fp2ret</code> 入口处理返回值类型为 <code>long double</code> 的情况</li>
<li><code>objc_msgSend_stret</code>:返回值为结构体</li>
<li><code>objc_msgSendSuper_stret</code>:向父类发消息，返回值类型为结构体</li>
</ul>
<p>当需要发送消息时，编译器会生成中间代码，根据情况分别调用 <code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code> 其中之一。</p>
<p>这也是为什么 <code>objc_msgSend</code> 要用汇编语言而不是 OC、C 或 C++ 语言来实现，因为单独一个方法定义满足不了多种类型返回值，有的方法返回 <code>id</code>，有的返回 <code>int</code>。考虑到不同类型参数返回值排列组合映射不同方法签名（method signature）的问题，那 switch 语句得老长了。。。**这些原因可以总结为 <a href="https://en.wikipedia.org/wiki/Calling_convention">Calling Convention</a>，也就是说函数调用者与被调用者必须约定好参数与返回值在不同架构处理器上的存取规则，比如参数是以何种顺序存储在栈上，或是存储在哪些寄存器上。**除此之外还有其他原因，比如其可变参数用汇编处理起来最方便，因为找到 IMP 地址后参数都在栈上。要是用 C++ 传递可变参数那就悲剧了，prologue 机制会弄乱地址（比如 i386 上为了存储 <code>ebp</code> 向后移位 4byte ），最后还要用 epilogue 打扫战场。而且汇编程序执行效率高，在 Objective-C Runtime 中调用频率较高的函数好多都用汇编写的。</p>
<p>还有一张巨详细的图：</p>
<p><img src="programming-languages/Objective-C/media/16295369836049.jpg" alt="" /></p>
<h2 id="消息发送"><a class="header" href="#消息发送">消息发送</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md">draveness/analyze</a></p>
<p>通过断点方式来查看消息发送的调用顺序：</p>
<ol>
<li>缓存命中；</li>
<li>查找当前类的缓存及方法；</li>
<li>查找父类的缓存及方法；</li>
<li>方法决议；</li>
<li>消息转发。</li>
</ol>
<p><code>objc_msgSend</code> 的调用栈：</p>
<pre><code class="language-objectivec">0 lookUpImpOrForward
1 _class_lookupMethodAndLoadCache3
2 objc_msgSend
3 main
4 start
</code></pre>
<h2 id="lets-build-objc_msgsend"><a class="header" href="#lets-build-objc_msgsend">Let's Build <code>objc_msgSend</code></a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html">mikeash.com: Friday Q&amp;A 2012-11-16: Let's Build objc_msgSend</a></p>
<p>Mike Ash 尝试自己实现了 <code>objc_msgSend</code> ，前面部分为了拦截系统 <code>objc_msgSend</code> ，使用的是汇编来实现，当在缓存找不到 IMP 时，改用可维护的 C 来实现，由于找不到缓存的概率较小，和找不到缓存后对速度要求没那么高，所以改用 C 来实现。</p>
<p>伪代码实现：</p>
<pre><code class="language-objectivec">IMP class_getMethodImplementation(Class cls, SEL sel)
{
    IMP imp;
    if (!cls  ||  !sel) return nil;
    imp = lookUpImpOrNil(cls, sel, nil, YES/*initialize*/, YES/*cache*/, YES/*resolver*/);
    // Translate forwarding function to C-callable external version
    if (!imp) {
        return _objc_msgForward;
    }
    return imp;
}
</code></pre>
<h2 id="方法缓存"><a class="header" href="#方法缓存">方法缓存</a></h2>
<p><a href="https://tech.meituan.com/2015/08/12/deep-understanding-object-c-of-method-caching.html">深入理解 Objective-C：方法缓存</a></p>
<p>为什么需要缓存：</p>
<ol>
<li>大部分方法不会只调用一次，而且往往重复的几率较高；</li>
<li>当一个方法在比较“上层”的类中，而使用比较“下层”的对象去调用时，如果没有缓存，整个遍历就会比较耗时。</li>
</ol>
<p>使用散列表来进行缓存，具体代码分析可以查看上面的文章，使用散列表可以加快检索速度。</p>
<h2 id="浅尝-objc_msgsend"><a class="header" href="#浅尝-objc_msgsend">浅尝 <code>objc_msgSend</code></a></h2>
<p><a href="https://kingcos.me/posts/2019/objc_msgsend/">浅尝 objc_msgSend</a></p>
<p>对 <code>objc_msgSend</code> 整体流程进行研究，包括消息发送，动态方法解析以及消息转发三部分。</p>
<h2 id="objective-c-message-forwarding"><a class="header" href="#objective-c-message-forwarding">Objective-C Message Forwarding</a></h2>
<p><a href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objective-c-message-forwarding.html">mikeash.com: Friday Q&amp;A 2009-03-27: Objective-C Message Forwarding</a></p>
<p>当给一个对象发送一个它无法响应的消息时，并不会说直接抛出 <code>unrecognized selector sent to instance</code> 错误，而是会经过一系列的消息转发处理，提供了处理机制。</p>
<h3 id="lazy-method-resolution"><a class="header" href="#lazy-method-resolution">Lazy method resolution</a></h3>
<p>runtime 在发送消息时会查找对应的 <code>IMP</code> ，而 Lazy method resolution 提供了一个延迟到发送消息时才生成对应方法的机制，而不是提前就设置好所有方法。 Lazy method solution 处理消息非常快，当添加完方法后就会走正常的消息处理流程，但是缺少灵活性，无法改变参数，接收对象和返回参数等。在 Lazy method solution 中会调用以下方法：</p>
<pre><code class="language-objectivec">/// 类方法
+ (BOOL)resolveClassMethod:(SEL)sel;
/// 对象方法
+ (BOOL)resolveInstanceMethod:(SEL)sel;
</code></pre>
<p>如果在方法中添加 <code>SEL</code> 的实现和返回 <code>YES</code> ，就会重走消息处理流程，如果返回 <code>NO</code> 就会进入消息转发的下一个流程。</p>
<p>CoreData 就是通过结合 <code>@dynamic</code> 属性，在运行时动态生成 <code>setter</code> 和 <code>getter</code> 方法。</p>
<h3 id="fast-fowarding"><a class="header" href="#fast-fowarding">Fast Fowarding</a></h3>
<p>在 Lazy method resolution 返回 <code>NO</code> 之后，就会走到 Fast Fowarding 流程，调用以下方法：</p>
<pre><code class="language-objectivec">- (id)forwardingTargetForSelector:(SEL)aSelector;
</code></pre>
<p>通过这个方法我们可以返回其它对象来响应这个 <code>SEL</code> ，这里属于消息转发的基础流程，所以性能开销也比较小。通过这个方法，我们可以实现类似于多继承的机制，根据不同的 <code>SEL</code> 返回不同的对象，即使自己当前没有实现对应的 <code>SEL</code> 。</p>
<h3 id="normal-forwarding"><a class="header" href="#normal-forwarding">Normal Forwarding</a></h3>
<p>Normal Forwarding 是消息转发的最后一个处理流程，会相继调用以下两个方法：</p>
<pre><code class="language-objectivec">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel;
- (void)forwardInvocation:(NSInvocation *)inv;
</code></pre>
<p>先调用 <code>methodSignatureForSelector:</code> 方法来返回 <code>NSMethodSignature</code> ， <code>NSMethodSignature</code> 用于生成 <code>NSInvocation</code> ，而 <code>NSInvocation</code> 包含了 <code>Target</code> ， <code>SEL</code> ，所有参数和返回值，它以对象的形式对消息进行了一层封装。然后就会调用 <code>forwardInvocation:</code> 对 <code>NSInvocation</code> 进行处理。 <code>NSInvocation</code> 非常灵活，返回值，处理对象，参数和 <code>SEL</code> 都可以进行改变。下面是一个非常简单的例子，假设我们想给 <code>NSArray</code> 添加一个这样的特性：当给  <code>NSArray</code> 发送消息时，如果 <code>NSArray</code> 无法响应，就查找它里面的元素，找出可以响应的对象并进行发送。</p>
<pre><code class="language-objectivec">@implementation NSArray (ForwardingIteration)

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    NSMethodSignature *sig = [super methodSignatureForSelector:sel];
    if(!sig)
    {
        for(id obj in self)
            if((sig = [obj methodSignatureForSelector:sel]))
                break;
    }
    return sig;
}

- (void)forwardInvocation:(NSInvocation *)inv
{
    for(id obj in self)
        [inv invokeWithTarget:obj];
}

@end
</code></pre>
<p>以上三个流程，性能递减，灵活性递增，可以根据具体需求在对应的流程中进行处理。</p>
<h2 id="消息转发的应用"><a class="header" href="#消息转发的应用">消息转发的应用</a></h2>
<p><a href="https://triplecc.github.io/2017/07/09/2017-07-09-objective-cxiao-xi-zhuan-fa-ying-yong-zhi-ji-chu/">Objective-C 消息转发应用场景摘录</a></p>
<h3 id="weak-proxy"><a class="header" href="#weak-proxy">Weak Proxy</a></h3>
<p><a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m">ibireme/YYKit</a></p>
<p><code>YYWeakProxy</code> 通过弱引用持有对象来避免循环引用，在设置 <code>NSTimer</code> 或者 <code>CADisplayLink</code> 时可以使用，示例代码：</p>
<pre><code class="language-objectivec">@implementation MyView {
    NSTimer *_timer;
}

- (void)initTimer {
    YYWeakProxy *proxy = [YYWeakProxy proxyWithTarget:self];
    _timer = [NSTimer timerWithTimeInterval:0.1 target:proxy selector:@selector(tick:) userInfo:nil repeats:YES];
}

- (void)tick:(NSTimer *)timer {...}
@end
</code></pre>
<h3 id="delegate-proxy"><a class="header" href="#delegate-proxy">Delegate Proxy</a></h3>
<p><a href="https://github.com/Instagram/IGListKit/blob/019b22da07324f5dfdb81863865360937087b95d/Source/IGListKit/Internal/IGListAdapterProxy.m">Instagram/IGListKit</a></p>
<p>内部对代理进行一层封装，可以区分不同的方法，转发给不同的对象，也可以减少胶水代码，不需要手动对每个代理方法进行转发。</p>
<h3 id="multicast-delegate"><a class="header" href="#multicast-delegate">Multicast Delegate</a></h3>
<p><a href="https://github.com/robbiehanson/XMPPFramework/wiki/MulticastDelegate">robbiehanson/XMPPFramework</a></p>
<p>Wiki 里列了一下 <code>Delegate</code> 和 <code>Notification</code> 的优缺点，以及 Multicast Delegate 的特性。</p>
<p><code>Delegate</code> 优点：</p>
<ul>
<li>注册多个回调方法更加容易；</li>
<li>处理多个参数时更加容易和简单；</li>
<li>允许返回值。</li>
</ul>
<p><code>Delegate</code> 缺点：</p>
<ul>
<li>只能有一个 <code>Delegate</code> 。</li>
</ul>
<p><code>Notification</code> 优点：</p>
<ul>
<li>多个对象可以响应同一个通知。</li>
</ul>
<p><code>Notification</code> 缺点：</p>
<ul>
<li>注册多个回调时非常麻烦；</li>
<li>从 <code>Dictionary</code> 里取出参数时也十分麻烦；</li>
<li>不支持返回值。</li>
</ul>
<p>Multicast Delegate 支持的特性：</p>
<ul>
<li>支持多个回调对象，即广播给所有监听者；</li>
<li>良好的扩展性，支持定义不同的 <code>Delegate</code> ；</li>
<li>支持返回值；</li>
<li>线程安全。</li>
</ul>
<p>核心原理就是在 <code>methodSignatureForSelector:</code> 和 <code>forwardInvocation:</code> 中进行调用 <code>delegates</code> 中对应的方法，具体实现可以查看源代码：</p>
<p><a href="https://github.com/robbiehanson/XMPPFramework/blob/master/Utilities/GCDMulticastDelegate.m">robbiehanson/XMPPFramework</a></p>
<h3 id="nsundomanager"><a class="header" href="#nsundomanager">NSUndoManager</a></h3>
<p><code>NSUndoManager</code> 通过 <code>NSInvocation</code> 记录 <code>undo</code> 时需要执行的方法，当 <code>undo</code> 时就触发最新的 <code>NSInvocation</code> 。</p>
<h3 id="aspects"><a class="header" href="#aspects">Aspects</a></h3>
<p><a href="https://github.com/steipete/Aspects">steipete/Aspects</a></p>
<p>核心原理：</p>
<ol>
<li>对 <code>-forwardInvocation:</code> 进行 hook ，以便在执行原函数前后进行一些操作；</li>
<li>对需要处理的方法进行 hook ，替换为 <code>_objc_msgForward</code> 或者 <code>_objc_msgForward_stret</code> ，这样就会触发消息转发机制，执行 <code>-forwardInvocation:</code> 。</li>
</ol>
<p>具体的源码解析：</p>
<p><a href="https://dirtmelon.github.io/posts/Aspects/">Aspects</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvo"><a class="header" href="#kvo">KVO</a></h1>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA">Introduction to Key-Value Observing Programming Guide</a></p>
<p>开启 KVO 需要严格遵循以下 3 个步骤：</p>
<ol>
<li>使用 <code>addObserver:forKeyPath:options:context:</code> 方法注册监听者；</li>
<li>在监听类中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来接收通知；</li>
<li>当不需要接收时，需要调用 <code>removeObserver:forKeyPath:</code> 。在监听者 <code>dealloc</code> 方法中需要调用这个方法来移除监听。</li>
</ol>
<p>其它：</p>
<p><code>automaticallyNotifiesObserversForKey:</code> 默认返回 <code>YES</code> ，当重写并对某个 <code>Key</code> 返回 <code>NO</code> 时，那么修改属性时就需要手动调用 <code>(void)willChangeValueForKey:(NSString *)key</code> 与 <code>-(void)didChangeValueForKey:(NSString *)key</code> 发送通知，我们也可以通过这样在 <code>Setter</code> 方法判断对象是否真的发生改变，只有真的发生改变时才发送通知。</p>
<h2 id="kvo-详解"><a class="header" href="#kvo-详解">KVO 详解</a></h2>
<p><a href="https://kingcos.me/posts/2019/kvo_in_ios/">iOS 中的 KVO</a></p>
<p>这篇文章非常详细，从 <code>KVO</code> 的使用到原理都进行了说明。</p>
<h2 id="kvc-和-kvo"><a class="header" href="#kvc-和-kvo">KVC 和 KVO</a></h2>
<p><a href="https://objccn.io/issue-7-3/">ObjC 中国 - KVC 和 KVO</a></p>
<p>一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者 RunLoop 的处理。</p>
<p><a href="https://github.com/objcio/issue-7-lab-color-space-explorer/blob/master/Lab%20Color%20Space%20Explorer/KeyValueObserver.m">objcio/issue-7-lab-color-space-explorer</a></p>
<h2 id="friday-qa-about-kvo"><a class="header" href="#friday-qa-about-kvo">Friday Q&amp;A About KVO</a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html">mikeash.com: Friday Q&amp;A 2009-01-23</a></p>
<p>Mikeash 关于 KVO 原理的文章：</p>
<ul>
<li>动态生成一个 <code>KVO</code> 的子类，实现了 <code>dealloc</code> ， <code>_isKVOA</code> ， <code>class</code> 方法；</li>
<li>只会生成一个 <code>KVO</code> 子类，对所有监听的属性的设置方法都进行了替换，如果针对不同的属性监听生成不同类，就需要动态生成大量的不同的类，所以苹果选择了只生成一个类；</li>
<li>替换了对应的方法的 <code>IMP</code> ，改用内部的 <code>NSSet...ValueAndNotify</code> ；</li>
</ul>
<h2 id="key-value-observing-done-right"><a class="header" href="#key-value-observing-done-right">Key-Value Observing Done Right</a></h2>
<p><a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html">mikeash.com: Key-Value Observing Done Right</a></p>
<p>Mikeash 先是吹捧了一下 KVO 机制，非常强大和好用，但是 API 设计非常糟糕：</p>
<ol>
<li><code>-addObserver:forKeyPath:options:context:</code> 不支持 <code>selector</code> 参数，对比 <code>NSNotificationCenter</code> 的设计，可谓高下立判， KVO 必须要在  <code>-observeValueForKeyPath:ofObject:change:context:</code> 中处理消息或者传递给父类；</li>
<li>因为不支持 <code>selector</code> 参数，所以如果在相同的 <code>observer</code> 监听相同的 <code>KeyPath</code> 时，需要通过 <code>context</code> 参数来进行区分；</li>
<li><code>-removeObserver:forKeyPath:</code> 不支持 <code>context</code> 参数， KVO 是在 iOS2.0 时增加的，后面在 iOS5.0 新增了 <code>-removeObserver:forKeyPath:context:</code> ，支持 <code>context</code> 参数。</li>
</ol>
<h2 id="kvo-considered-harmful"><a class="header" href="#kvo-considered-harmful">KVO Considered Harmful</a></h2>
<p><a href="https://khanlou.com/2013/12/kvo-considered-harmful/">kvo-considered-harmful</a></p>
<p>KVO 缺点：</p>
<ol>
<li>所有回调都在同一个方法中进行，稍不留意这个方法就会快速膨胀；</li>
<li>使用字符串硬编码，如果被监听的对象修改了属性名，编译期无法察觉；</li>
<li>要求处理父类的 KVO 流程；</li>
<li>移除 observer 时有可能会崩溃；</li>
<li>充斥着大量有可能会失败的操作，作者认为一个好的 API 设计应该起到使用者成功地调用他们，即使没有解释为什么要这样去调用；</li>
<li>流程过于隐藏，没办法追踪数据改变的流程，与 delegate 模式相比， KVO 在 debug 时比较麻烦，且需要在运行时通过 <code>isKindOfClass:</code> 动态判断类型；</li>
<li>有可能造成死循环，如果不小心在回调中修改了监听的属性，那么就会造成死循环，如果说两个属性在不同的 KVO 流程中互相修改，也会造成死循环，且难于 debug ；</li>
<li>KVO 在某些场景下会失效，比如说 <code>__weak</code> 属性，在 <code>__weak</code> 对象被释放时， KVO 是不会去清理对应的监听，导致可能会出现野指针崩溃；</li>
<li>KVO 是一种老旧的模式，在 Apple 平台上，我们可以通过其它方式比如说 Delegate ，Block 和明确的发布/订阅 （ <code>NSNotificationCenter</code> ）方式来解决问题，而不是使用 KVO 这种隐晦的方式。</li>
</ol>
<p>什么时候可以使用 KVO ：</p>
<ol>
<li>Apple 官方要求，比如说 <code>AVPlayer</code> ，要求通过监听 <code>status</code> 属性来获取播放器的状态；</li>
<li>设计相关的 API 给其他开发者使用。</li>
</ol>
<h2 id="刨根问题-kvo-原理"><a class="header" href="#刨根问题-kvo-原理">刨根问题 KVO 原理</a></h2>
<p><a href="https://juejin.im/post/5c22023df265da6124157a25">刨根问底KVO原理</a></p>
<p>通过源码相关的伪代码来探究 <code>KVO</code> 的实现方式，如果需要深入了解 <code>KVO</code> 的原理，可以阅读下这篇文章。 <code>KVO</code> 的原理看起来虽然比较简单，但是实现时还是有不少坑，比如说多线程，系统的具体实现也体现了这一点，通过 <code>pthread_mutex_lock</code> 来保证线程安全。</p>
<h2 id="kvocontroller-解析"><a class="header" href="#kvocontroller-解析">KVOController 解析</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md">draveness/analyze</a></p>
<p><a href="https://github.com/facebookarchive/KVOController">facebookarchive/KVOController</a></p>
<p>为了解决 <code>KVO</code> 非常难用的问题，Facebook 开源了 <code>KVOController</code> ，优点如下：</p>
<ol>
<li>不需要手动移除 <code>observer</code> ，这里利用了关联属性在对象释放时也会被释放的原理，在关联属性的 <code>dealloc</code> 方法中移除 <code>observer</code> ；</li>
<li>支持使用 <code>block</code> ，减少复杂度，添加监听和处理通知的代码可以放在同一处。</li>
</ol>
<h2 id="基于-kvo-hook-子类的方法"><a class="header" href="#基于-kvo-hook-子类的方法">基于 KVO hook 子类的方法</a></h2>
<p><a href="http://satanwoo.github.io/2017/11/27/KVO-Swizzle/">一种基于KVO的页面加载，渲染耗时监控方法</a></p>
<p>在做 <code>ViewController</code> 的耗时检测时，我们需要记录各个 <code>UIViewController</code> 子类对应方法的耗时，如果只是针对 <code>UIViewController</code> 的方法进行 <code>hook</code> ，那么只能记录到 <code>UIViewController</code> 的方法耗时，无法获取子类的方法耗时。</p>
<p>在进行 <code>KVO</code> 时 <code>runtime</code> 实际上会帮你创建一个 <code>KVO</code> 相关的子类，由此可以在初始化时进行一次 <code>KVO</code> 来生成一个新的子类，然后对这个子类方法进行耗时检测。</p>
<p>至于为什么使用 <code>KVO</code> 的方式，下面这篇文章有进行解释，而且也给出了具体实现代码：</p>
<p><a href="https://punmy.cn/2018/06/18/15278496835424.html">巧妙利用KVO实现精准的VC耗时检测</a></p>
<p><a href="https://github.com/panmingyang2009/VCProfiler">panmingyang2009/VCProfiler</a></p>
<h2 id="kvo-在不同的二进制中多个符号并存的-crash-问题"><a class="header" href="#kvo-在不同的二进制中多个符号并存的-crash-问题">KVO 在不同的二进制中多个符号并存的 Crash 问题</a></h2>
<p><a href="http://satanwoo.github.io/2017/09/11/KVO-CRASH/">KVO在不同的二进制中多个符号并存的Crash问题</a></p>
<p>当两个产物都有相同的类名时，比如主二进制和动态库中，这两个类都会被 realize ，都能够被正常调用。</p>
<blockquote>
<p>其原因在于苹果使用的是 <code>two level namespace</code> 的技术。在这种形式下，符号所在的“库”的名称也会作为符号的一部分。链接的时候， <code>staic linker</code> 会标记住在这个符号是来自于哪个库的。这样不仅大大减少了dyld搜索符号所需要的时间，也更好对后续库的更新进行了兼容。</p>
</blockquote>
<p>但是由于全局类表的存在，在动态创建 <code>KVO</code> 的子类时，只能产生一个。所以就导致 <code>allocate</code> 失败，从而引发 <code>register</code> 过程的 Crash 问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvc"><a class="header" href="#kvc">KVC</a></h1>
<h2 id="基础-1"><a class="header" href="#基础-1">基础</a></h2>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">About Key-Value Coding</a></p>
<p><code>KVC</code> 是通过 <code>NSKeyValueCodinng</code> 协议来实现的。当一个对象支持 <code>KVC</code> 时，它的属性可以通过字符串来进行访问。 <code>KVC</code> 对象提供了简单的接口，通过接口和字符串可以访问所有的属性。 <code>KVC</code> 是 Cocoa 中一些功能的基石，如 <code>KVO</code> ， <code>Cocoa</code> 绑定机制， Core Data 等。</p>
<h3 id="用途"><a class="header" href="#用途">用途</a></h3>
<p>只要继承自 <code>NSObject</code> 就可以使用 <code>KVC</code> ， <code>NSObject</code> 已默认支持 <code>NSKeyValueCoding</code> 协议和提供默认的必须方法， <code>KVC</code> 提供了以下特性：</p>
<ul>
<li>获取对象属性。协议定义了一些方法，比如说 <code>valueForKey:</code> 和 <code>setValue:forKey:</code> ，使用字符串作为参数，可以访问到对象的属性或者对属性进行设置；</li>
<li>操作集合属性，跟其它属性一样，提供了对集合属性进行操作的方法，如果需要对集合进行修改， <code>KVC</code> 也提供了独特高效的方法；</li>
<li>集合属性的操作符，当访问对象的集合属性时， <code>KVC</code> 为我们提供了一些操作符，通过这些操作符可以直接对集合获取某些属性，继续计算转换等；</li>
<li>获取非对象属性， <code>KVC</code> 也支持获取非对象属性，包括纯量属性和结构体等，会自动将它们和对象之间进行转换，以便协议的方法进行调用；</li>
</ul>
<h3 id="适配-kvc"><a class="header" href="#适配-kvc">适配 KVC</a></h3>
<p>如果想要你的对象支持 <code>KVC</code> ，那么你需要使得它们遵循 <code>NSKeyValueCoding</code> 协议。幸运的是， <code>NSObject</code> 已经为我们做好一切工作，因此如果你想要使用 <code>KVC</code> ，那么只需要继承自 <code>NSObject</code> 即可。为了保证 <code>KVC</code> 生效，你需要保证对象的存取器和变量名遵守相关的规则。</p>
<h3 id="获取对象属性"><a class="header" href="#获取对象属性">获取对象属性</a></h3>
<p>一个对象会在它的 <code>interface</code> 声明中定义属性，而属性则会分成以下几个分类：</p>
<ul>
<li>属性，系统提供的一些比较简单的值，如纯量属性，字符串， <code>Bool</code> 值等。</li>
<li>一对一关系，对于拥有者来说它们是可变对象。一个对象的属性可以在对象本身不改变的情况下发生改变。举个例子，比如说一个银行客户的对象拥有一个 <code>Person</code> 的 <code>owner</code> 属性， <code>Person</code> 拥有一个地址属性。 <code>owner</code> 就可以在不改变银行客户的引用关系的前提下改变自己的地址属性；</li>
<li>一对多，集合对象，比如说 <code>NSArray</code> 或者 <code>NSSet</code> ，也可以使用其它的一些自定义集合类型；</li>
</ul>
<pre><code class="language-objectivec">@interface BankAccount : NSObject
 
@property (nonatomic) NSNumber* currentBalance;              // An attribute
@property (nonatomic) Person* owner;                         // A to-one relation
@property (nonatomic) NSArray&lt; Transaction* &gt;* transactions; // A to-many relation
 
@end
</code></pre>
<p>为了保持封装性，一个对象会提供为属性提供存取方法作为它的接口。</p>
<pre><code class="language-objectivec">[myAccount setCurrentBalance:@(100.0)];
</code></pre>
<p>这样很直接，但是会缺少灵活性。 <code>KVC</code> 为对象提供了一种通过字符串来获取属性的机制。</p>
<h3 id="通过-keys-或者-keypaths-识别对象的属性"><a class="header" href="#通过-keys-或者-keypaths-识别对象的属性">通过 <code>Keys</code> 或者 <code>KeyPaths</code> 识别对象的属性</a></h3>
<p><code>key</code> 是一个字符串，对应某个属性。通常情况下， <code>key</code> 会跟属性的名字一致。使用  <code>ASCII</code> 编码，不包含空格，以小写字母开头 （当然了，也会有例外，比如说 <code>URL</code> 属性）。</p>
<p>对于 <code>BankAccount</code> 来说，我们可以通过以下属性来设置 <code>currentBalance</code> ：</p>
<pre><code class="language-objectivec">[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];
</code></pre>
<p>实际上，我们可以使用相同的方法，不同的 <code>key</code> 参数来获取 <code>myAccount</code> 对象的所有属性。</p>
<p>我们可以通过 <code>.</code> 来使用 <code>KeyPath</code> 。假设 <code>Person</code> 和 <code>Address</code> 也符合 <code>KVC</code> 规范，我们可以通过 <code>owner.address.street</code> 的方式来访问账户所有者的地址中的街道信息。</p>
<p><code>NSObject</code> 已经实现了 <code>NSKeyValueCoding</code> 协议所需要的方法，所以只需要继承自 <code>NSObject</code> ，就可以得到默认的实现和支持 <code>KVC</code> 。</p>
<ul>
<li><code>valueForKey:</code> ，返回一个以 <code>key</code> 参数来进行命名的属性。如果说属性无法被 <code>key</code> 通过定好的规则搜索到，对象会调用 <code>valueForUndefinedKey:</code> 方法，这个方法的默认实现是抛出一个 <code>NSUndefinedKeyException</code> 异常，但是子类可以通过重写这个方法来更优雅地处理这个场景；</li>
<li><code>valueForKeyPath:</code> ，返回接收器中满足 <code>keyPath</code> 路径的值。所有在这个 <code>keyPath</code> 路径中的对象都需要满足特定的 <code>key</code> 对应的 <code>KVC</code> 机制，如果说 <code>valueForKey:</code> 找不到对应的存取方法，就会收到 <code>valueForUndefinedKey:</code> 消息；</li>
<li><code>dictionaryWithValuesForKeys:</code> ，返回 <code>value</code> 和 <code>key</code> 组成的 <code>NSDictionary</code> ，它会为数组的每个 <code>key</code> 调用 <code>valueForKey:</code> 方法来获取对应的值。</li>
</ul>
<p>集合对象，比如说 <code>NSArray</code> ， <code>NSSet</code> 和 <code>NSDictionary</code> ，不可以包含 <code>nil</code> 。你可以使用 <code>NSNull</code> 对象来替换 <code>nil</code> ， <code>NSNull</code> 提供了一个单例来表示 <code>nil</code> 值。 <code>dictionaryWithValuesForKeys:</code> 和 <code>setValuesForKeysWithDictionary:</code> 会在 <code>NSNull</code> （ dictionary 参数）和 <code>nil</code> （属性）中自动切换。</p>
<p><code>KeyPath</code> 也支持多对一关系，当 <code>key-path</code> 路径中有一对多的关系时，那么就会返回数组。比如说 <code>transactions.payee</code> 会以数组形式返回所有 <code>transactions</code> 中的 <code>payee</code> 对象。</p>
<h3 id="通过-keys-设置属性值"><a class="header" href="#通过-keys-设置属性值">通过 <code>Keys</code> 设置属性值</a></h3>
<p>和 <code>getter</code> 一样， <code>KVC</code> 也提供了一组通用的 <code>setter</code> 方法，由 <code>NSObject</code> 中 <code>NSKeyValueCoding</code> 协议的默认方法提供：</p>
<ul>
<li><code>setValue:forKey:</code> ，使用 <code>value</code> 来设置对象中对应 <code>key</code> 的属性。 <code>setValue:forKey:</code> 的默认实现会自动对 <code>NSNumber</code> 和 <code>NSValue</code> 对象进行解包，把它们转换为对应的纯量和结构体，然后设置到对应的属性中。如果对象中没有和 <code>key</code> 对应的 <code>setter</code> ，那么对象就会调用它自己的 <code>setValue:forUndefinedKey:</code> 方法，这个方法的默认实现会抛出一个 <code>NSUndefinedKeyException</code> 异常。子类可以通过重写这个方法来 实现自定义逻辑。</li>
<li><code>setValue:forKeyPath:</code> ，使用 <code>value</code> 来设置对象中与 <code>keyPath</code> 路径相符的属性。当存在 <code>keyPath</code> 路径上不支持对应的 <code>key</code> 的 <code>KVC</code> 时，就会收到 <code>setValue:forUndefinedKey:</code> 消息。</li>
<li><code>setValuesForKeysWithDictionary:</code> ，批量设置属性，使用 <code>dictionary</code> 中的 <code>key</code> 来指明属性。它通过调用 <code>setValue:forKey:</code> 方法来为每一对 <code>key-value</code> 进行设置，自动将 <code>NSNull</code> 对象替换为 <code>nil</code> 。</li>
</ul>
<p>在默认的实现中，当你尝试设置一个非对象的属性为 <code>nil</code> 时， <code>KVC</code> 会调用 <code>setNilValueForKey:</code> 方法。这个方法的默认实现会抛出一个 <code>NSInvalidArgumentException</code> ，对象可以通过重写这个行为来提供一个默认值或者标记值（ marker value ）。</p>
<p><a href="https://kingcos.me/posts/2019/kvc_in_ios/">iOS 中的 KVC</a></p>
<p>这篇文章有更详细的说明</p>
<p><a href="https://juejin.im/post/6844903934662803464">iOS 开发：『Crash 防护系统』（三）KVC 防护</a></p>
<p><code>KVC</code> 崩溃防护。上面提到 <code>KVC</code> 相关的崩溃，这篇文章中相关防护也是对这些方法进行 <code>hook</code> ，替换掉原来的实现。</p>
<pre><code class="language-objectivec">/********************* NSObject+KVCDefender.h 文件 *********************/
#import &lt;Foundation/Foundation.h&gt;

@interface NSObject (KVCDefender)

@end

/********************* NSObject+KVCDefender.m 文件 *********************/
#import &quot;NSObject+KVCDefender.h&quot;
#import &quot;NSObject+MethodSwizzling.h&quot;

@implementation NSObject (KVCDefender)

// 不建议拦截 `setValue:forKey:` 方法
+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        // 拦截 `setValue:forKey:` 方法，替换自定义实现
        [NSObject yscDefenderSwizzlingInstanceMethod:@selector(setValue:forKey:)
                                       withMethod:@selector(ysc_setValue:forKey:)
                                        withClass:[NSObject class]];

    });
}

- (void)ysc_setValue:(id)value forKey:(NSString *)key {
    if (key == nil) {
        NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages : [&lt;%@ %p&gt; setNilValueForKey]: could not set nil as the value for the key %@.&quot;,NSStringFromClass([self class]),self,key];
        NSLog(@&quot;%@&quot;, crashMessages);
        return;
    }

    [self ysc_setValue:value forKey:key];
}

- (void)setNilValueForKey:(NSString *)key {
    NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages : [&lt;%@ %p&gt; setNilValueForKey]: could not set nil as the value for the key %@.&quot;,NSStringFromClass([self class]),self,key];
    NSLog(@&quot;%@&quot;, crashMessages);
}

- (void)setValue:(id)value forUndefinedKey:(NSString *)key {
    NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages : [&lt;%@ %p&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key: %@,value:%@'&quot;,NSStringFromClass([self class]),self,key,value];
    NSLog(@&quot;%@&quot;, crashMessages);
}

- (nullable id)valueForUndefinedKey:(NSString *)key {
    NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages :[&lt;%@ %p&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key: %@&quot;,NSStringFromClass([self class]),self,key];
    NSLog(@&quot;%@&quot;, crashMessages);
    
    return self;
}

@end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoreleasepool"><a class="header" href="#autoreleasepool">AutoreleasePool</a></h1>
<h2 id="autoreleasepool-解析"><a class="header" href="#autoreleasepool-解析">AutoreleasePool 解析</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.md">draveness/analyze</a></p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>
<p>整个 iOS 的入口都是放到 <code>@autoreleasepool</code> 的 <code>block</code> 中：</p>
<pre><code class="language-objectivec">int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>
<p>然后编译器会将其改写成下面的代码：</p>
<pre><code class="language-objectivec">void *context = objc_autoreleasePoolPush();
// {}中的代码
objc_autoreleasePoolPop(context);
</code></pre>
<p>我们也可以通过手动调用 <code>@autoreleasepool</code> 来创建自己的自动释放池。</p>
<p>RunLoop 每次处理事件时也会创建和释放 <code>autoreleasepool</code> 。App 启动后，会在主线程的 RunLoop 里注册两个 <code>autoreleasepool</code> 相关的 Observer ，其回调的方法都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code> 。</p>
<ol>
<li>第一个 Observer 监听的事件是 Entry ，即将进入 Loop ，会调用 <code>_objc_autoreleasePoolPush()</code> 来创建自动释放池，order 是 -2147483647 ，优先级最高，确保自动释放池的创建在其它回调之前；</li>
<li>第二个 Observer 监听了 BeforeWaiting 事件，当处理完事件即将进入休眠时调用，会调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池，order 是 2147483647 ，优先级最低，确保自动释放池的释放在所有回调之后，同时也会调用 <code>_objc_autoreleasePoolPush()</code> 来创建一个新的自动释放池，以供下一次唤醒使用；</li>
</ol>
<pre><code class="language-objectivec">void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}

void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre>
<p><code>AutoreleasePage</code> 的定义如下：</p>
<pre><code class="language-objectivec">class AutoreleasePoolPage {
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
};
</code></pre>
<p>自动释放池是由一系列的 <code>AutoreleasePoolPage</code> 组成，每个 <code>AutoreleasePoolPage</code> 的大小都是 4096 bit 大小。</p>
<ul>
<li>自动释放池是由 <code>AutoreleasePoolPage</code> 以双向链表的方式实现的</li>
<li>当对象调用 <code>autorelease</code> 方法时，会将对象加入 <code>AutoreleasePoolPage</code> 的栈中</li>
<li>调用 <code>AutoreleasePoolPage::pop</code> 方法会向栈中的对象发送 <code>release</code> 消息</li>
</ul>
<p>当使用容器的 <code>block</code> 枚举时，内部会自动添加一个 <code>AutoreleasePool</code> ：</p>
<pre><code class="language-objectivec">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    // 这里被一个局部@autoreleasepool包围着
}];
</code></pre>
<p>但是普通的 for 循环和 for in 循环中是没有的，所以当遍历中的 <code>autorelease</code> 变量所占用的内存较大时，需要手动添加 <code>@autoreleasepool</code> 。</p>
<h2 id="autoreleasepool-uses-in-swift"><a class="header" href="#autoreleasepool-uses-in-swift"><code>@autoreleasepool</code> uses in Swift</a></h2>
<p><a href="https://swiftrocks.com/autoreleasepool-in-2019-swift.html">@autoreleasepool uses in 2019 Swift</a></p>
<p>本文先是简单的介绍了 <code>autoreleasepool</code> 在 Objective-C 中的使用场景——在循环体中大量创建 <code>autorelease</code> 对象。而 ARC 对 Swift 的优化在过去几年中进步了很多，根据作者的测试，似乎 ARC for Swift 从不调用 <code>autorelease</code> ，而是用多次调用 <code>release</code> 来替代。所以对于纯粹的 Swift 对象我们可能不再需要 <code>autoreleasepool</code> 。但在 Swift 开发中 <code>autoreleasepool</code> 仍然有用，因为在 UIKit 和 Foundation 中仍然存在调用 <code>autorelease</code> 的遗留 <code>Objective-C</code> 类。在 Swift 5.2 上测试确实如此。</p>
<p><a href="https://swifter.tips/autoreleasepool/">Swifter</a></p>
<p>其实对于这个特定的例子，我们并不一定需要加入自动释放。在 Swift 中更提倡的是用初始化方法而不是用像上面那样的类方法来生成对象，而且从 Swift 1.1 开始，因为加入了可以<a href="https://swifter.tips/init-nil/">返回 <code>nil</code> 的初始化方法</a>，像上面例子中那样的工厂方法都已经从 API 中删除了。今后我们都应该这样写：</p>
<pre><code class="language-swift">let data = Data(contentsOfFile: path)
</code></pre>
<p>使用初始化方法的话，我们就不需要面临自动释放的问题了，每次在超过作用域后，自动内存管理都将为我们处理好内存相关的事情。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dealloc"><a class="header" href="#dealloc">dealloc</a></h1>
<h2 id="llvm-关于-dealloc-的说明"><a class="header" href="#llvm-关于-dealloc-的说明">LLVM 关于 <code>dealloc</code> 的说明</a></h2>
<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc">Clang 12 documentation</a></p>
<blockquote>
<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>
</blockquote>
<p><code>dealloc</code> 在最后 <code>release</code> 时调用，但此时实例变量（ <code>Ivars</code> ）并未释放，父类的  <code>dealloc</code> 会在子类的 <code>dealloc</code> 返回后调用。</p>
<blockquote>
<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>
</blockquote>
<p>实例变量会在 <code>root class</code> （根类）的 <code>dealloc</code> 中释放，一般来说就是 <code>NSObject</code> 的 <code>dealloc</code> 方法，释放顺序不确定。</p>
<h3 id="dealloc-调用时机"><a class="header" href="#dealloc-调用时机">dealloc 调用时机</a></h3>
<p><a href="https://zhongwuzw.github.io/2017/09/21/%E8%81%8A%E8%81%8Adealloc/">聊聊dealloc</a></p>
<p>当对象调用 <code>release</code> 方法时会走到 <code>sidetable_release</code> 这个方法中，而 <code>sidetable_release</code> 这个方法会判断是否需要调用 <code>dealloc</code> 方法：</p>
<pre><code class="language-objectivec">uintptr_t objc_object::sidetable_release(bool performDealloc)
{
#if SUPPORT_NONPOINTER_ISA
    assert(!isa.nonpointer);
#endif
    // 找到当前对象所对应的 SideTable
    SideTable&amp; table = SideTables()[this];
    bool do_dealloc = false;
    table.lock();
    // 找到当前对象所对应的引用计数
    RefcountMap::iterator it = table.refcnts.find(this);
    if (it == table.refcnts.end()) {
        // 如果找不到所对应的应用计数，则表示可以执行 dealloc ，
			  // 同时设置对应的值为 SIDE_TABLE_DEALLOCATING
        do_dealloc = true;
        table.refcnts[this] = SIDE_TABLE_DEALLOCATING;
    } else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) {
        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
        // 如果引用计数小于 SIDE_TABLE_DEALLOCATING ，则表示引用计数为 0 ，可以执行 dealloc
        do_dealloc = true;
        it-&gt;second |= SIDE_TABLE_DEALLOCATING;
    } else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) {
        // 引用计数减 1
        it-&gt;second -= SIDE_TABLE_RC_ONE;
    }
    table.unlock();
    // 进行释放操作，执行 dealloc
    if (do_dealloc  &amp;&amp;  performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
    }
    return do_dealloc;
}
</code></pre>
<p><code>dealloc</code> 有可能在任何线程调用，在最后一个调用 <code>release</code> 方法的线程中调用。</p>
<p>函数调用顺序： <code>dealloc-&gt;_objc_rootDealloc-&gt;objc_object::rootDealloc-&gt;object_dispose-&gt;objc_destructInstance</code> ：</p>
<pre><code class="language-objectivec">- (void)dealloc {
    _objc_rootDealloc(self);
}
</code></pre>
<pre><code class="language-objectivec">void _objc_rootDealloc(id obj)
{
    assert(obj);

    obj-&gt;rootDealloc();
}
</code></pre>
<pre><code class="language-objectivec">inline void
objc_object::rootDealloc()
{
    if (isTaggedPointer()) return;  // fixme necessary?
		// 判断 isa 的各个标志位，确认是否需要进行快速释放。
    if (fastpath(isa.nonpointer  &amp;&amp;  
                 !isa.weakly_referenced  &amp;&amp;  
                 !isa.has_assoc  &amp;&amp;  
                 !isa.has_cxx_dtor  &amp;&amp;  
                 !isa.has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        object_dispose((id)this);
    }
}
</code></pre>
<pre><code class="language-objectivec">id object_dispose(id obj)
{
    if (!obj) return nil;

    objc_destructInstance(obj);    
    free(obj);

    return nil;
}
</code></pre>
<pre><code class="language-objectivec">void *objc_destructInstance(id obj)
{
    if (obj) {
        Class isa_gen = _object_getClass(obj);
        class_t *isa = newcls(isa_gen);

        // Read all of the flags at once for performance.
        bool cxx = hasCxxStructors(isa);
        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);

        // This order is important.
        if (cxx) object_cxxDestruct(obj); // 1
        if (assoc) _object_remove_assocations(obj); // 2

        if (!UseGC) objc_clear_deallocating(obj); // 3
    }

    return obj;
}
</code></pre>
<ol>
<li><code>object_cxxDestruct</code> 调用 C++ 析构器，释放实例变量；</li>
<li><code>_object_remove_assocations</code> 清除 <code>Associated</code> 对象；</li>
<li><code>objc_clear_deallocating</code> ARC 相关操作，清理 <code>SideTable</code> ， <code>weak</code> 设置为 <code>nil</code> 等。</li>
</ol>
<h2 id="arc-下-dealloc-过程及-cxx_destruct-的探究"><a class="header" href="#arc-下-dealloc-过程及-cxx_destruct-的探究">ARC 下 <code>dealloc</code> 过程及 <code>.cxx_destruct</code> 的探究</a></h2>
<p><a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxx_destruct的探究</a></p>
<p>这篇文章对 <code>.cxx_destruct</code> 做了深入研究，包括 <code>.cxx_destruct</code> 如何释放实例变量，如何调用 <code>[super dealloc]</code> 。这两者都是由编译器帮我们完成，插入这部分的代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-pointer"><a class="header" href="#tagged-pointer">Tagged Pointer</a></h1>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Tagged_pointer">Tagged pointer</a></p>
<p>对象存储在内存中的时候总是内存对齐的，所以它们的地址会是单个指针大小的倍数，通常来说会是 16 的倍数。在 64 位系统中，对象的指针为 64 位整形。后面几位为 0 。由于后面几位一直为 0 。所以我们可以使用后面几位来记录一些事情。</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2013/404/">Advances in Objective-C - WWDC 2013 - Videos - Apple Developer</a></p>
<p>WWDC 2013 上相关介绍，从 36:49 开始。</p>
<p><img src="programming-languages/Objective-C/media/16295382272652.jpg" alt="" /></p>
<ul>
<li>苹果使用 Tagged Pointer 来存储一些比较小的数据，如： <code>NSNumber</code> ， <code>NSDate</code> 和 <code>NSString</code> 等；</li>
<li>由于直接使用指针本身来存储数据，不再需要额外生命周期管理，没有 <code>malloc/free</code> ；</li>
<li>3 倍的空间优化， 106 倍的创建或者销毁速度。</li>
</ul>
<p><img src="programming-languages/Objective-C/media/16295384569038.jpg" alt="" /></p>
<p>使用低位的 <code>bit</code> 来作为标识位。</p>
<h2 id="tagged-pointer-解析"><a class="header" href="#tagged-pointer-解析">Tagged Pointer 解析</a></h2>
<p><a href="https://wenghengcong.com/posts/b6becb26/">内存管理（二）Tagged Pointer</a></p>
<p><a href="https://juejin.cn/post/6844904132940136462">iOS - 老生常谈内存管理（五）：Tagged Pointer</a></p>
<p>由于内存对齐的关系，指针的值最后四位都是 0 ，所以可以使用这四位来做一些记录。如果最后一位是 1 ，则这个指针是 Tagged Pointer 。</p>
<pre><code class="language-objectivec">static inline bool 
_objc_isTaggedPointer(const void *ptr) 
{
    return ((intptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
}

#if OBJC_MSB_TAGGED_POINTERS
#   define _OBJC_TAG_MASK (1ULL&lt;&lt;63)
#else
#   define _OBJC_TAG_MASK 1
#endif

#if TARGET_OS_OSX &amp;&amp; __x86_64__
    // 64-bit Mac - tag bit is LSB
#   define OBJC_MSB_TAGGED_POINTERS 0
#else
    // Everything else - tag bit is MSB
#   define OBJC_MSB_TAGGED_POINTERS 1
#endif
</code></pre>
<p>在 iOS 平台上使用的是最高位进行判断，在 macOS 上 使用的是最低位。 Tagged Pointer 支持的类型：</p>
<pre><code class="language-objectivec">enum
{
    OBJC_TAG_NSAtom            = 0, 
    OBJC_TAG_1                 = 1, 
    OBJC_TAG_NSString          = 2, 
    OBJC_TAG_NSNumber          = 3, 
    OBJC_TAG_NSIndexPath       = 4, 
    OBJC_TAG_NSManagedObjectID = 5, 
    OBJC_TAG_NSDate            = 6, 
    OBJC_TAG_RESERVED_7        = 7, 

    OBJC_TAG_First60BitPayload = 0, 
    OBJC_TAG_Last60BitPayload  = 6, 
    OBJC_TAG_First52BitPayload = 8, 
    OBJC_TAG_Last52BitPayload  = 263, 

    OBJC_TAG_RESERVED_264      = 264
};
</code></pre>
<p>Tagged Pointer 不是真的对象，没有 isa 指针，不存在 <code>retain</code> ， <code>release</code> ， <code>autorelease</code> 等对象生命周期管理的流程，其引用计数为 <code>NSUInteger</code> 的最大值。</p>
<pre><code class="language-objectivec">dispatch_queue_t queue = dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i &lt; 1000; i ++) {
    dispatch_async(queue, ^{
        self.name = [NSString stringWithFormat:@&quot;abcdefghijk&quot;];
    })
}
dispatch_queue_t queue = dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i &lt; 1000; i ++) {
    dispatch_async(queue, ^{
        self.name = [NSString stringWithFormat:@&quot;abc&quot;];
    })
}
</code></pre>
<p>上面的代码中，第一个 for 循环会崩溃，因为在多线程中可能会重复 <code>release</code> ，而第二个不会，因为 Tagged Pointer 其实是值类型，不涉及到 <code>retain</code> 和 <code>release</code> 操作，其赋值操作是原子性的。</p>
<h2 id="lets-build-tagged-pointers"><a class="header" href="#lets-build-tagged-pointers">Let's Build Tagged Pointers</a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">mikeash.com: Friday Q&amp;A 2012-07-27: Let's Build Tagged Pointers</a></p>
<p>Mike Ash 尝试自己实现了一个 Tagged Pointer 。</p>
<h2 id="tagged-pointer-strings"><a class="header" href="#tagged-pointer-strings">Tagged Pointer Strings</a></h2>
<p><a href="https://mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html">mikeash.com: Friday Q&amp;A 2015-07-31: Tagged Pointer Strings</a></p>
<p><a href="https://swift.gg/2018/10/08/tagged-pointer-strings/">Tagged Pointer 字符串</a></p>
<p>如果某些字符串可以保存为 60 位以内的二进制数据，那么对应的 <code>NSString</code> 就会被创建为 Tagged Pointer 。</p>
<p>由于 <code>NSString</code> 字符串编码的特殊性，苹果针对 <code>NSString</code> 的 Tagged Pointer 进行优化。</p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<pre><code class="language-objectivec">NSString *a = @&quot;a&quot;;
NSString *b = [[a mutableCopy] copy];
NSLog(@&quot;%p %p %@&quot;, a, b, object_getClass(b));
</code></pre>
<ol>
<li>常量字符串不会被存储为 Tagged Pointer ，因为常量字符串必须保证可以兼容不同的系统，但是 Tagged Pointer 的内部实现细节却不能保证兼容不同的系统，常量字符串嵌入到二进制字符串时有可能会崩溃；</li>
<li>先执行 <code>[a mutableCopy]</code> ，因 <code>copy</code> 返回的是不可变的字符串，所以常量字符串的 <code>copy</code> 得到的还是原来的常量字符串，所以先通过 <code>mutableCopy</code> 生成一个新的可变字符串，然后再通过 <code>copy</code> 得到一个不可变的 Tagged Pointer ， Tagged Pointer 只会在运行时创建。</li>
</ol>
<p>输出结果如下：</p>
<pre><code class="language-objectivec">0x10ba41038 0x6115 NSTaggedPointerString
</code></pre>
<p>首先第一个 <code>a</code> 不是 Tagged Pointer ，是一个对象的指针，第二个是 Tagged Pointer。</p>
<p>然后 <code>NSString</code> 对应的 Tagged Pointer 使用的是 ASCII 编码，占用的长度较少。</p>
<p>伪代码：</p>
<pre><code class="language-objectivec">unsigned short -[NSTaggedPointerString characterAtIndex:](void * self, void * _cmd, unsigned long long index) {
     int8_t buffer[11];
     length = self &gt;&gt; 0x4 &amp; 0xf;
     if (length &gt;= 0x8) {
         stringData = self &gt;&gt; 0x8;
         table = &quot;eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX&quot;;
             cursor = length;
             if (length &lt; 0xa) {
                 do {
                     buffer[cursor - 1] = table[stringData &amp; 0x3f];
                     cursor = cursor - 0x1;
                     stringData = stringData &gt;&gt; 0x6;
                 } while (cursor != 0x0);
             }
             else {
                 do {
                     buffer[cursor - 1] = table[stringData &amp; 0x1f];
                     cursor = cursor - 0x1;
                     stringData = stringData &gt;&gt; 0x5;
                 } while (cursor != 0x0);
             }
     } else {
         *(uint64_t *)buffer = self &gt;&gt; 8;
     }
     if (length &lt;= index) {
         rbx = r8;
         ___CFExceptionProem(self, _cmd);
         [NSException raise:@&quot;NSRangeException&quot; format:@&quot;%@: Index %lu out of bounds; string length %lu&quot;];
         r8 = rbx;
     }
     rax = buffer[index];
     return rax;
 }
</code></pre>
<ol>
<li>长度小于 8 的情况下，直接使用 ASCII 编码，所以 <code>self</code> 按位编译后直接赋值给 <code>buff</code> 即可；</li>
<li>长度大于等于8小于10，就会取出 <code>stringData</code> 的最低 6 位，作为 <code>table</code> 的索引取出相应的值拷贝到 <code>buffer</code> 中，然后将 <code>stringData</code> 右移 6 位，重复操作；</li>
<li>如果大于等于 10 ，那么就会使用 5 位编码，而 <code>table</code> 只使用前半部分。</li>
</ol>
<p>构造 <code>NSString</code> Tagged Pointer 的原理大致上也和上面的一致。</p>
<p>6 位编码表：</p>
<pre><code>eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX
</code></pre>
<p>猜测是按照在英语中出现的频率进行排序，使得尽量多的字符串可以使用 Tagged Pointer 。通过一个简单又巧妙的查找表方式在有限的空间内存储尽量的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weak"><a class="header" href="#weak">weak</a></h1>
<h2 id="实现-1"><a class="header" href="#实现-1">实现</a></h2>
<p><a href="https://triplecc.github.io/2019/03/20/objective-c-weak-implement/">Objective-C weak 弱引用实现</a></p>
<p>作者在文中提供了一个简单版的 <code>weak</code> 实现：</p>
<pre><code class="language-objectivec">// { 对象地址 : [ 对象指针地址1、 对象指针地址1] }
static NSMutableDictionary *weakTable;
@interface A : NSObject
@end
@implementation A
- (void)dealloc {
    // 获取指向此对象的所有指针变量地址
    for (NSNumber *ptrPtrNumber in weakTable[@((uintptr_t)self)]) {
        // 根据指针变量地址，将指针变量置为 nil
        // 这里就是 w1 置 nil
        uintptr_t **ptrPtr = (uintptr_t **)[ptrPtrNumber unsignedLongValue];
        *ptrPtr = nil;
    }
    // 移除和此对象相关的数据
    [weakTable removeObjectForKey:@((uintptr_t)self)];
}
@end
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        weakTable = @{}.mutableCopy;
        __unsafe_unretained NSObject *w1;
        @autoreleasepool {
            NSObject *obj = [A new];
            uintptr_t objAddr = (uintptr_t)obj;

            w1 = obj;
            // 将对象地址和需要自动置 nil 的指针变量的地址保存至 map 中
            // 使用可变数组方便处理多个需要置 nil 的变量指向 obj
            weakTable[@(objAddr)] = @[@((uintptr_t)&amp;w1)].mutableCopy;
            // 即将走出 w1 所在作用域，将 w1 的地址从 map 中清除
            [weakTable[@((uintptr_t)w1)] removeObject:@((uintptr_t)&amp;w1)];
        }
        NSLog(@&quot;%@&quot;, w1);
    }
    return 0;
}

</code></pre>
<p>系统的 <code>weak</code> 实现总结如下：</p>
<blockquote>
<p>设置 <code>__weak</code> 修饰的变量时， runtime 会生成对应的 <code>entry</code> 结构放入 <code>weak hash table</code> 中，以赋值对象地址生成的 <code>hash</code> 值为 <code>key</code> ，以包装 <code>__weak</code> 修饰的指针变量地址的 <code>entry</code> 为 <code>value</code> ，当赋值对象释放时， runtime 会在目标对象的 <code>dealloc</code> 处理过程中，以对象地址（ <code>self</code> ）为 <code>key</code> 去 <code>weak hash table</code> 查找 <code>entry</code> ，置空 <code>entry</code> 指向的的所有对象指针。
实际上 <code>entry</code> 使用数组保存指针变量地址，当地址数量不大于 4 时，这个数组就是个普通的内置数组，在地址数量大于 4 时，这个数组就会扩充成一个 <code>hash table</code> 。
系统会提供一个 <code>SideTable</code> 来关联对象引用和弱引用表，对于一个对象来说这个结构实例是唯一的。一般来说，objc 2.0 的对象引用计数都会优先保存在 <code>isa</code> 的 <code>extra_rc</code> 位段中，只有超出了存储的限制才会将超出部分保存到对应的 <code>SideTable</code> 中， <code>isa</code> 使用 <code>has_sidetable_rc</code> 标记是否超出限制。
系统的实现需要针对 <code>TaggedPointer</code> 进行特殊处理。
<code>weak_entry_t</code> 使用 <code>union</code> 来进行记录，在 <code>wea</code> 指针数量小于 4 个时可以快速访问。</p>
</blockquote>
<p>文章不算很长，但是把创建和销毁流程讲得非常清晰。主要重点在 <code>weak_entry_t</code> 的处理， <code>hash</code> 的计算。</p>
<h2 id="weak-弱引用的实现方式"><a class="header" href="#weak-弱引用的实现方式">weak 弱引用的实现方式</a></h2>
<p><a href="https://www.desgard.com/objective-c/2016/09/10/weak.html">weak 弱引用的实现方式</a></p>
<p>整体流程说得比较清晰，代码注释和解释也比较详细</p>
<p><img src="programming-languages/Objective-C/media/16295391694403.jpg" alt="" /></p>
<h2 id="引用计数与-weak"><a class="header" href="#引用计数与-weak">引用计数与 weak</a></h2>
<p><a href="https://wenghengcong.com/posts/7162dd05/">内存管理（四）引用计数与weak</a></p>
<p><img src="programming-languages/Objective-C/media/16295391908761.jpg" alt="" /></p>
<p><img src="programming-languages/Objective-C/media/16295392026961.jpg" alt="" /></p>
<h2 id="应用-1"><a class="header" href="#应用-1">应用</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/27832890">iOS weak 关键字漫谈</a></p>
<p><code>weak singleton</code> ，当所有持有单例的对象都释放后，单例也会被释放掉，减少内存浪费：</p>
<pre><code class="language-objectivec">- (void)setContext:(CDDContext*)object {
    id __weak weakObject = object;
    id (^block)() = ^{ return weakObject; };
    objc_setAssociatedObject(self, @selector(context), block, OBJC_ASSOCIATION_COPY);
}

- (CDDContext*)context {
    id (^block)() = objc_getAssociatedObject(self, @selector(context));
    id curContext = (block ? block() : nil);
    return curContext;
}
</code></pre>
<p><code>weak associated object</code> ，<code>associated object</code> 本身并不支持添加具备 <code>weak</code> 特性的 <code>property</code> ，但我们可以通过一个小技巧来完成：</p>
<pre><code class="language-objectivec">- (void)setContext:(CDDContext*)object {
    id __weak weakObject = object;
    id (^block)() = ^{ return weakObject; };
    objc_setAssociatedObject(self, @selector(context), block, OBJC_ASSOCIATION_COPY);
}

- (CDDContext*)context {
    id (^block)() = objc_getAssociatedObject(self, @selector(context));
    id curContext = (block ? block() : nil);
    return curContext;
}
</code></pre>
<p>文章最后一段话写得很好：</p>
<blockquote>
<p>编程语言一直处于进化当中，语言的设计者会站在宏观的角度，结合行业的需要，添加更多的方便特性，如果只是记住官方文档里的几个应用场景，而不去思考背后的设计思路，则很难写出有想象力的代码。</p>
</blockquote>
<h2 id="简易版实现"><a class="header" href="#简易版实现">简易版实现</a></h2>
<p><a href="http://samwei12.com/2016/03/09/Objective-C/%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9Fruntime%E4%B8%ADweak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/">如何实现ARC中weak功能？</a></p>
<p><code>weak</code> 的简易版实现。借用 <code>block</code> 和 <code>unsafe_unretained</code> 实现 <code>weak</code> ，在对象 <code>dealloc</code> 时调用 <code>block</code> ，而 <code>block</code> 会将 <code>unsafe_unretained</code> 指针指向 <code>nil</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object"><a class="header" href="#object">Object</a></h1>
<h2 id="objective-c-中的对象"><a class="header" href="#objective-c-中的对象">Objective-C 中的对象</a></h2>
<p><a href="https://kingcos.me//posts/2019/objects_in_obj-c/">Obj-C 中的对象</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae81bfb2-aecc-49ba-97d3-44117f694791/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae81bfb2-aecc-49ba-97d3-44117f694791/Untitled.png" /></p>
<p><code>NSObject</code> 定了 <code>isa</code> 指针，用于指向 <code>Class</code> ，而 <code>Class</code> 本质上则是指向 <code>objc_class</code> 结构体的指针：</p>
<pre><code class="language-objectivec">// NSObject.h

@interface NSObject &lt;NSObject&gt; {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;
    Class isa  OBJC_ISA_AVAILABILITY;
#pragma clang diagnostic pop
}
</code></pre>
<p>而 <code>Class</code> 的本质则是指向 <code>objc_class</code> 结构体的指针，存放了 <code>isa</code> 、 <code>superclass</code> 、方法缓存等。</p>
<pre><code class="language-c">typedef struct objc_class *Class;

// objc-runtime-new.h
struct objc_class : objc_object {
    // Class ISA;
    // 父类指针
    Class superclass;
    // 方法缓存
    cache_t cache;             // formerly cache pointer and vtable
    // 可读可写表（class_rw_t）等
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags

    // ...
};

// objc-private.h
struct objc_object {
private:
    // isa 指针
    isa_t isa;

// ...
}

struct class_data_bits_t {
    // Values are the FAST_ flags above.
    uintptr_t bits;

    class_rw_t* data() {
        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);
    }

    // ...
}
</code></pre>
<p><code>bits</code> 标志位作用：</p>
<ul>
<li>0 - 1 ， <code>FAST_IS_SWIFT_LEGACY</code> ，是否来自 ABI 预稳定版本的 Swift ；</li>
<li>1 - 2 ， <code>FAST_IS_SWIFT_STABLE</code> ，是否来自 ABI 稳定版本的 Swift ；</li>
<li>2 - 3 ， <code>FAST_HAS_DEFAULT_RR</code> ，类或父类含有默认的持有或引用；</li>
<li>3 - 47 ， <code>FAST_DATA_MASK</code> ，指向 <code>class_rw_t</code> 结构体的指针；</li>
<li>47 - 63 ，字节对齐，填 0 。</li>
</ul>
<p><code>class_rw_t</code> 是可读可写， Read-Write ，在运行时会进行调整，而 <code>class_ro_t</code> 是只读的，在编译期已经确定，无法调整。</p>
<pre><code class="language-c">struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    // 只读表的指针（const：不可修改指针指向内存空间中的数据）
    const class_ro_t *ro;

    // 方法、属性、协议信息，可用于运行时动态添加
    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    // ...
};
</code></pre>
<p><code>class_ro_t</code> 在编译时会被动态替换为 <code>class_rw_t</code> ，而 <code>class_rw_t</code> 则会通过指针指向 <code>class_ro_t</code> ：</p>
<pre><code class="language-c">struct class_ro_t {
    // 标志位
    uint32_t flags;
    uint32_t instanceStart;
    // 实例大小
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;

    // 类名
    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    // 成员变量
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
</code></pre>
<p>从上面的 <code>class_rw_t</code> 和 <code>class_ro_t</code> 可以看出为什么 Category 不支持添加变量，因为 Category 相关方法和属性是添加到 <code>class_rw_t</code> 中的，而 <code>class_ro_t</code> 表示的示例大小和属性在编译时已经确定了，不支持在运行时进行修改。</p>
<p>基类：</p>
<p><img src="programming-languages/Objective-C/media/16295434389166.jpg" alt="" /></p>
<h2 id="isa-指针"><a class="header" href="#isa-指针">isa 指针</a></h2>
<p><a href="https://kingcos.me//posts/2019/isa_in_objc/">Obj-C 中的 isa 指针</a></p>
<p><img src="programming-languages/Objective-C/media/16295434244296.jpg" alt="" /></p>
<p>实例对象中的 <code>isa</code> 指向类对象，类对象中的 <code>isa</code> 指向元类对象，元类对象中的 <code>isa</code> 指向根元类对象（包括根元类对象也指向自己）。 <code>isa_t</code> 通过 <code>union</code> 来共享内存占用：</p>
<pre><code class="language-c">struct objc_object {
private:
    isa_t isa;

// ...
}

union isa_t {
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;
#if defined(ISA_BITFIELD)
    struct {
        ISA_BITFIELD;  // defined in isa.h
    };
#endif
};

// isa.h
// ARM 64
# if __arm64__
#   define ISA_MASK        0x0000000ffffffff8ULL
#   define ISA_MAGIC_MASK  0x000003f000000001ULL
#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
#   define ISA_BITFIELD                                                      \
      uintptr_t nonpointer        : 1;                                       \
      uintptr_t has_assoc         : 1;                                       \
      uintptr_t has_cxx_dtor      : 1;                                       \
      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \
      uintptr_t magic             : 6;                                       \
      uintptr_t weakly_referenced : 1;                                       \
      uintptr_t deallocating      : 1;                                       \
      uintptr_t has_sidetable_rc  : 1;                                       \
      uintptr_t extra_rc          : 19
#   define RC_ONE   (1ULL&lt;&lt;45)
#   define RC_HALF  (1ULL&lt;&lt;18)

// _uintptr_t.h
#ifndef _UINTPTR_T
#define _UINTPTR_T
typedef unsigned long           uintptr_t;
#endif /* _UINTPTR_T */
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
