<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Knowledge</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="About.html">关于</a></li><li class="chapter-item expanded "><a href="programming-languages/programming-languages.html">编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-languages/Swift/Swift.html">Swift</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Objective-C.html">Objective-C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Objective-C.html">Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-languages/Objective-C/associated-objects.html">Associated Objects</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/initialize.html">initialize</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/load.html">load</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Block.html">Block</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Category.html">Category</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/KVO.html">KVO</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/KVC.html">KVC</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/AutoreleasePool.html">AutoreleasePool</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/dealloc.html">dealloc</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Tagged-Pointer.html">Tagged Pointer</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/weak.html">weak</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Object.html">Object</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/reference-counting.html">Reference Counting</a></li></ol></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/Objective-C.html">Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-languages/Objective-C/getting-subclasses-of-objective-c-class.html">如何获取某个类的全部子类</a></li><li class="chapter-item expanded "><a href="programming-languages/Objective-C/objective-c-class-properties.html">Objective-C 类属性</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="iDev/iDev.html">iDev</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="iDev/Multithreading/Introduction.html">多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="iDev/Multithreading/NSOperation.html">NSOperation</a></li><li class="chapter-item expanded "><a href="iDev/Multithreading/Grand-Central-Dispatch.html">Grand Central Dispatch</a></li><li class="chapter-item expanded "><a href="iDev/Multithreading/thread.html">pthread 和 NSThread</a></li><li class="chapter-item expanded "><a href="iDev/Multithreading/locks.html">Locks</a></li><li class="chapter-item expanded "><a href="iDev/Multithreading/RunLoop.html">RunLoop</a></li></ol></li><li class="chapter-item expanded "><a href="iDev/UIKit/UIKit.html">UIKit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="iDev/UIKit/touches_presses_and_gestures.html">点击，按压与手势</a></li></ol></li><li class="chapter-item expanded "><a href="iDev/Architectures/Architectures.html">Architectures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="iDev/Architectures/MVC.html">MVC</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="books/books.html">阅读</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="books/Homo-Deus-A-Brief-History-of-Tomorrow.html">未来简史</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Knowledge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dirtmelon/Knowledge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="关于"><a class="header" href="#关于">关于</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程语言"><a class="header" href="#编程语言">编程语言</a></h1>
<ul>
<li><a href="programming-languages/./Swift/Swift.html">Swift</a></li>
<li><a href="programming-languages/./Objective-C/Objective-C.html">Objective-C</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c"><a class="header" href="#objective-c">Objective-C</a></h1>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Runtime 官方文档</a></p>
<ul>
<li><a href="programming-languages/Objective-C/./associated-objects.html">Associated Objects</a></li>
<li><a href="programming-languages/Objective-C/./initialize.html">initialize</a></li>
<li><a href="programming-languages/Objective-C/./load.html">load</a></li>
<li><a href="programming-languages/Objective-C/./Block.html">Block</a></li>
<li><a href="programming-languages/Objective-C/./Category.html">Category</a></li>
<li><a href="programming-languages/Objective-C/./Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li>
<li><a href="programming-languages/Objective-C/./KVO.html">KVO</a></li>
<li><a href="programming-languages/Objective-C/./KVC.html">KVC</a></li>
<li><a href="programming-languages/Objective-C/./AutoreleasePool.html">AutoreleasePool</a></li>
<li><a href="programming-languages/Objective-C/./dealloc.html">dealloc</a></li>
<li><a href="programming-languages/Objective-C/./Tagged-Pointer.html">Tagged Pointer</a></li>
<li><a href="programming-languages/Objective-C/./weak.html">weak</a></li>
<li><a href="programming-languages/Objective-C/./Object.html">Object</a></li>
</ul>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ul>
<li><a href="programming-languages/Objective-C/./getting-subclasses-of-objective-c-class.html">如何获取某个类的全部子类</a></li>
<li><a href="programming-languages/Objective-C/./objective-c-class-properties.html">Objective-C 类属性</a></li>
</ul>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<ul>
<li><a href="https://github.com/oa414/objc-zen-book-cn">禅与 Objective-C 编程艺术</a></li>
<li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0</a></li>
<li><a href="https://book.douban.com/subject/24720270/">Objective-C高级编程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c-1"><a class="header" href="#objective-c-1">Objective-C</a></h1>
<h2 id="runtime-1"><a class="header" href="#runtime-1">Runtime</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Runtime 官方文档</a></p>
<ul>
<li><a href="programming-languages/Objective-C/./associated-objects.html">Associated Objects</a></li>
<li><a href="programming-languages/Objective-C/./initialize.html">initialize</a></li>
<li><a href="programming-languages/Objective-C/./load.html">load</a></li>
<li><a href="programming-languages/Objective-C/./Block.html">Block</a></li>
<li><a href="programming-languages/Objective-C/./Category.html">Category</a></li>
<li><a href="programming-languages/Objective-C/./Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li>
<li><a href="programming-languages/Objective-C/./KVO.html">KVO</a></li>
<li><a href="programming-languages/Objective-C/./KVC.html">KVC</a></li>
<li><a href="programming-languages/Objective-C/./AutoreleasePool.html">AutoreleasePool</a></li>
<li><a href="programming-languages/Objective-C/./dealloc.html">dealloc</a></li>
<li><a href="programming-languages/Objective-C/./Tagged-Pointer.html">Tagged Pointer</a></li>
<li><a href="programming-languages/Objective-C/./weak.html">weak</a></li>
<li><a href="programming-languages/Objective-C/./Object.html">Object</a></li>
</ul>
<h2 id="tips-1"><a class="header" href="#tips-1">Tips</a></h2>
<ul>
<li><a href="programming-languages/Objective-C/./getting-subclasses-of-objective-c-class.html">如何获取某个类的全部子类</a></li>
<li><a href="programming-languages/Objective-C/./objective-c-class-properties.html">Objective-C 类属性</a></li>
</ul>
<h2 id="books-1"><a class="header" href="#books-1">Books</a></h2>
<ul>
<li><a href="https://github.com/oa414/objc-zen-book-cn">禅与 Objective-C 编程艺术</a></li>
<li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0</a></li>
<li><a href="https://book.douban.com/subject/24720270/">Objective-C高级编程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-objects"><a class="header" href="#associated-objects">Associated Objects</a></h1>
<p><a href="https://nshipster.com/associated-objects/">Associated Objects</a></p>
<p>通过以下三个函数可以进行关联对象的相关操作：</p>
<pre><code class="language-objectivec">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
void objc_removeAssociatedObjects(id object);
</code></pre>
<p><code>key</code> 应该是常量的，唯一的，在 <code>setter</code> 和 <code>getter</code> 方法中可以进行访问：</p>
<pre><code class="language-objectivec">static char kAssociatedObjectKey;

objc_getAssociatedObject(self, &amp;kAssociatedObjectKey);
</code></pre>
<p>但是由于 <code>selector</code> 是唯一的，所以可以直接使用 <code>selector</code> ：</p>
<p><a href="https://twitter.com/bbum/status/3609098005">https://twitter.com/bbum/status/3609098005</a></p>
<p>不要调用 <code>objc_removeAssociatedObjects</code> 来移除关联对象，因为会移除所有关联对象。正确的做法是调用 <code>objc_setAssociatedObject</code> 方法并传入 <code>nil</code> 来清除关联。</p>
<blockquote>
<p>比起其他解决问题的方法，关联对象应该被视为最后的选择（事实上关联对象也不应该作为首选方法）。</p>
</blockquote>
<h2 id="associatedobject-解析"><a class="header" href="#associatedobject-解析">AssociatedObject 解析</a></h2>
<p><a href="https://draveness.me/ao/">关联对象 AssociatedObject 完全解析 - 面向信仰编程</a></p>
<ul>
<li>关联对象其实就是 <code>ObjcAssociation</code> 对象</li>
<li>关联对象由 <code>AssociationsManager</code> 管理并在 <code>AssociationsHashMap</code> 存储</li>
<li>对象的指针以及其对应 <code>ObjectAssociationMap</code> 以键值对的形式存储在 <code>AssociationsHashMap</code> 中</li>
<li><code>ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li>
<li>每一个对象都有一个标记位 <code>has_assoc</code> 指示对象是否含有关联对象</li>
</ul>
<h2 id="ios-中的关联对象"><a class="header" href="#ios-中的关联对象">iOS 中的关联对象</a></h2>
<p><a href="https://kingcos.me/posts/2019/associated_objects_in_ios/">iOS 中的关联对象</a></p>
<p><img src="programming-languages/Objective-C/media/16295230050442.jpg" alt="" /></p>
<h3 id="weak-associated-object"><a class="header" href="#weak-associated-object">Weak Associated Object</a></h3>
<p><a href="https://zhangbuhuai.com/post/weak-associated-object.html">Weak Associated Object | 张不坏的博客</a></p>
<p>起一个中间层，叫 container 或者 wrapper 都可以：</p>
<pre><code class="language-objectivec">@interface WeakAssociatedObjectWrapper : NSObject

@property (nonatomic, weak) id object;

@end

@implementation WeakAssociatedObjectWrapper

@end

@interface UIView (ViewController)

@property (nonatomic, weak) UIViewController *vc;

@end

@implementation UIView (ViewController)

- (void)setVc:(UIViewController *)vc {
    WeakAssociatedObjectWrapper *wrapper = [WeakAssociatedObjectWrapper new];
    wrapper.object = vc;
    objc_setAssociatedObject(self, @selector(vc), wrapper, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (UIViewController *)vc {
    WeakAssociatedObjectWrapper *wrapper = objc_getAssociatedObject(self, _cmd);
    return wrapper.object;
}

@end
</code></pre>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p><a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor">ChenYilong/CYLDeallocBlockExecutor</a></p>
<p>通过 <code>Associated Objects</code> 在对象 <code>dealloc</code> 会释放的原理，可以给对象添加一个属性，然后在这个属性 <code>dealloc</code> 时进行相关操作，可以达到对象 <code>dealloc</code> 进行对应操作的目的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialize"><a class="header" href="#initialize">initialize</a></h1>
<h2 id="官方文档"><a class="header" href="#官方文档">官方文档</a></h2>
<p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize">Apple Developer Documentation</a></p>
<ol>
<li><code>initialize</code> 会在第一次给当前类发送消息（即调用方法）时调用；</li>
<li>先调用父类的，再调用子类的；</li>
<li><code>initialize</code> 是线程安全的，它会在第一次给类发送消息的当前线程中运行，而其它线程尝试给类发送消息的线程则需要等待 <code>initialize</code> 执行完毕；</li>
<li>如果子类没有实现 <code>initialize</code> 方法，则会调用父类的，所以一个 <code>initialize</code> 有可能会多次调用，我们可以通过对当前类进行判断来防止多次调用；</li>
<li>因为 <code>initialize</code> 有阻塞机制，所以尽量不要执行复杂的初始化方法，不然有可能会造成死锁；</li>
<li>每个类的 <code>initialize</code> 方法只会调用一次，如果需要分类和类的初始化方法都执行，可以使用 <code>load</code> 方法。</li>
</ol>
<p>如何防止 <code>initialize</code> 方法多次调用：</p>
<pre><code class="language-objectivec">+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre>
<h2 id="源码解析"><a class="header" href="#源码解析">源码解析</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E6%87%92%E6%83%B0%E7%9A%84%20initialize%20%E6%96%B9%E6%B3%95.md">draveness/analyze</a></p>
<p><code>initialize</code> 的源码解析，与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都<strong>已经加载</strong>到了内存中。</p>
<h2 id="如何在-swift-中使用-initialize"><a class="header" href="#如何在-swift-中使用-initialize">如何在 Swift 中使用 <code>initialize</code></a></h2>
<p><a href="http://jordansmith.io/handling-the-deprecation-of-initialize/">Handling the Deprecation of initialize()</a></p>
<p><code>load</code> 和 <code>initialize</code> 方法在 Swift 中都不会调用，所以需要一个替代的方案，在 Swift 中也可以起到 <code>load</code> 或者 <code>initialize</code> 的作用。</p>
<p>一个简单的替代方案：</p>
<p>直接在 <code>delegate</code> 的 <code>application(_:didFinishLaunchingWithOptions:)</code> 的方法中调用对应的方法，但是这样会有不少缺点：</p>
<ul>
<li>可能有大量的类需要处理，这会使得 <code>delegate</code> 变得笨重，因为它直接依赖了这些类，即使说把这部分的方法调用挪至单独的功能模块中，这个模块也是直接依赖这些类；</li>
<li>可能说没有权限来获取 <code>delegate</code> ，在只是负责开发其中一小部分或者只是一个 SDK 时会有这种情况发生。</li>
</ul>
<p>一个不简单的替代方案：</p>
<p>这个方案和 <code>load</code> 或者 <code>initialize</code> 方法类似，不需要主动调用，也不会影响 <code>delegate</code> 。</p>
<p>首先定义以下类和协议：</p>
<pre><code class="language-swift">protocol SelfAware: class {
    static func awake()
}

class NothingToSeeHere {

    static func harmlessFunction() {

        let typeCount = Int(objc_getClassList(nil, 0))
        let types = UnsafeMutablePointer&lt;AnyClass?&gt;.allocate(capacity: typeCount)
        let safeTypes = AutoreleasingUnsafeMutablePointer&lt;AnyClass?&gt;(types)
        objc_getClassList(safeTypes, Int32(typeCount))
        for index in 0 ..&lt; typeCount { (types[index] as? SelfAware.Type)?.awake() }
        types.deallocate(capacity: typeCount)

    }

}
</code></pre>
<p>可以看到 <code>harmlessFunction</code> 方法通过 <code>objc_getClassList</code> 来获取所有的类，如果类支持 <code>SelfAware</code> 的 <code>awake</code> 方法，那么就会进行调用，接下来需要无侵入地调用 <code>harmlessFunction</code> 方法：</p>
<pre><code class="language-swift">extension UIApplication {

    private static let runOnce: Void = {
        NothingToSeeHere.harmlessFunction()
    }()

    override open var next: UIResponder? {
        // Called before applicationDidFinishLaunching
        UIApplication.runOnce
        return super.next
    }

} 
</code></pre>
<p>但是这里有个不好的地方，就是需要通过 <code>objc_getClassList</code> 来获取所有的类，也就是只能是 <code>Objective-C</code> 的类，如果是纯 Swift 的类，是不支持的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load"><a class="header" href="#load">load</a></h1>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc">Apple Developer Documentation</a></p>
<p>The order of initialization is as follows:</p>
<ol>
<li>All initializers in any framework you link to.</li>
<li>All <code>+load</code> methods in your image.</li>
<li>All C++ static initializers and C/C++ <code>__attribute__(constructor)</code> functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>
<p>In addition:</p>
<ul>
<li>A class’s <code>+load</code> method is called after all of its superclasses’ <code>+load</code> methods.</li>
<li>A category <code>+load</code> method is called after the class’s own <code>+load</code> method.</li>
</ul>
<p>运行时机： Objective-C 运行时会收集所有 <code>+load</code> 方法的类，然后在镜像加载完成后调用，时机在主函数运行前。</p>
<p>初始化顺序：</p>
<ol>
<li>执行全部链接到的框架中的所有构造器；</li>
<li>镜像（ Image ) 中所有的 <code>+load</code> 方法；</li>
<li>镜像 （ Image ）中所有 C++ 静态构造器，以及 C/C++ 的 <code>__attribute__(constructor)</code> 方法；</li>
<li>执行全部链接到当前框架的全部框架的所有构造器.</li>
</ol>
<p>特点：</p>
<ol>
<li>类的 <code>+load</code> 方法会在父类的 <code>+load</code> 方法调用后再调用；</li>
<li>分类 <code>Category</code> 的 <code>+load</code> 方法会在类的 <code>+load</code> 方法后调用；</li>
<li>Swift 中桥接到 Objective-C 的类不会自动调用 <code>+load</code> 方法。</li>
</ol>
<h2 id="你真的了解-load-方法么"><a class="header" href="#你真的了解-load-方法么">你真的了解 <code>load</code> 方法么？</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md">draveness/analyze</a></p>
<p>详细说明了 <code>+load</code> 方法的调用时机：</p>
<pre><code class="language-c">0  +[XXObject load]
1  call_class_loads()
2  call_load_methods
3  load_images
4  dyld::notifySingle(dyld_image_states, ImageLoader const*)
11 _dyld_start
</code></pre>
<p>在有新的镜像加载后，都会调用 <code>load_images</code> 方法进行回调，这个方法是运行时在 <code>_objc_init</code> 方法中进行注册的：</p>
<pre><code class="language-objectivec">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);
</code></pre>
<p>类的 <code>+load</code> 方法会在父类的 <code>+load</code> 方法调用后再调用：</p>
<pre><code class="language-objectivec">static void schedule_class_load(Class cls)
{
    if (!cls) return;
    // 类是否已经 realized
    assert(cls-&gt;isRealized());
		// 判断类是否有调用过 +load
    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;
		// 递归调用，先执行父类的 +load 方法
    schedule_class_load(cls-&gt;superclass);
		// 添加当前类至列表
    add_class_to_loadable_list(cls);
    // 设置为已调用过 +load
    cls-&gt;setInfo(RW_LOADED); 
}
</code></pre>
<p>分类的 <code>+load</code> 方法在类之后调用：</p>
<pre><code class="language-objectivec">void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    loadMethodLock.assertLocked();

    // 加载中，直接返回
    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        // 调用类的 +load 方法，直到列表为空
        while (loadable_classes_used &gt; 0) {
            // ➡️ 调用类的 +load 方法
            call_class_loads();
        }

        // 调用分类的 +load 方法一次
        more_categories = call_category_loads();

        // 如果有类或者分类未调用 +load 方法，则尝试再调用一次
    } while (loadable_classes_used &gt; 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}
</code></pre>
<p>调用分类 <code>+load</code> 方法时需要确保类已经加载：</p>
<pre><code class="language-objectivec">if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
    (*load_method)(cls, SEL_load);
    cats[i].cat = nil;
}
</code></pre>
<h2 id="ios-中的-load-方法"><a class="header" href="#ios-中的-load-方法">iOS 中的 <code>+load</code> 方法</a></h2>
<p><a href="https://kingcos.me/posts/2019/+load_in_ios/">iOS 中的 +load 方法</a></p>
<p><code>+load</code> 方法的执行时机非常靠前，而且只会执行一次，所以一般来说我们可能会通过 <code>+load</code> 方法来执行一些 <code>hook</code> 操作，但是如果 <code>+load</code> 方法过多或者方法执行时间较长，就会影响增加应用的启动时间，所以在编写 <code>+load</code> 方法时需要非常小心。</p>
<h2 id="监控-load-方法的耗时"><a class="header" href="#监控-load-方法的耗时">监控 <code>+load</code> 方法的耗时</a></h2>
<p>这篇文章讲述了如何监控 <code>+load</code> 方法的耗时：</p>
<p><a href="https://triplecc.github.io/2019/05/27/%E8%AE%A1%E7%AE%97load%E8%80%97%E6%97%B6/">计算 +load 方法的耗时</a></p>
<p>实现有以下这几点需要注意：</p>
<p>dyld 加载的镜像中包含系统的镜像，需要对这块做过滤；</p>
<pre><code class="language-objectivec">static bool isSelfDefinedImage(const char *imageName) {
    return !strstr(imageName, &quot;/Xcode.app/&quot;) &amp;&amp;
    !strstr(imageName, &quot;/Library/PrivateFrameworks/&quot;) &amp;&amp;
    !strstr(imageName, &quot;/System/Library/&quot;) &amp;&amp;
    !strstr(imageName, &quot;/usr/lib/&quot;);
}

static const struct mach_header **copyAllSelfDefinedImageHeader(unsigned int *outCount) {
    unsigned int imageCount = _dyld_image_count();
    unsigned int count = 0;
    const struct mach_header **mhdrList = NULL;
    
    if (imageCount &gt; 0) {
        mhdrList = (const struct mach_header **)malloc(sizeof(struct mach_header *) * imageCount);
        for (unsigned int i = 0; i &lt; imageCount; i++) {
            const char *imageName = _dyld_get_image_name(i);
            if (isSelfDefinedImage(imageName)) {
                const struct mach_header *mhdr = _dyld_get_image_header(i);
                mhdrList[count++] = mhdr;
            }
        }
        mhdrList[count] = NULL;
    }
    
    if (outCount) *outCount = count;
    
    return mhdrList;
}
</code></pre>
<p>如何获取定义了 <code>+load</code> 的类或者分类，在编译时期，包含 <code>+load</code> 的 <code>class</code> 和 <code>category</code> 会写入 Mach-O 文件 data 段的 <code>__objc_nlcslist</code> 和 <code>__objc_nlcatlist</code> 节，可以通过读取这两部分来获取 no lazy class 和 no lazy category 列表，即定义了 <code>+load</code> 方法的类或者分类</p>
<pre><code class="language-objectivec">static NSArray &lt;LMLoadInfo *&gt; *getNoLazyArray(const struct mach_header *mhdr) {
    NSMutableArray *noLazyArray = [NSMutableArray new];
    unsigned long bytes = 0;
    Class *clses = (Class *)getDataSection(mhdr, &quot;__objc_nlclslist&quot;, &amp;bytes);
    for (unsigned int i = 0; i &lt; bytes / sizeof(Class); i++) {
        LMLoadInfo *info = [[LMLoadInfo alloc] initWithClass:clses[i]];
        if (!shouldRejectClass(info.clsname)) [noLazyArray addObject:info];
    }
    
    bytes = 0;
    Category *cats = getDataSection(mhdr, &quot;__objc_nlcatlist&quot;, &amp;bytes);
    for (unsigned int i = 0; i &lt; bytes / sizeof(Category); i++) {
        LMLoadInfo *info = [[LMLoadInfo alloc] initWithCategory:cats[i]];
        if (!shouldRejectClass(info.clsname)) [noLazyArray addObject:info];
    }
    
    return noLazyArray;
}
</code></pre>
<p>hook <code>+load</code> 方法：</p>
<pre><code class="language-objectivec">static void swizzleLoadMethod(Class cls, Method method, LMLoadInfo *info) {
retry:
    do {
        SEL hookSel = getRandomLoadSelector();
        Class metaCls = object_getClass(cls);
        IMP hookImp = imp_implementationWithBlock(^ {
            info-&gt;_start = CFAbsoluteTimeGetCurrent();
            ((void (*)(Class, SEL))objc_msgSend)(cls, hookSel);
            info-&gt;_end = CFAbsoluteTimeGetCurrent();
            if (!--LMAllLoadNumber) printLoadInfoWappers();
        });
        
        BOOL didAddMethod = class_addMethod(metaCls, hookSel, hookImp, method_getTypeEncoding(method));
        if (!didAddMethod) goto retry;
        
        info-&gt;_nSEL = hookSel;
        Method hookMethod = class_getInstanceMethod(metaCls, hookSel);
        method_exchangeImplementations(method, hookMethod);
    } while(0);
}

static void hookAllLoadMethods(LMLoadInfoWrapper *infoWrapper) {
    unsigned int count = 0;
    Class metaCls = object_getClass(infoWrapper.cls);
    Method *methodList = class_copyMethodList(metaCls, &amp;count);
    for (unsigned int i = 0; i &lt; count; i++) {
        Method method = methodList[i];
        SEL sel = method_getName(method);
        const char *name = sel_getName(sel);
        if (!strcmp(name, &quot;load&quot;)) {
            IMP imp = method_getImplementation(method);
            LMLoadInfo *info = [infoWrapper findLoadInfoByImp:imp];
            if (!info) {
                info = [infoWrapper findClassLoadInfo];
                if (!info) continue;
            }
            
            swizzleLoadMethod(infoWrapper.cls, method, info);
        }
    }
    free(methodList);
}
</code></pre>
<p>相应的实现：</p>
<p><a href="https://github.com/tripleCC/Laboratory/tree/master/HookLoadMethods">tripleCC/Laboratory</a></p>
<h2 id="使用-load-进行自动发通知和解耦"><a class="header" href="#使用-load-进行自动发通知和解耦">使用 load 进行自动发通知和解耦</a></h2>
<p><a href="https://blog.sunnyxx.com/2015/03/09/notification-once/">Notification Once</a></p>
<p>利用 <code>+load</code> 的方法调用时机较早，实现 <code>AppDelegate</code> 的瘦身：</p>
<pre><code class="language-objectivec">/// FooModule.m
+ (void)load
{
    __block id observer =
    [[NSNotificationCenter defaultCenter]
     addObserverForName:UIApplicationDidFinishLaunchingNotification
     object:nil
     queue:nil
     usingBlock:^(NSNotification *note) {
         [self setup]; // Do whatever you want
         [[NSNotificationCenter defaultCenter] removeObserver:observer];
     }];
}
</code></pre>
<ul>
<li><code>+ load</code>方法在足够早的时间点被调用；</li>
<li><code>block</code> 版本的通知注册会产生一个<code>__NSObserver *</code>对象用来给外部 <code>remove</code> 观察者；</li>
<li><code>block</code> 对 <code>observer</code> 对象的捕获早于函数的返回，所以若不加<code>__block</code>，会捕获到 <code>nil</code> ；</li>
<li>在 <code>block</code> 执行结束时移除 <code>observer</code> ，无需其他清理工作；</li>
<li>这样，在模块内部就完成了在程序启动点代码的挂载。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">Block</a></h1>
<h2 id="深入研究-block-捕获外部变量和-__block-实现原理"><a class="header" href="#深入研究-block-捕获外部变量和-__block-实现原理">深入研究 Block 捕获外部变量和 __block 实现原理</a></h2>
<p><a href="https://halfrost.com/ios_block/">深入研究 Block 捕获外部变量和 __block 实现原理</a></p>
<p>里面有提到作用域：</p>
<p><img src="programming-languages/Objective-C/media/16295345348106.jpg" alt="" /></p>
<ul>
<li><code>_NSConcreteStackBlock</code> ：只用到外部局部变量、成员属性变量，且没有强指针引用的 <code>block</code> 都是 <code>StackBlock</code> 。 <code>StackBlock</code> 的生命周期由系统控制的，一旦返回之后，就被系统销毁了。</li>
<li><code>_NSConcreteMallocBlock</code> ：有强指针引用或 <code>copy</code> 修饰的成员属性引用的 <code>block</code> 会被复制一份到堆中成为 <code>MallocBlock</code> ，没有强指针引用即销毁，生命周期由程序员控制</li>
<li><code>_NSConcreteGlobalBlock</code> ：没有用到外界变量或只用到全局变量、静态变量的 <code>block</code> 为 <code>_NSConcreteGlobalBlock</code> ，生命周期从创建到应用程序结束。</li>
</ul>
<p><code>__block</code> 结构体 <code>__forwarding</code> ：</p>
<p><img src="programming-languages/Objective-C/media/16295347079014.jpg" alt="" /></p>
<h2 id="block-技巧与底层解析"><a class="header" href="#block-技巧与底层解析">Block 技巧与底层解析</a></h2>
<p><a href="https://triplecc.github.io/2015/07/19/2015-08-27-blockji-qiao-yu-di-ceng-jie-xi/">Block技巧与底层解析</a></p>
<p>Block 的实际结构：</p>
<pre><code class="language-objectivec">/* Revised new layout. */
struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};

struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>
<p><code>_NSConcreteMallocBlock</code> 无法直接创建，只能 <code>_NSConcreteStackBlock</code> 拷贝得到，而 Block 的拷贝最终都会调用 <code>_Block_copy_internal</code> 函数，所以从 <code>_Block_copy_internal</code> 函数中可以得出 <code>_NSConcreteMallocBlock</code> 是如何创建的：</p>
<pre><code class="language-objectivec">static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
	...
    aBlock = (struct Block_layout *)arg;
	...
    // Its a stack block.  Make a copy.
    if (!isGC) {
    	// 申请block的堆内存
        struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
        if (!result) return (void *)0;
        // 拷贝栈中block到刚申请的堆内存中
        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
        // reset refcount
        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
        result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
        // 改变isa指向_NSConcreteMallocBlock，即堆block类型
        result-&gt;isa = _NSConcreteMallocBlock;
        if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
            //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
            (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
        }
        return result;
    }
    else {
        ...
    }
}
</code></pre>
<p>函数通过 <code>memmove</code> 将栈中的 Block 的内容拷贝到了堆中，并使 <code>isa</code> 指向了 <code>_NSConcreteMallocBlock</code> 。</p>
<p>Block 的拷贝代码在 <code>_Block_copy_internal</code> 函数中，根据 Block 的类型不同，拷贝过程中的操作也不同。</p>
<p>栈 Block 的拷贝不仅是拷贝了内容，而且由于从栈拷贝到堆中，还会进行一些额外的操作：</p>
<ol>
<li>往 <code>flags</code> 中并入 <code>BLOCK_NEEDS_FREE</code> ，并将引用计数设置为 1，表示 Block 需要释放，需要自行 <code>release</code> ；</li>
<li>如果有辅助 copy 函数 ( <code>BLOCK_HAS_COPY_DISPOSE</code> )，那么就会调用辅助  copy 函数来拷贝 Block 捕获的变量。</li>
</ol>
<pre><code class="language-objectivec">...
struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;
memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
// reset refcount
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
result-&gt;isa = _NSConcreteMallocBlock;
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
    (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
}
return result;
...
</code></pre>
<p>堆 Block 由于已经拷贝至堆中，所以其拷贝操作比较简单，首先需要判断是否有 <code>BLOCK_FREE</code> ，如果是，则表示是堆 Block ，那么只需要执行 <code>latching_incr_int</code> 操作，将 Block 的引用计数加 1 即可，只需要单纯地改变引用计数：</p>
<pre><code class="language-objectivec">...
if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
      // latches on high
      latching_incr_int(&amp;aBlock-&gt;flags);
      return aBlock;
}
...
</code></pre>
<p>全局 Block 不需要执行任何操作，只是直接返回了传入的 Block ：</p>
<pre><code class="language-objectivec">...
else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
      return aBlock;
}
...
</code></pre>
<pre><code class="language-objectivec">// flags/_flags类型
enum {
        /* See function implementation for a more complete description of these fields and combinations */
        // 是一个对象
        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */
        // 是一个block
        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */
        // 被__block修饰的变量
        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */
        // 被__weak修饰的变量，只能被辅助copy函数使用
        BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */
        // block辅助函数调用（告诉内部实现不要进行retain或者copy）
        BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */
    };

// 设置不同属性对应的flags/_flags值
__block id                   128+3
__weak block id              128+3+16
__block (^Block)             128+7
__weak __block (^Block)      128+7+16

struct Block_byref {
    void *isa;
    struct Block_byref *forwarding;
    int flags; /* refcount; */
    int size;
    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
    void (*byref_destroy)(struct Block_byref *);
    /* long shared[0]; */
};

// 做下对比
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};
</code></pre>
<p><code>__block</code> 将原来的基本类型包装成了对象。因为以上两个结构体的前 4 个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>
<pre><code class="language-objectivec">// 转换成C++代码
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

// _Block_object_assign源码
void _Block_object_assign(void *destAddr, const void *object, const int flags) {
...
    else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
...
}

// _Block_byref_assign_copy源码
static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    // 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
...
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) {
        // 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0
        // 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值
        // static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;
        // 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是包装对象的初始引用计数（栈上持有+堆上持有）
        ...
        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value;
        ...
    }
    // 已经拷贝到堆了，只增加引用计数
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);
    }
    // 普通的赋值，里面最底层就*destptr = value;这句表达式
    _Block_assign(src-&gt;forwarding, (void **)destp);
}
</code></pre>
<p>对象的辅助函数：</p>
<p>没有 <code>__block</code> 修饰：</p>
<pre><code class="language-objectivec">typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}
</code></pre>
<p>首先，在没有 <code>__block</code> 修饰时，对象编译转换的结果如下：</p>
<pre><code class="language-objectivec">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  NSObject *a = __cself-&gt;a; // bound by copy
            a;
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0),
</code></pre>
<p>对象在没有 <code>__block</code> 修饰时，并没有产生 <code>__Block_byref_a_0</code> 结构体，只是将标志位修改为 <code>BLOCK_FIELD_IS_OBJECT</code> 。而在 <code>_Block_object_assign</code> 中对应的判断分支代码如下：</p>
<pre><code class="language-objectivec"> v...
else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {
    _Block_retain_object(object);
    _Block_assign((void *)object, destAddr);
}
...
</code></pre>
<p>Block 在捕获对象时会进行 <code>retain</code> 操作，增加引用计数。</p>
<p>在有 <code>__block</code> 修饰时：</p>
<pre><code class="language-objectivec">typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}

// 转换后：
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 NSObject *a;
};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 33554432, sizeof(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131,....};
Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
}

// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）
static void __Block_byref_id_object_copy_131(void *dst, void *src) {
 _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);
}
static void __Block_byref_id_object_dispose_131(void *src) {
 _Block_object_dispose(*(void * *) ((char*)src + 40), 131);
}
</code></pre>
<p><code>__Block_byref_a_0</code> 新增两个内存管理的辅助函数 <code>__Block_byref_id_object_copy</code> 和 <code>__Block_byref_id_object_dispose</code> 。最后的 <code>131</code> 参数表示 <code>BLOCK_BYREF_CALLER|BLOCK_FIELD_IS_OBJECT</code> ， <code>BLOCK_BYREF_CALLER</code> 用于表明不需要对 <code>__block</code> 修饰的 <code>a</code> 对象进行 <code>retain</code> 或者 <code>copy</code> ：</p>
<pre><code class="language-objectivec">if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {
	...
    else {
        // do *not* retain or *copy* __block variables whatever they are
        _Block_assign((void *)object, destAddr);
    }
}
</code></pre>
<p><code>_Block_byref_assign_copy</code> 函数的以下代码会对上面的辅助函数 <code>__Block_byref_id_object_copy_131</code> 进行调用， <code>570425344</code> 表示 <code>BLOCK_HAS_COPY_DISPOSE|BLOCK_HAS_DESCRIPTOR</code> ，所以会执行以下相关源码：</p>
<pre><code class="language-objectivec">if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    // Trust copy helper to copy everything of interest
    // If more than one field shows up in a byref block this is wrong XXX
    copy-&gt;byref_keep = src-&gt;byref_keep;
    copy-&gt;byref_destroy = src-&gt;byref_destroy;
    (*src-&gt;byref_keep)(copy, src);
}
</code></pre>
<h2 id="一道-block-面试题的深入挖掘"><a class="header" href="#一道-block-面试题的深入挖掘">一道 Block 面试题的深入挖掘</a></h2>
<p><a href="https://juejin.im/post/5eaa2a87e51d454db7436726">一道Block面试题的深入挖掘</a></p>
<p>借由 <code>NSNotificationCenter</code> 和 <code>token</code> 说明实际编码中 Block 需要注意的地方以及原理。</p>
<h2 id="block-语法快速查询"><a class="header" href="#block-语法快速查询">Block 语法快速查询</a></h2>
<p>由于 Objective-C 的 Block 语法实在是太难记了，反观 Swift 😂 ，所以有了这么一个快速查看 Block 语法的网站：</p>
<p><a href="http://fuckingblocksyntax.com/">How Do I Declare A Block in Objective-C?</a></p>
<h2 id="obj-c-中的-block"><a class="header" href="#obj-c-中的-block">Obj-C 中的 Block</a></h2>
<p><a href="https://kingcos.me/posts/2019/block_in_obj-c/">Obj-C 中的 Block</a></p>
<p>Objective-C 中的 Block 相当于匿名函数。</p>
<p>通过 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 转换为 C++ 代码可以查看 Block 的结构体。</p>
<p><code>__main_3_block_impl_0</code> 为具体 Block 对应的 <code>struct</code> ，包含 <code>__block_impl</code> 和 <code>__main_3_block_desc_0</code> 。</p>
<pre><code class="language-objectivec">// Block 实现的结构体
struct __block_impl {
  void *isa;     // isa 指针，即 Block 也是 id 类型，即 Obj-C 对象
  int Flags;     // 标记，默认会被初始化为 0
  int Reserved;  // 保留域（ABI 兼容），默认 0
  void *FuncPtr; // Block 代码块的函数指针
};

// ➡️ Block 结构体
struct __main_3_block_impl_0 {
  struct __block_impl impl;           // 实现（非指针）
  struct __main_3_block_desc_0* Desc; // 描述信息（指针）
  // 构造函数
  __main_3_block_impl_0(void *fp, struct __main_3_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock; // Block 作为 Obj-C 对象，那么 isa 将指向其类对象，即 _NSConcreteStackBlock
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// Block 内代码块封装在该 C 语言静态函数中，函数命名规则：__CALLER_METHOD_NAME_block_func_NUMBER
// 类似 Obj-C 实例方法参数 self 或 C++ 实例方法参数 this，__cself 为指向 Block 结构体的变量
static void __main_3_block_func_0(struct __main_3_block_impl_0 *__cself) {
  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_b9596e_mi_0);
}

// Block 描述信息的结构体静态变量
static struct __main_3_block_desc_0 {
  size_t reserved;   // 保留域，默认 0
  size_t Block_size; // Block 大小，sizeof 整个 Block 结构体 ⬇️
} __main_3_block_desc_0_DATA = { 0, sizeof(struct __main_3_block_impl_0)};

// 主函数
int main_3(int argc, const char * argv[]) {
    // 通过 __main_3_block_impl_0 结构体的构造函数初始化，参数为静态函数和描述信息静态变量的地址，将地址存储在 block 变量中
    // 忽略类型转换：block = &amp;__main_3_block_impl_0(__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));
    void(*block)(void) = ((void (*)())&amp;__main_3_block_impl_0((void *)__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));

    // 执行 Block（参数 block 即静态函数中的参数 __cself）
    // 忽略类型转换：block-&gt;FuncPtr(block);
    // 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);

    return 0;
}
</code></pre>
<p><img src="programming-languages/Objective-C/media/16295350902641.jpg" alt="" /></p>
<p>Block 对于捕获变量的不同也会有不同的处理</p>
<ol>
<li>局部变量，进行值拷贝传递，修改原有的值不影响 Block 所捕获的值；</li>
<li>显式或者隐式捕获 <code>self</code> ，Block 会持有 <code>self</code> 的引用，有可能触发我们常说的循环引用；</li>
<li>静态局部变量， 虽然作用域在代码块内，但是其生命周期是全局的，所以 Block 直接持有对变量的引用；</li>
<li>全局变量，Block 不会捕获，使用时直接进行读取。</li>
</ol>
<p>Block 的类型：</p>
<p><code>__NSGlobalBlock__</code> ，不捕获自动变量，即运行时不依赖上下文，放在内存的数据段 (Data Section) ，和全局变量同一个 Section 。对 <code>__NSGlobalBlock__</code> 执行拷贝后得到的仍是 <code>__NSGlobalBlock__</code> 。</p>
<p><code>__NSStackBlock__</code> ，当 Block 捕获了外界自动变量时，则会被分配在栈区，变成 <code>__NSStackBlock__</code> ，开发者无需关心其生命周期。</p>
<p><code>__NSMallocBlock__</code> ，Block 分配在堆区，需要开发者手动管理其生命周期，ARC 下编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 copy 到堆上，将 Block 的 <code>isa</code> 设置为 <code>_NSConcreteMallocBlock</code> ，以下操作会将 Block copy 到堆上：</p>
<ol>
<li>强指针或者属性指向的 Block ；</li>
<li>Block 作为函数值会自动拷贝；</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code>  的参数时会自动拷贝；</li>
<li>Block 作为 GCD API 参数时会被自动拷贝；</li>
</ol>
<p><code>__block</code> 声明的变量：</p>
<p>Block 内可以直接修改</p>
<p><code>__block</code> 声明会将变量封装为对应的结构体，而不同的变量就会生成不同的结构体。 <code>__block</code> 变量从声明后，无论在 Block 内外去访问均是通过结构体的 <code>__forwarding</code> 指针即 <code>blockVar.__forwarding-&gt;blockVar</code> 。当 <code>__block</code> 变量在栈上时， <code>blockVar.__forwarding-&gt;blockVar</code> 就等同于直接通过 <code>blockVar-&gt;blockVar</code> 来访问的，因为此时 <code>__forwarding</code> 就指向栈上的结构体本身；而当 Block 拷贝到堆上时， <code>__block</code> 变量也会被拷贝到堆上，此时栈上的 <code>__forwarding</code> 将替换为指向堆上的结构体，而堆上的结构体里的 <code>__forwarding</code> 将指向堆上的结构体本身，从而保证后续的数据变动均是在堆上。</p>
<p>上面说到 Block 会生成不同的结构体，也就说使用 Block 实现的功能代码量会较多。</p>
<p><img src="programming-languages/Objective-C/media/16295351225941.jpg" alt="" /></p>
<p>循环引用：</p>
<pre><code class="language-objectivec">typedef void(^BlockType_5)(void);

@interface Foo_9 : NSObject
@property (nonatomic, assign) NSUInteger bar;
@property (nonatomic, copy) BlockType_5 block;
@end

@implementation Foo_9
- (void)dealloc
{
#if !__has_feature(objc_arc)
    [super dealloc];
#endifNSLog(@&quot;dealloc&quot;);
}

- (void)foo_1 {
    // Block 捕获了 self，其强引用了 Block，导致双方都无法释放
    self.block = ^{
        // WARNING: Capturing 'self' strongly in this block is likely to lead to a retain cycle
        NSLog(@&quot;%lu&quot;, (unsigned long)self.bar);
        // WARNING: Block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior
        NSLog(@&quot;%lu&quot;, (unsigned long)_bar); // self-&gt;_bar
    };
}
@end

int main_22(int argc, const char * argv[]) {
#if __has_feature(objc_arc)
    Foo_9 *f = [[Foo_9 alloc] init];
    f.bar = 20;

    f.block = ^{
        // Block 捕获了 f，其强引用了 Block，导致双方都无法释放
        // WARNING: Capturing 'f' strongly in this block is likely to lead to a retain cycle
        NSLog(@&quot;%lu&quot;, (unsigned long)f.bar);
    };

    f.block();
    [f foo_1];

    // Never call dealloc
#endifreturn 0;
}

// OUTPUT:
// 20
</code></pre>
<p><img src="programming-languages/Objective-C/media/16295351549792.jpg" alt="" /></p>
<h2 id="用-block-实现-delegate-方法"><a class="header" href="#用-block-实现-delegate-方法">用 Block 实现 delegate 方法</a></h2>
<p><a href="https://triplecc.github.io/2017/07/28/2017-07-28-blockhe-nsmethodsignature/">用 Block 实现委托方法</a></p>
<p>使用 <code>NSInvocation</code> ，消息转化机制和 Block 结构体获取 <code>NSMethodSignature</code> 。</p>
<p><code>NSInvocation</code> 需要注意的地方：</p>
<p>方法的自定义参数从 index 2 开始，前两个参数是接收消息的对象和方法的 SEL ；</p>
<p><code>-getArgument:atIndex:</code> 和 <code>-getReturnvalue:</code> 方法中获取的对象不会进行 <code>retain</code> ，所以不能直接使用具体的对象指针，只能使用 <code>vod *</code> ：</p>
<pre><code class="language-objectivec">// 错误代码
NSString *bar = nil;
[invocation getArgument:&amp;bar atIndex:2];

NSString *result = nil;
[invocation getReturnValue:&amp;result];

// 正确代码
void *bar = nil;
//__unsafe_unretained NSString *bar = nil;
//__weak NSString *bar = nil;
[invocation getArgument:&amp;bar atIndex:2];

void *result = nil;
//__unsafe_unretained NSString *result = nil;
//__weak NSString *result = nil;
[invocation getReturnValue:&amp;result];
</code></pre>
<p>如果是在两个 <code>NSInvocation</code> 对象间传递参数/返回值，可以直接传入指针获取和设置目标地址：</p>
<pre><code class="language-objectivec">....
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
NSInvocation *shadowInvocation = [NSInvocation invocationWithMethodSignature:signature];
....
void *resultBuffer = malloc(invocation.methodSignature.methodReturnLength);
memset(resultBuffer, 0, invocation.methodSignature.methodReturnLength);

[invocation getReturnValue:resultBuffer];
[shadowInvocation setReturnValue:resultBuffer];
....
free(resultBuffer);
</code></pre>
<p>从协议中获取方法签名，利用 <code>protocol_getMethodDescription</code> 函数，可以获取到描述类型的 C 字符串，再通过这个字符串构造方法签名。针对协议中的接口有 <code>required</code> 和 <code>optional</code> 两种，并且不允许重复这一特点，可以创建构造方法签名的函数：</p>
<pre><code class="language-objectivec">static NSMethodSignature *tbv_getProtocolMethodSignature(Protocol *protocol, SEL selector, BOOL isInstanceMethod) {
    struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, YES, isInstanceMethod);
    if (!methodDescription.name) {
        methodDescription = protocol_getMethodDescription(protocol, selector, NO, isInstanceMethod);
    }
    return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
}
</code></pre>
<p>第三个参数表示是否为 <code>required</code> ，如果从 <code>required</code> 中获取不到对应的 <code>objc_method_description</code> ，再从 <code>optional</code> 中获取：</p>
<p><a href="https://developer.apple.com/documentation/objectivec/1418830-protocol_getmethoddescription">Apple Developer Documentation</a></p>
<p>从 Block 中获取方法签名，虽然苹果没有提供公开的 API 给开发者获取，但是可以通过自定义一个与 Block 结构相同的 <code>struct</code> ，通过这个 <code>struct</code> 来获取方法签名：</p>
<pre><code class="language-objectivec">// Block internals.
typedef NS_OPTIONS(int, TBVBlockFlags) {
    TBVBlockFlagsHasCopyDisposeHelpers = (1 &lt;&lt; 25),
    TBVBlockFlagsHasSignature          = (1 &lt;&lt; 30)
};
typedef struct tbv_block {
    __unused Class isa;
    TBVBlockFlags flags;
    __unused int reserved;
    void (__unused *invoke)(struct tbv_block *block, ...);
    struct {
        unsigned long int reserved;
        unsigned long int size;
        // requires TBVBlockFlagsHasCopyDisposeHelpers
        void (*copy)(void *dst, const void *src);
        void (*dispose)(const void *);
        // requires TBVBlockFlagsHasSignature
        const char *signature;
        const char *layout;
    } *descriptor;
    // imported variables
} *TBVBlockRef;

// 使用自定义的 TBVBlockRef 获取 descriptor
static NSMethodSignature *tbv_signatureForBlock(id block) {
    TBVBlockRef layout = (__bridge TBVBlockRef)(block);
    
    // 没有签名，直接返回空
    if (!(layout-&gt;flags &amp; TBVBlockFlagsHasSignature)) {
        return nil;
    }
    
    // 获取 descriptor 指针
    void *desc = layout-&gt;descriptor;
    
    // 跳过 reserved 和 size 成员
    desc += 2 * sizeof(unsigned long int);
    
    // 如果有 Helpers 函数， 跳过 copy 和 dispose 成员
    if (layout-&gt;flags &amp; TBVBlockFlagsHasCopyDisposeHelpers) {
        desc += 2 * sizeof(void *);
    }
    
    // desc 为 signature 指针的地址，转换下给 objcTypes
    char *objcTypes = (*(char **)desc);
    
    return [NSMethodSignature signatureWithObjCTypes:objcTypes];
}
</code></pre>
<p>为了确保 Block 和方法两者的参数是相同的，需要对两者的签名进行匹配，即检验返回值类型和参数类型是否相同：</p>
<pre><code class="language-objectivec">static BOOL tbv_isCompatibleBlockSignature(NSMethodSignature *blockSignature, NSMethodSignature *methodSignature) {
    NSCParameterAssert(blockSignature);
    NSCParameterAssert(methodSignature);
    
    if ([blockSignature isEqual:methodSignature]) {
        return YES;
    }
    
    // block 参数个数需要小于 method 的参数个数 (针对 block 调用替换 method 调用)
    // 两者返回类型需要一致
    if (blockSignature.numberOfArguments &gt;= methodSignature.numberOfArguments ||
        blockSignature.methodReturnType[0] != methodSignature.methodReturnType[0]) {
        return NO;
    }
    
    // 参数类型需要一致
    BOOL compatibleSignature = YES;
    
    // 自定义参数从第二个开始
    for (int idx = 2; idx &lt; blockSignature.numberOfArguments; idx++) {

        // block 相比 method ，默认参数少了 SEL
        // method: id(@) SEL(:) ....
        // block: block(@?) ....
        const char *methodArgument = [methodSignature getArgumentTypeAtIndex:idx];
        const char *blockArgument = [blockSignature getArgumentTypeAtIndex:idx - 1];
        if (!methodArgument || !blockArgument || methodArgument[0] != blockArgument[0]) {
            compatibleSignature = NO;
            break;
        }
    }
    
    return compatibleSignature;
}
</code></pre>
<p>调用 Block 的 <code>NSInvocation</code> ，由于直接调用的是 <code>delegate</code> 方法，在转发时接收到的是方法对应的 <code>NSInvocation</code> ，所以需要将其的参数和返回值传递给 Block 的 <code>NSInvocation</code> ：</p>
<pre><code class="language-objectivec">- (void)invokeWithMethodInvocation:(NSInvocation *)methodInvocation {
    NSParameterAssert(methodInvocation);
    NSAssert([self.methodSignature isEqual:methodInvocation.methodSignature], @&quot;Method invocation's signature is not compatible with block signature&quot;);
    
    NSMethodSignature *methodSignature = methodInvocation.methodSignature;
    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];
    
    void *argumentBuffer = NULL;
    for (int idx = 2; idx &lt; methodSignature.numberOfArguments; idx++) {
        
        // 获取参数类型
        const char *type = [methodSignature getArgumentTypeAtIndex:idx];
        NSUInteger size = 0;
        
        // 获取参数大小
        NSGetSizeAndAlignment(type, &amp;size, NULL);
        
        // 参数缓存
        if (!(argumentBuffer = reallocf(argumentBuffer, size))) {
            return;
        }
        
        // 把 method 的参数传递给 block
        [methodInvocation getArgument:argumentBuffer atIndex:idx];
        [blockInvocation setArgument:argumentBuffer atIndex:idx - 1];
    }
    
    // 调用 block
    [blockInvocation invokeWithTarget:self.block];
    
    // 返回值缓存
    if (methodSignature.methodReturnLength &amp;&amp;
        (argumentBuffer = reallocf(argumentBuffer, methodSignature.methodReturnLength))) {
        
        // 把 block 的返回值传递给 method
        [blockInvocation getReturnValue:argumentBuffer];
        [methodInvocation setReturnValue:argumentBuffer];
    }
    
    // 释放缓存
    free(argumentBuffer);
}

// reallocf 函数是 realloc 函数的增强版，它可以在后者无法申请到堆空间时，释放旧的堆空间：
void *reallocf(void *p, size_t s) {
    void *tmp = realloc(p, s);
    if(tmp) return tmp;
    free(p);
    return NULL;
}
</code></pre>
<p>最后是通过消息转发的 <code>forwardInvocaion:</code> 方法进行转发：</p>
<pre><code class="language-objectivec">- (void)forwardInvocation:(NSInvocation *)invocation {
    TBVBlockInvocation *blockInvocation = self.selectorInvocationMap[NSStringFromSelector(invocation.selector)];
    [blockInvocation invokeWithMethodInvocation:invocation];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    return self.selectorInvocationMap[NSStringFromSelector(sel)].methodSignature;
}

- (BOOL)respondsToSelector:(SEL)aSelector {
    return !!self.selectorInvocationMap[NSStringFromSelector(aSelector)];
}
</code></pre>
<h2 id="如何获取-block-捕获的对象"><a class="header" href="#如何获取-block-捕获的对象">如何获取 Block 捕获的对象</a></h2>
<p><a href="https://triplecc.github.io/2019/08/15/%E8%81%8A%E8%81%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%A3%80%E6%B5%8B/">聊聊循环引用的检测</a></p>
<p>由于 Objective-C 使用引用计数作为内存管理方法，且 Block 会强引用所捕获的对象，所以 Block 经常会造成引用循环。本文讲述了如何通过 Block 的布局，捕获变量排序来获取 Block 强引用的对象。</p>
<p>Block 捕获的对象会统一放在 layout 的 <code>descriptor</code> 后面，即 <code>sr_block_layout</code> 结构体的 <code>imported variables</code> 部分，这种操作可以看作在 <code>sr_block_layout</code> 尾部定义了一个 0 长数组，可以根据实际捕获变量的大小，给捕获区域申请对应的内存空间，只不过这一操作由编译器完成 :</p>
<pre><code class="language-objectivec">struct sr_block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct sr_block_descriptor *descriptor;
    char captured[0];
};

// 标志位不一样，这个结构的实际布局也会有差别，这里简单地放在一起好阅读
struct sr_block_descriptor {
    unsigned long reserved; // Block_descriptor_1
    unsigned long size; // Block_descriptor_1
    void (*)(void *dst, void *src);  // Block_descriptor_2 BLOCK_HAS_COPY_DISPOSE
    void (*dispose)(void *); // Block_descriptor_2
    const char *signature; // Block_descriptor_3 BLOCK_HAS_SIGNATURE
    const char *layout; // Block_descriptor_3 contents depend on BLOCK_HAS_EXTENDED_LAYOUT
};
</code></pre>
<p>Block 的捕获区域布局有特定的排序规则：</p>
<p><a href="https://github.com/llvm-mirror/clang/blob/e870496ea61feb01aa0eb4dc599be0ddf2d03878/lib/CodeGen/CGBlocks.cpp#L366-L384">llvm-mirror/clang</a></p>
<p>在对齐字节数 ( <code>alignment</code> ) 不相等时，捕获的实体按照 <code>alignment</code> 降序排序 ( C 结构体比较特殊，即使整体占用空间比指针变量大，也排在对象指针后面)，否则按照以下类型排序：</p>
<ol>
<li><code>__strong</code> 修饰对象指针变量</li>
<li><code>__block</code> 修饰对象指针变量</li>
<li><code>__weak</code> 修饰对象指针变量</li>
<li>其他变量</li>
</ol>
<p>一个例子：</p>
<pre><code class="language-objectivec">NSObject *o1 = [NSObject new];
__weak NSObject *o2 = o1;
__block NSObject *o3 = o1;
unsigned long long j = 4;
int i = 3;
char c = 'a';
void (^blk)(void) = ^{
    i;
    c;
    o1;
    o2;
    o3;
    j;
};
</code></pre>
<p>输出：</p>
<pre><code class="language-objectivec">(lldb) x/69bx layout
0x10200d940: 0x70 0x21 0x7b 0xa6 0xff 0x7f 0x00 0x00
0x10200d948: 0x02 0x00 0x00 0xc3 0x00 0x00 0x00 0x00
0x10200d950: 0xf0 0x1b 0x00 0x00 0x01 0x00 0x00 0x00
0x10200d958: 0xf8 0x20 0x00 0x00 0x01 0x00 0x00 0x00
0x10200d960: 0xa0 0xf6 0x00 0x02 0x01 0x00 0x00 0x00  // o1
0x10200d968: 0x90 0xd9 0x00 0x02 0x01 0x00 0x00 0x00  // o3
0x10200d970: 0xa0 0xf6 0x00 0x02 0x01 0x00 0x00 0x00  // o2
0x10200d978: 0x04 0x00 0x00 0x00 0x00 0x00 0x00 0x00  // j
0x10200d980: 0x03 0x00 0x00 0x00 0x61                 // i c
(lldb) p o1
(NSObject *) $1 = 0x000000010200f6a0
</code></pre>
<p>可以看到，小端模式下，捕获的 o1 和 o2 指针变量值为 <code>0x10200f6a0</code> ，对应内存地址为 <code>0x10200d960</code> 和 <code>0x10200d970</code> ，而 o3 因为被 <code>__block</code> 修饰，编译器为 o3 捕获变量包装了一层 <code>byref</code> 结构，所以其值为 <code>byref</code> 结构的地址 0x102000d990 ，而不是 0x10200f6a0 ，捕获的 j 变量地址为 0x10200d978，i 变量地址为 0x10200d980，c 字符变量紧随其后。</p>
<p>通过分析 <code>descriptor</code> 的 <code>layout</code> 信息则可以获取捕获到的对象个数。</p>
<p><a href="https://github.com/tripleCC/Laboratory/blob/d5d98d343a918d3883a2d5274da212cd44f50414/AppleSources/libclosure-73/Block_private.h#L283-L314">tripleCC/Laboratory</a></p>
<p><a href="https://github.com/llvm-mirror/clang/blob/e5d2fdc902b0fb4e0a8f5a7d549728e1f2a648ad/lib/CodeGen/CGObjCMac.cpp#L2614-L2865">llvm-mirror/clang</a></p>
<pre><code class="language-objectivec">// block
// Extended layout encoding.

// Values for Block_descriptor_3-&gt;layout with BLOCK_HAS_EXTENDED_LAYOUT
// and for Block_byref_3-&gt;layout with BLOCK_BYREF_LAYOUT_EXTENDED

// If the layout field is less than 0x1000, then it is a compact encoding 
// of the form 0xXYZ: X strong pointers, then Y byref pointers, 
// then Z weak pointers.

// If the layout field is 0x1000 or greater, it points to a 
// string of layout bytes. Each byte is of the form 0xPN.
// Operator P is from the list below. Value N is a parameter for the operator.

enum {
    ...
    BLOCK_LAYOUT_NON_OBJECT_BYTES = 1,    // N bytes non-objects
    BLOCK_LAYOUT_NON_OBJECT_WORDS = 2,    // N words non-objects
    BLOCK_LAYOUT_STRONG           = 3,    // N words strong pointers
    BLOCK_LAYOUT_BYREF            = 4,    // N words byref pointers
    BLOCK_LAYOUT_WEAK             = 5,    // N words weak pointers
    ...
};

// clang 
/// InlineLayoutInstruction - This routine produce an inline instruction for the
/// block variable layout if it can. If not, it returns 0. Rules are as follow:
/// If ((uintptr_t) layout) &lt; (1 &lt;&lt; 12), the layout is inline. In the 64bit world,
/// an inline layout of value 0x0000000000000xyz is interpreted as follows:
/// x captured object pointers of BLOCK_LAYOUT_STRONG. Followed by
/// y captured object of BLOCK_LAYOUT_BYREF. Followed by
/// z captured object of BLOCK_LAYOUT_WEAK. If any of the above is missing, zero
/// replaces it. For example, 0x00000x00 means x BLOCK_LAYOUT_STRONG and no
/// BLOCK_LAYOUT_BYREF and no BLOCK_LAYOUT_WEAK objects are captured.`
</code></pre>
<p><code>descriptor-&gt;layout</code> 会包含捕获的对象个数，且会根据 <code>__strong</code> ， <code>__block</code> 和 <code>__weak</code> 进行区分。</p>
<pre><code class="language-objectivec">NSObject *o1 = [NSObject new];
__block NSObject *o3 = o1;
__weak NSObject *o2 = o1;
NSObject *o4 = o1;
... // 5 - 18
NSObject *o19 = o1;
void (^blk)(void) = ^{
    o1;
    o2;
    o3;
    o4;
    ... // 5 - 18
    o19;
};
</code></pre>
<pre><code class="language-objectivec">(lldb) p/x (long)layout-&gt;descriptor-&gt;layout
(long) $0 = 0x0000000100002f44
(lldb) x/8bx layout-&gt;descriptor-&gt;layout
0x100002f44: 0x3f 0x30 0x40 0x50 0x00 0x76 0x31 0x36
</code></pre>
<p>由于结构体的布局顺序在生命时就确定了，无法像 Block 那样在编译时再根据变量类型，修饰符进行调整，所以如果结构体中有类型为对象指针的字段，就需要额外的信息来进行记录，这也会影响 <code>layout</code> 。</p>
<p>使用 <code>__block</code> 修饰的捕获变量首先会转换成 <code>byref</code> 结构，然后再由这个结构去持有实际的变量， Block 只负责管理 <code>byref</code> ：</p>
<pre><code class="language-objectivec">struct sr_block_byref {
    void *isa;
    struct sr_block_byref *forwarding;
    volatile int32_t flags; // contains ref count
    uint32_t size;
    // requires BLOCK_BYREF_HAS_COPY_DISPOSE
    void (*byref_keep)(struct sr_block_byref *dst, struct sr_block_byref *src);
    void (*byref_destroy)(struct sr_block_byref *);
    // requires BLOCK_BYREF_LAYOUT_EXTENDED
    const char *layout;
};
</code></pre>
<p>这里使用 <code>layout</code> 的原因是需要根据不同的捕获变量记录不同的信息，具体的实现可以查看原文。</p>
<p>了解完 Block 的捕获区域的内存布局后，就可以通过内存布局来获取强引用对象了：</p>
<ol>
<li>被 Block 强引用</li>
<li>被 byref 结构强引用</li>
</ol>
<p>完整的代码在这里：</p>
<p><a href="https://github.com/tripleCC/Laboratory/blob/9982b333c6b8d1cd7cb9ed17430906afebf1f8bb/BlockStrongReferenceObject/BlockStrongReferenceObject/SRBlockStrongReferenceCollector.m">tripleCC/Laboratory</a></p>
<h2 id="另一种获取-block-强引用对象的方式"><a class="header" href="#另一种获取-block-强引用对象的方式">另一种获取 Block 强引用对象的方式</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/FBRetainCycleDetector/iOS%20%E4%B8%AD%E7%9A%84%20block%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84.md">draveness/analyze</a></p>
<p><a href="https://github.com/facebook/FBRetainCycleDetector/blob/ecd369ed1e03eb22178199091fecdba6c9964189/FBRetainCycleDetector/Layout/Blocks/FBBlockStrongLayout.m#L29-L102">facebook/FBRetainCycleDetector</a></p>
<p>FBRetainCycleDetector 也提供了获取 Block 强引用对象的功能，与上面的分析 Block 捕获区域的内存布局方式不同，使用了一种比较取巧的方式。</p>
<p>获取 <code>dispose_helper</code> ， <code>dispose_helper</code> 作为 Block 的辅助函数，在 Block 析构时会调用，然后给强引用对象发送 <code>release</code> 消息，借用这个特性进行处理。</p>
<pre><code class="language-objectivec">struct BlockDescriptor {
	unsigned long int reserved;                // NULL
	unsigned long int size;
	// optional helper functions
	void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25)
	void (*dispose_helper)(void *src);         // IFF (1&lt;&lt;25)
	const char *signature;                     // IFF (1&lt;&lt;30)
};
</code></pre>
<p>另外一个辅助类就是 <code>FBBlockStrongRelationDetector</code> ， <code>FBBlockStrongRelationDetector</code> 重写了 <code>release</code> 方法和新增了一个 <code>trueRelease</code> 方法：</p>
<pre><code class="language-objectivec">- (oneway void)release
{
  _strong = YES;
}

- (oneway void)trueRelease
{
  [super release];
}
</code></pre>
<p><code>FBBlockStrongRelationDetector</code> 同时也可以被当作 Block 来处理，当 Block  中又引用了 Block 时，它会尝试调用 <code>byref_dispose</code> ，所以 <code>FBBlockStrongRelationDetector</code> 也定义了和 Block 相同的变量布局：</p>
<pre><code class="language-objectivec">struct _block_byref_block;
@interface FBBlockStrongRelationDetector : NSObject
{
  // __block fakery
  void *forwarding;
  int flags;   //refcount;
  int size;
  void (*byref_keep)(struct _block_byref_block *dst, struct _block_byref_block *src);
  void (*byref_dispose)(struct _block_byref_block *);
  void *captured[16];
}
</code></pre>
<p>在获取强引用对象索引的实现中，会在自动释放迟中执行 <code>dispose_helper(obj)</code> 方法，给每个 强引用对象对应的 <code>FBBlockStrongRelationDetector</code> 发送 <code>release</code> 消息，这样就可以拿到它们的索引值，从而获取对应的对象。</p>
<pre><code class="language-objectivec">static NSIndexSet *_GetBlockStrongLayout(void *block) {
	...
	void (*dispose_helper)(void *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;
	const size_t ptrSize = sizeof(void *);	
	const size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize;
	
	void *obj[elements];
	void *detectors[elements];
	
	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];
		obj[i] = detectors[i] = detector;
	}
	
	@autoreleasepool {
		dispose_helper(obj);
	}
	NSMutableIndexSet *layout = [NSMutableIndexSet indexSet];
	
	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);
		if (detector.isStrong) {
			[layout addIndex:i];
		}
		
		[detector trueRelease];
	}
	
	return layout;
}
</code></pre>
<h2 id="llvm-关于-block-的文档"><a class="header" href="#llvm-关于-block-的文档">LLVM 关于 Block 的文档</a></h2>
<p><a href="https://clang.llvm.org/docs/Block-ABI-Apple.html">Clang 12 documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="category"><a class="header" href="#category">Category</a></h1>
<h2 id="官方文档-1"><a class="header" href="#官方文档-1">官方文档</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html">Category</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24925196">Objective-C Category</a></p>
<p>Category 的作用：</p>
<ol>
<li>为已存在的类添加方法；</li>
<li>将类的实现分开在不同的代码文件里，减少单个代码文件的行数，将不同的功能组织到不同的 Category ，可以由多个开发者共同开发同一个类，按需加载对应的 Category ；</li>
<li>声明私有方法，借此将私有方法公开，方便调用；</li>
<li>模拟多继承；</li>
<li>Method Swizzling ；</li>
<li>结合 Associated Objects 和 Category 给已有的类新增 Property ；</li>
<li>覆盖主类的实现（也可以说是副作用）。</li>
</ol>
<h2 id="深入理解-category"><a class="header" href="#深入理解-category">深入理解 Category</a></h2>
<p><a href="https://tech.meituan.com/2015/03/03/diveintocategory.html">深入理解Objective-C：Category</a></p>
<p>深入解析 Category ：</p>
<ol>
<li>Category 和 Extension 的不同；</li>
<li>源码解析，Category 生成的 <code>sturct</code> ；</li>
<li>Category 的属性，方法等是如何在通过 runtime 追加到主类中；</li>
<li>Category 的加载顺序；</li>
<li>Category 与 Associated Objects 。</li>
</ol>
<p>如何调用被覆盖掉的主类方法：</p>
<pre><code class="language-objectivec">Class currentClass = [MyClass class];
MyClass *my = [[MyClass alloc] init];

if (currentClass) {
    unsigned int methodCount;
    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);
    IMP lastImp = NULL;
    SEL lastSel = NULL;
    for (NSInteger i = 0; i &lt; methodCount; i++) {
        Method method = methodList[i];
        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) 
        								encoding:NSUTF8StringEncoding];
        if ([@&quot;printName&quot; isEqualToString:methodName]) {
            lastImp = method_getImplementation(method);
            lastSel = method_getName(method);
        }
    }
    typedef void (*fn)(id,SEL);
    
    if (lastImp != NULL) {
        fn f = (fn)lastImp;
        f(my,lastSel);
    }
    free(methodList);
}
</code></pre>
<p>这里是顺序遍历，可以使用逆序遍历，找到第一个 IMP 就返回，会快那么一点点。</p>
<h2 id="ios-中的-category"><a class="header" href="#ios-中的-category">iOS 中的 Category</a></h2>
<p><a href="https://kingcos.me/posts/2019/category_in_ios/">iOS 中的 Category</a></p>
<p>这篇文章非常详细，从 <code>realloc</code> 到 <code>memmove</code> 和 <code>memcpy</code> 都有讲：</p>
<p><img src="programming-languages/Objective-C/media/16295354687549.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-sending--forwarding"><a class="header" href="#message-sending--forwarding">Message Sending &amp; Forwarding</a></h1>
<h2 id="消息发送与转发"><a class="header" href="#消息发送与转发">消息发送与转发</a></h2>
<p><a href="https://halfrost.com/objc_runtime_objc_msgsend/">神经病院 Objective-C Runtime 住院第二天--消息发送与转发</a></p>
<p>作者画了一张非常清晰的流程图，可以先看图再看文章。</p>
<p><img src="programming-languages/Objective-C/media/16295369175812.jpg" alt="" /></p>
<h2 id="消息发送与转发机制原理"><a class="header" href="#消息发送与转发机制原理">消息发送与转发机制原理</a></h2>
<p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></p>
<p>这里有说到为什么 <code>objc_msgSend</code> 要使用汇编进行处理：</p>
<p>其实在 <a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Messengers.subproj/objc-msg-x86_64.s">objc-msg-x86_64.s</a> 中包含了多个版本的 <code>objc_msgSend</code> 方法，它们是根据返回值的类型和调用者的类型分别处理的：</p>
<ul>
<li><code>objc_msgSendSuper</code>:向父类发消息，返回值类型为 <code>id</code></li>
<li><code>objc_msgSend_fpret</code>:返回值类型为 floating-point，其中包含 <code>objc_msgSend_fp2ret</code> 入口处理返回值类型为 <code>long double</code> 的情况</li>
<li><code>objc_msgSend_stret</code>:返回值为结构体</li>
<li><code>objc_msgSendSuper_stret</code>:向父类发消息，返回值类型为结构体</li>
</ul>
<p>当需要发送消息时，编译器会生成中间代码，根据情况分别调用 <code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code> 其中之一。</p>
<p>这也是为什么 <code>objc_msgSend</code> 要用汇编语言而不是 OC、C 或 C++ 语言来实现，因为单独一个方法定义满足不了多种类型返回值，有的方法返回 <code>id</code>，有的返回 <code>int</code>。考虑到不同类型参数返回值排列组合映射不同方法签名（method signature）的问题，那 switch 语句得老长了。。。**这些原因可以总结为 <a href="https://en.wikipedia.org/wiki/Calling_convention">Calling Convention</a>，也就是说函数调用者与被调用者必须约定好参数与返回值在不同架构处理器上的存取规则，比如参数是以何种顺序存储在栈上，或是存储在哪些寄存器上。**除此之外还有其他原因，比如其可变参数用汇编处理起来最方便，因为找到 IMP 地址后参数都在栈上。要是用 C++ 传递可变参数那就悲剧了，prologue 机制会弄乱地址（比如 i386 上为了存储 <code>ebp</code> 向后移位 4byte ），最后还要用 epilogue 打扫战场。而且汇编程序执行效率高，在 Objective-C Runtime 中调用频率较高的函数好多都用汇编写的。</p>
<p>还有一张巨详细的图：</p>
<p><img src="programming-languages/Objective-C/media/16295369836049.jpg" alt="" /></p>
<h2 id="消息发送"><a class="header" href="#消息发送">消息发送</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md">draveness/analyze</a></p>
<p>通过断点方式来查看消息发送的调用顺序：</p>
<ol>
<li>缓存命中；</li>
<li>查找当前类的缓存及方法；</li>
<li>查找父类的缓存及方法；</li>
<li>方法决议；</li>
<li>消息转发。</li>
</ol>
<p><code>objc_msgSend</code> 的调用栈：</p>
<pre><code class="language-objectivec">0 lookUpImpOrForward
1 _class_lookupMethodAndLoadCache3
2 objc_msgSend
3 main
4 start
</code></pre>
<h2 id="lets-build-objc_msgsend"><a class="header" href="#lets-build-objc_msgsend">Let's Build <code>objc_msgSend</code></a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html">mikeash.com: Friday Q&amp;A 2012-11-16: Let's Build objc_msgSend</a></p>
<p>Mike Ash 尝试自己实现了 <code>objc_msgSend</code> ，前面部分为了拦截系统 <code>objc_msgSend</code> ，使用的是汇编来实现，当在缓存找不到 IMP 时，改用可维护的 C 来实现，由于找不到缓存的概率较小，和找不到缓存后对速度要求没那么高，所以改用 C 来实现。</p>
<p>伪代码实现：</p>
<pre><code class="language-objectivec">IMP class_getMethodImplementation(Class cls, SEL sel)
{
    IMP imp;
    if (!cls  ||  !sel) return nil;
    imp = lookUpImpOrNil(cls, sel, nil, YES/*initialize*/, YES/*cache*/, YES/*resolver*/);
    // Translate forwarding function to C-callable external version
    if (!imp) {
        return _objc_msgForward;
    }
    return imp;
}
</code></pre>
<h2 id="方法缓存"><a class="header" href="#方法缓存">方法缓存</a></h2>
<p><a href="https://tech.meituan.com/2015/08/12/deep-understanding-object-c-of-method-caching.html">深入理解 Objective-C：方法缓存</a></p>
<p>为什么需要缓存：</p>
<ol>
<li>大部分方法不会只调用一次，而且往往重复的几率较高；</li>
<li>当一个方法在比较“上层”的类中，而使用比较“下层”的对象去调用时，如果没有缓存，整个遍历就会比较耗时。</li>
</ol>
<p>使用散列表来进行缓存，具体代码分析可以查看上面的文章，使用散列表可以加快检索速度。</p>
<h2 id="浅尝-objc_msgsend"><a class="header" href="#浅尝-objc_msgsend">浅尝 <code>objc_msgSend</code></a></h2>
<p><a href="https://kingcos.me/posts/2019/objc_msgsend/">浅尝 objc_msgSend</a></p>
<p>对 <code>objc_msgSend</code> 整体流程进行研究，包括消息发送，动态方法解析以及消息转发三部分。</p>
<h2 id="objective-c-message-forwarding"><a class="header" href="#objective-c-message-forwarding">Objective-C Message Forwarding</a></h2>
<p><a href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objective-c-message-forwarding.html">mikeash.com: Friday Q&amp;A 2009-03-27: Objective-C Message Forwarding</a></p>
<p>当给一个对象发送一个它无法响应的消息时，并不会说直接抛出 <code>unrecognized selector sent to instance</code> 错误，而是会经过一系列的消息转发处理，提供了处理机制。</p>
<h3 id="lazy-method-resolution"><a class="header" href="#lazy-method-resolution">Lazy method resolution</a></h3>
<p>runtime 在发送消息时会查找对应的 <code>IMP</code> ，而 Lazy method resolution 提供了一个延迟到发送消息时才生成对应方法的机制，而不是提前就设置好所有方法。 Lazy method solution 处理消息非常快，当添加完方法后就会走正常的消息处理流程，但是缺少灵活性，无法改变参数，接收对象和返回参数等。在 Lazy method solution 中会调用以下方法：</p>
<pre><code class="language-objectivec">/// 类方法
+ (BOOL)resolveClassMethod:(SEL)sel;
/// 对象方法
+ (BOOL)resolveInstanceMethod:(SEL)sel;
</code></pre>
<p>如果在方法中添加 <code>SEL</code> 的实现和返回 <code>YES</code> ，就会重走消息处理流程，如果返回 <code>NO</code> 就会进入消息转发的下一个流程。</p>
<p>CoreData 就是通过结合 <code>@dynamic</code> 属性，在运行时动态生成 <code>setter</code> 和 <code>getter</code> 方法。</p>
<h3 id="fast-fowarding"><a class="header" href="#fast-fowarding">Fast Fowarding</a></h3>
<p>在 Lazy method resolution 返回 <code>NO</code> 之后，就会走到 Fast Fowarding 流程，调用以下方法：</p>
<pre><code class="language-objectivec">- (id)forwardingTargetForSelector:(SEL)aSelector;
</code></pre>
<p>通过这个方法我们可以返回其它对象来响应这个 <code>SEL</code> ，这里属于消息转发的基础流程，所以性能开销也比较小。通过这个方法，我们可以实现类似于多继承的机制，根据不同的 <code>SEL</code> 返回不同的对象，即使自己当前没有实现对应的 <code>SEL</code> 。</p>
<h3 id="normal-forwarding"><a class="header" href="#normal-forwarding">Normal Forwarding</a></h3>
<p>Normal Forwarding 是消息转发的最后一个处理流程，会相继调用以下两个方法：</p>
<pre><code class="language-objectivec">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel;
- (void)forwardInvocation:(NSInvocation *)inv;
</code></pre>
<p>先调用 <code>methodSignatureForSelector:</code> 方法来返回 <code>NSMethodSignature</code> ， <code>NSMethodSignature</code> 用于生成 <code>NSInvocation</code> ，而 <code>NSInvocation</code> 包含了 <code>Target</code> ， <code>SEL</code> ，所有参数和返回值，它以对象的形式对消息进行了一层封装。然后就会调用 <code>forwardInvocation:</code> 对 <code>NSInvocation</code> 进行处理。 <code>NSInvocation</code> 非常灵活，返回值，处理对象，参数和 <code>SEL</code> 都可以进行改变。下面是一个非常简单的例子，假设我们想给 <code>NSArray</code> 添加一个这样的特性：当给  <code>NSArray</code> 发送消息时，如果 <code>NSArray</code> 无法响应，就查找它里面的元素，找出可以响应的对象并进行发送。</p>
<pre><code class="language-objectivec">@implementation NSArray (ForwardingIteration)

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    NSMethodSignature *sig = [super methodSignatureForSelector:sel];
    if(!sig)
    {
        for(id obj in self)
            if((sig = [obj methodSignatureForSelector:sel]))
                break;
    }
    return sig;
}

- (void)forwardInvocation:(NSInvocation *)inv
{
    for(id obj in self)
        [inv invokeWithTarget:obj];
}

@end
</code></pre>
<p>以上三个流程，性能递减，灵活性递增，可以根据具体需求在对应的流程中进行处理。</p>
<h2 id="消息转发的应用"><a class="header" href="#消息转发的应用">消息转发的应用</a></h2>
<p><a href="https://triplecc.github.io/2017/07/09/2017-07-09-objective-cxiao-xi-zhuan-fa-ying-yong-zhi-ji-chu/">Objective-C 消息转发应用场景摘录</a></p>
<h3 id="weak-proxy"><a class="header" href="#weak-proxy">Weak Proxy</a></h3>
<p><a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.m">ibireme/YYKit</a></p>
<p><code>YYWeakProxy</code> 通过弱引用持有对象来避免循环引用，在设置 <code>NSTimer</code> 或者 <code>CADisplayLink</code> 时可以使用，示例代码：</p>
<pre><code class="language-objectivec">@implementation MyView {
    NSTimer *_timer;
}

- (void)initTimer {
    YYWeakProxy *proxy = [YYWeakProxy proxyWithTarget:self];
    _timer = [NSTimer timerWithTimeInterval:0.1 target:proxy selector:@selector(tick:) userInfo:nil repeats:YES];
}

- (void)tick:(NSTimer *)timer {...}
@end
</code></pre>
<h3 id="delegate-proxy"><a class="header" href="#delegate-proxy">Delegate Proxy</a></h3>
<p><a href="https://github.com/Instagram/IGListKit/blob/019b22da07324f5dfdb81863865360937087b95d/Source/IGListKit/Internal/IGListAdapterProxy.m">Instagram/IGListKit</a></p>
<p>内部对代理进行一层封装，可以区分不同的方法，转发给不同的对象，也可以减少胶水代码，不需要手动对每个代理方法进行转发。</p>
<h3 id="multicast-delegate"><a class="header" href="#multicast-delegate">Multicast Delegate</a></h3>
<p><a href="https://github.com/robbiehanson/XMPPFramework/wiki/MulticastDelegate">robbiehanson/XMPPFramework</a></p>
<p>Wiki 里列了一下 <code>Delegate</code> 和 <code>Notification</code> 的优缺点，以及 Multicast Delegate 的特性。</p>
<p><code>Delegate</code> 优点：</p>
<ul>
<li>注册多个回调方法更加容易；</li>
<li>处理多个参数时更加容易和简单；</li>
<li>允许返回值。</li>
</ul>
<p><code>Delegate</code> 缺点：</p>
<ul>
<li>只能有一个 <code>Delegate</code> 。</li>
</ul>
<p><code>Notification</code> 优点：</p>
<ul>
<li>多个对象可以响应同一个通知。</li>
</ul>
<p><code>Notification</code> 缺点：</p>
<ul>
<li>注册多个回调时非常麻烦；</li>
<li>从 <code>Dictionary</code> 里取出参数时也十分麻烦；</li>
<li>不支持返回值。</li>
</ul>
<p>Multicast Delegate 支持的特性：</p>
<ul>
<li>支持多个回调对象，即广播给所有监听者；</li>
<li>良好的扩展性，支持定义不同的 <code>Delegate</code> ；</li>
<li>支持返回值；</li>
<li>线程安全。</li>
</ul>
<p>核心原理就是在 <code>methodSignatureForSelector:</code> 和 <code>forwardInvocation:</code> 中进行调用 <code>delegates</code> 中对应的方法，具体实现可以查看源代码：</p>
<p><a href="https://github.com/robbiehanson/XMPPFramework/blob/master/Utilities/GCDMulticastDelegate.m">robbiehanson/XMPPFramework</a></p>
<h3 id="nsundomanager"><a class="header" href="#nsundomanager">NSUndoManager</a></h3>
<p><code>NSUndoManager</code> 通过 <code>NSInvocation</code> 记录 <code>undo</code> 时需要执行的方法，当 <code>undo</code> 时就触发最新的 <code>NSInvocation</code> 。</p>
<h3 id="aspects"><a class="header" href="#aspects">Aspects</a></h3>
<p><a href="https://github.com/steipete/Aspects">steipete/Aspects</a></p>
<p>核心原理：</p>
<ol>
<li>对 <code>-forwardInvocation:</code> 进行 hook ，以便在执行原函数前后进行一些操作；</li>
<li>对需要处理的方法进行 hook ，替换为 <code>_objc_msgForward</code> 或者 <code>_objc_msgForward_stret</code> ，这样就会触发消息转发机制，执行 <code>-forwardInvocation:</code> 。</li>
</ol>
<p>具体的源码解析：</p>
<p><a href="https://dirtmelon.github.io/posts/Aspects/">Aspects</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvo"><a class="header" href="#kvo">KVO</a></h1>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA">Introduction to Key-Value Observing Programming Guide</a></p>
<p>开启 KVO 需要严格遵循以下 3 个步骤：</p>
<ol>
<li>使用 <code>addObserver:forKeyPath:options:context:</code> 方法注册监听者；</li>
<li>在监听类中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来接收通知；</li>
<li>当不需要接收时，需要调用 <code>removeObserver:forKeyPath:</code> 。在监听者 <code>dealloc</code> 方法中需要调用这个方法来移除监听。</li>
</ol>
<p>其它：</p>
<p><code>automaticallyNotifiesObserversForKey:</code> 默认返回 <code>YES</code> ，当重写并对某个 <code>Key</code> 返回 <code>NO</code> 时，那么修改属性时就需要手动调用 <code>(void)willChangeValueForKey:(NSString *)key</code> 与 <code>-(void)didChangeValueForKey:(NSString *)key</code> 发送通知，我们也可以通过这样在 <code>Setter</code> 方法判断对象是否真的发生改变，只有真的发生改变时才发送通知。</p>
<h2 id="kvo-详解"><a class="header" href="#kvo-详解">KVO 详解</a></h2>
<p><a href="https://kingcos.me/posts/2019/kvo_in_ios/">iOS 中的 KVO</a></p>
<p>这篇文章非常详细，从 <code>KVO</code> 的使用到原理都进行了说明。</p>
<h2 id="kvc-和-kvo"><a class="header" href="#kvc-和-kvo">KVC 和 KVO</a></h2>
<p><a href="https://objccn.io/issue-7-3/">ObjC 中国 - KVC 和 KVO</a></p>
<p>一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者 RunLoop 的处理。</p>
<p><a href="https://github.com/objcio/issue-7-lab-color-space-explorer/blob/master/Lab%20Color%20Space%20Explorer/KeyValueObserver.m">objcio/issue-7-lab-color-space-explorer</a></p>
<h2 id="friday-qa-about-kvo"><a class="header" href="#friday-qa-about-kvo">Friday Q&amp;A About KVO</a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html">mikeash.com: Friday Q&amp;A 2009-01-23</a></p>
<p>Mikeash 关于 KVO 原理的文章：</p>
<ul>
<li>动态生成一个 <code>KVO</code> 的子类，实现了 <code>dealloc</code> ， <code>_isKVOA</code> ， <code>class</code> 方法；</li>
<li>只会生成一个 <code>KVO</code> 子类，对所有监听的属性的设置方法都进行了替换，如果针对不同的属性监听生成不同类，就需要动态生成大量的不同的类，所以苹果选择了只生成一个类；</li>
<li>替换了对应的方法的 <code>IMP</code> ，改用内部的 <code>NSSet...ValueAndNotify</code> ；</li>
</ul>
<h2 id="key-value-observing-done-right"><a class="header" href="#key-value-observing-done-right">Key-Value Observing Done Right</a></h2>
<p><a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html">mikeash.com: Key-Value Observing Done Right</a></p>
<p>Mikeash 先是吹捧了一下 KVO 机制，非常强大和好用，但是 API 设计非常糟糕：</p>
<ol>
<li><code>-addObserver:forKeyPath:options:context:</code> 不支持 <code>selector</code> 参数，对比 <code>NSNotificationCenter</code> 的设计，可谓高下立判， KVO 必须要在  <code>-observeValueForKeyPath:ofObject:change:context:</code> 中处理消息或者传递给父类；</li>
<li>因为不支持 <code>selector</code> 参数，所以如果在相同的 <code>observer</code> 监听相同的 <code>KeyPath</code> 时，需要通过 <code>context</code> 参数来进行区分；</li>
<li><code>-removeObserver:forKeyPath:</code> 不支持 <code>context</code> 参数， KVO 是在 iOS2.0 时增加的，后面在 iOS5.0 新增了 <code>-removeObserver:forKeyPath:context:</code> ，支持 <code>context</code> 参数。</li>
</ol>
<h2 id="kvo-considered-harmful"><a class="header" href="#kvo-considered-harmful">KVO Considered Harmful</a></h2>
<p><a href="https://khanlou.com/2013/12/kvo-considered-harmful/">kvo-considered-harmful</a></p>
<p>KVO 缺点：</p>
<ol>
<li>所有回调都在同一个方法中进行，稍不留意这个方法就会快速膨胀；</li>
<li>使用字符串硬编码，如果被监听的对象修改了属性名，编译期无法察觉；</li>
<li>要求处理父类的 KVO 流程；</li>
<li>移除 observer 时有可能会崩溃；</li>
<li>充斥着大量有可能会失败的操作，作者认为一个好的 API 设计应该起到使用者成功地调用他们，即使没有解释为什么要这样去调用；</li>
<li>流程过于隐藏，没办法追踪数据改变的流程，与 delegate 模式相比， KVO 在 debug 时比较麻烦，且需要在运行时通过 <code>isKindOfClass:</code> 动态判断类型；</li>
<li>有可能造成死循环，如果不小心在回调中修改了监听的属性，那么就会造成死循环，如果说两个属性在不同的 KVO 流程中互相修改，也会造成死循环，且难于 debug ；</li>
<li>KVO 在某些场景下会失效，比如说 <code>__weak</code> 属性，在 <code>__weak</code> 对象被释放时， KVO 是不会去清理对应的监听，导致可能会出现野指针崩溃；</li>
<li>KVO 是一种老旧的模式，在 Apple 平台上，我们可以通过其它方式比如说 Delegate ，Block 和明确的发布/订阅 （ <code>NSNotificationCenter</code> ）方式来解决问题，而不是使用 KVO 这种隐晦的方式。</li>
</ol>
<p>什么时候可以使用 KVO ：</p>
<ol>
<li>Apple 官方要求，比如说 <code>AVPlayer</code> ，要求通过监听 <code>status</code> 属性来获取播放器的状态；</li>
<li>设计相关的 API 给其他开发者使用。</li>
</ol>
<h2 id="刨根问题-kvo-原理"><a class="header" href="#刨根问题-kvo-原理">刨根问题 KVO 原理</a></h2>
<p><a href="https://juejin.im/post/5c22023df265da6124157a25">刨根问底KVO原理</a></p>
<p>通过源码相关的伪代码来探究 <code>KVO</code> 的实现方式，如果需要深入了解 <code>KVO</code> 的原理，可以阅读下这篇文章。 <code>KVO</code> 的原理看起来虽然比较简单，但是实现时还是有不少坑，比如说多线程，系统的具体实现也体现了这一点，通过 <code>pthread_mutex_lock</code> 来保证线程安全。</p>
<h2 id="kvocontroller-解析"><a class="header" href="#kvocontroller-解析">KVOController 解析</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md">draveness/analyze</a></p>
<p><a href="https://github.com/facebookarchive/KVOController">facebookarchive/KVOController</a></p>
<p>为了解决 <code>KVO</code> 非常难用的问题，Facebook 开源了 <code>KVOController</code> ，优点如下：</p>
<ol>
<li>不需要手动移除 <code>observer</code> ，这里利用了关联属性在对象释放时也会被释放的原理，在关联属性的 <code>dealloc</code> 方法中移除 <code>observer</code> ；</li>
<li>支持使用 <code>block</code> ，减少复杂度，添加监听和处理通知的代码可以放在同一处。</li>
</ol>
<h2 id="基于-kvo-hook-子类的方法"><a class="header" href="#基于-kvo-hook-子类的方法">基于 KVO hook 子类的方法</a></h2>
<p><a href="http://satanwoo.github.io/2017/11/27/KVO-Swizzle/">一种基于KVO的页面加载，渲染耗时监控方法</a></p>
<p>在做 <code>ViewController</code> 的耗时检测时，我们需要记录各个 <code>UIViewController</code> 子类对应方法的耗时，如果只是针对 <code>UIViewController</code> 的方法进行 <code>hook</code> ，那么只能记录到 <code>UIViewController</code> 的方法耗时，无法获取子类的方法耗时。</p>
<p>在进行 <code>KVO</code> 时 <code>runtime</code> 实际上会帮你创建一个 <code>KVO</code> 相关的子类，由此可以在初始化时进行一次 <code>KVO</code> 来生成一个新的子类，然后对这个子类方法进行耗时检测。</p>
<p>至于为什么使用 <code>KVO</code> 的方式，下面这篇文章有进行解释，而且也给出了具体实现代码：</p>
<p><a href="https://punmy.cn/2018/06/18/15278496835424.html">巧妙利用KVO实现精准的VC耗时检测</a></p>
<p><a href="https://github.com/panmingyang2009/VCProfiler">panmingyang2009/VCProfiler</a></p>
<h2 id="kvo-在不同的二进制中多个符号并存的-crash-问题"><a class="header" href="#kvo-在不同的二进制中多个符号并存的-crash-问题">KVO 在不同的二进制中多个符号并存的 Crash 问题</a></h2>
<p><a href="http://satanwoo.github.io/2017/09/11/KVO-CRASH/">KVO在不同的二进制中多个符号并存的Crash问题</a></p>
<p>当两个产物都有相同的类名时，比如主二进制和动态库中，这两个类都会被 realize ，都能够被正常调用。</p>
<blockquote>
<p>其原因在于苹果使用的是 <code>two level namespace</code> 的技术。在这种形式下，符号所在的“库”的名称也会作为符号的一部分。链接的时候， <code>staic linker</code> 会标记住在这个符号是来自于哪个库的。这样不仅大大减少了dyld搜索符号所需要的时间，也更好对后续库的更新进行了兼容。</p>
</blockquote>
<p>但是由于全局类表的存在，在动态创建 <code>KVO</code> 的子类时，只能产生一个。所以就导致 <code>allocate</code> 失败，从而引发 <code>register</code> 过程的 Crash 问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kvc"><a class="header" href="#kvc">KVC</a></h1>
<h2 id="基础-1"><a class="header" href="#基础-1">基础</a></h2>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">About Key-Value Coding</a></p>
<p><code>KVC</code> 是通过 <code>NSKeyValueCodinng</code> 协议来实现的。当一个对象支持 <code>KVC</code> 时，它的属性可以通过字符串来进行访问。 <code>KVC</code> 对象提供了简单的接口，通过接口和字符串可以访问所有的属性。 <code>KVC</code> 是 Cocoa 中一些功能的基石，如 <code>KVO</code> ， <code>Cocoa</code> 绑定机制， Core Data 等。</p>
<h3 id="用途"><a class="header" href="#用途">用途</a></h3>
<p>只要继承自 <code>NSObject</code> 就可以使用 <code>KVC</code> ， <code>NSObject</code> 已默认支持 <code>NSKeyValueCoding</code> 协议和提供默认的必须方法， <code>KVC</code> 提供了以下特性：</p>
<ul>
<li>获取对象属性。协议定义了一些方法，比如说 <code>valueForKey:</code> 和 <code>setValue:forKey:</code> ，使用字符串作为参数，可以访问到对象的属性或者对属性进行设置；</li>
<li>操作集合属性，跟其它属性一样，提供了对集合属性进行操作的方法，如果需要对集合进行修改， <code>KVC</code> 也提供了独特高效的方法；</li>
<li>集合属性的操作符，当访问对象的集合属性时， <code>KVC</code> 为我们提供了一些操作符，通过这些操作符可以直接对集合获取某些属性，继续计算转换等；</li>
<li>获取非对象属性， <code>KVC</code> 也支持获取非对象属性，包括纯量属性和结构体等，会自动将它们和对象之间进行转换，以便协议的方法进行调用；</li>
</ul>
<h3 id="适配-kvc"><a class="header" href="#适配-kvc">适配 KVC</a></h3>
<p>如果想要你的对象支持 <code>KVC</code> ，那么你需要使得它们遵循 <code>NSKeyValueCoding</code> 协议。幸运的是， <code>NSObject</code> 已经为我们做好一切工作，因此如果你想要使用 <code>KVC</code> ，那么只需要继承自 <code>NSObject</code> 即可。为了保证 <code>KVC</code> 生效，你需要保证对象的存取器和变量名遵守相关的规则。</p>
<h3 id="获取对象属性"><a class="header" href="#获取对象属性">获取对象属性</a></h3>
<p>一个对象会在它的 <code>interface</code> 声明中定义属性，而属性则会分成以下几个分类：</p>
<ul>
<li>属性，系统提供的一些比较简单的值，如纯量属性，字符串， <code>Bool</code> 值等。</li>
<li>一对一关系，对于拥有者来说它们是可变对象。一个对象的属性可以在对象本身不改变的情况下发生改变。举个例子，比如说一个银行客户的对象拥有一个 <code>Person</code> 的 <code>owner</code> 属性， <code>Person</code> 拥有一个地址属性。 <code>owner</code> 就可以在不改变银行客户的引用关系的前提下改变自己的地址属性；</li>
<li>一对多，集合对象，比如说 <code>NSArray</code> 或者 <code>NSSet</code> ，也可以使用其它的一些自定义集合类型；</li>
</ul>
<pre><code class="language-objectivec">@interface BankAccount : NSObject
 
@property (nonatomic) NSNumber* currentBalance;              // An attribute
@property (nonatomic) Person* owner;                         // A to-one relation
@property (nonatomic) NSArray&lt; Transaction* &gt;* transactions; // A to-many relation
 
@end
</code></pre>
<p>为了保持封装性，一个对象会提供为属性提供存取方法作为它的接口。</p>
<pre><code class="language-objectivec">[myAccount setCurrentBalance:@(100.0)];
</code></pre>
<p>这样很直接，但是会缺少灵活性。 <code>KVC</code> 为对象提供了一种通过字符串来获取属性的机制。</p>
<h3 id="通过-keys-或者-keypaths-识别对象的属性"><a class="header" href="#通过-keys-或者-keypaths-识别对象的属性">通过 <code>Keys</code> 或者 <code>KeyPaths</code> 识别对象的属性</a></h3>
<p><code>key</code> 是一个字符串，对应某个属性。通常情况下， <code>key</code> 会跟属性的名字一致。使用  <code>ASCII</code> 编码，不包含空格，以小写字母开头 （当然了，也会有例外，比如说 <code>URL</code> 属性）。</p>
<p>对于 <code>BankAccount</code> 来说，我们可以通过以下属性来设置 <code>currentBalance</code> ：</p>
<pre><code class="language-objectivec">[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];
</code></pre>
<p>实际上，我们可以使用相同的方法，不同的 <code>key</code> 参数来获取 <code>myAccount</code> 对象的所有属性。</p>
<p>我们可以通过 <code>.</code> 来使用 <code>KeyPath</code> 。假设 <code>Person</code> 和 <code>Address</code> 也符合 <code>KVC</code> 规范，我们可以通过 <code>owner.address.street</code> 的方式来访问账户所有者的地址中的街道信息。</p>
<p><code>NSObject</code> 已经实现了 <code>NSKeyValueCoding</code> 协议所需要的方法，所以只需要继承自 <code>NSObject</code> ，就可以得到默认的实现和支持 <code>KVC</code> 。</p>
<ul>
<li><code>valueForKey:</code> ，返回一个以 <code>key</code> 参数来进行命名的属性。如果说属性无法被 <code>key</code> 通过定好的规则搜索到，对象会调用 <code>valueForUndefinedKey:</code> 方法，这个方法的默认实现是抛出一个 <code>NSUndefinedKeyException</code> 异常，但是子类可以通过重写这个方法来更优雅地处理这个场景；</li>
<li><code>valueForKeyPath:</code> ，返回接收器中满足 <code>keyPath</code> 路径的值。所有在这个 <code>keyPath</code> 路径中的对象都需要满足特定的 <code>key</code> 对应的 <code>KVC</code> 机制，如果说 <code>valueForKey:</code> 找不到对应的存取方法，就会收到 <code>valueForUndefinedKey:</code> 消息；</li>
<li><code>dictionaryWithValuesForKeys:</code> ，返回 <code>value</code> 和 <code>key</code> 组成的 <code>NSDictionary</code> ，它会为数组的每个 <code>key</code> 调用 <code>valueForKey:</code> 方法来获取对应的值。</li>
</ul>
<p>集合对象，比如说 <code>NSArray</code> ， <code>NSSet</code> 和 <code>NSDictionary</code> ，不可以包含 <code>nil</code> 。你可以使用 <code>NSNull</code> 对象来替换 <code>nil</code> ， <code>NSNull</code> 提供了一个单例来表示 <code>nil</code> 值。 <code>dictionaryWithValuesForKeys:</code> 和 <code>setValuesForKeysWithDictionary:</code> 会在 <code>NSNull</code> （ dictionary 参数）和 <code>nil</code> （属性）中自动切换。</p>
<p><code>KeyPath</code> 也支持多对一关系，当 <code>key-path</code> 路径中有一对多的关系时，那么就会返回数组。比如说 <code>transactions.payee</code> 会以数组形式返回所有 <code>transactions</code> 中的 <code>payee</code> 对象。</p>
<h3 id="通过-keys-设置属性值"><a class="header" href="#通过-keys-设置属性值">通过 <code>Keys</code> 设置属性值</a></h3>
<p>和 <code>getter</code> 一样， <code>KVC</code> 也提供了一组通用的 <code>setter</code> 方法，由 <code>NSObject</code> 中 <code>NSKeyValueCoding</code> 协议的默认方法提供：</p>
<ul>
<li><code>setValue:forKey:</code> ，使用 <code>value</code> 来设置对象中对应 <code>key</code> 的属性。 <code>setValue:forKey:</code> 的默认实现会自动对 <code>NSNumber</code> 和 <code>NSValue</code> 对象进行解包，把它们转换为对应的纯量和结构体，然后设置到对应的属性中。如果对象中没有和 <code>key</code> 对应的 <code>setter</code> ，那么对象就会调用它自己的 <code>setValue:forUndefinedKey:</code> 方法，这个方法的默认实现会抛出一个 <code>NSUndefinedKeyException</code> 异常。子类可以通过重写这个方法来 实现自定义逻辑。</li>
<li><code>setValue:forKeyPath:</code> ，使用 <code>value</code> 来设置对象中与 <code>keyPath</code> 路径相符的属性。当存在 <code>keyPath</code> 路径上不支持对应的 <code>key</code> 的 <code>KVC</code> 时，就会收到 <code>setValue:forUndefinedKey:</code> 消息。</li>
<li><code>setValuesForKeysWithDictionary:</code> ，批量设置属性，使用 <code>dictionary</code> 中的 <code>key</code> 来指明属性。它通过调用 <code>setValue:forKey:</code> 方法来为每一对 <code>key-value</code> 进行设置，自动将 <code>NSNull</code> 对象替换为 <code>nil</code> 。</li>
</ul>
<p>在默认的实现中，当你尝试设置一个非对象的属性为 <code>nil</code> 时， <code>KVC</code> 会调用 <code>setNilValueForKey:</code> 方法。这个方法的默认实现会抛出一个 <code>NSInvalidArgumentException</code> ，对象可以通过重写这个行为来提供一个默认值或者标记值（ marker value ）。</p>
<p><a href="https://kingcos.me/posts/2019/kvc_in_ios/">iOS 中的 KVC</a></p>
<p>这篇文章有更详细的说明</p>
<p><a href="https://juejin.im/post/6844903934662803464">iOS 开发：『Crash 防护系统』（三）KVC 防护</a></p>
<p><code>KVC</code> 崩溃防护。上面提到 <code>KVC</code> 相关的崩溃，这篇文章中相关防护也是对这些方法进行 <code>hook</code> ，替换掉原来的实现。</p>
<pre><code class="language-objectivec">/********************* NSObject+KVCDefender.h 文件 *********************/
#import &lt;Foundation/Foundation.h&gt;

@interface NSObject (KVCDefender)

@end

/********************* NSObject+KVCDefender.m 文件 *********************/
#import &quot;NSObject+KVCDefender.h&quot;
#import &quot;NSObject+MethodSwizzling.h&quot;

@implementation NSObject (KVCDefender)

// 不建议拦截 `setValue:forKey:` 方法
+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        // 拦截 `setValue:forKey:` 方法，替换自定义实现
        [NSObject yscDefenderSwizzlingInstanceMethod:@selector(setValue:forKey:)
                                       withMethod:@selector(ysc_setValue:forKey:)
                                        withClass:[NSObject class]];

    });
}

- (void)ysc_setValue:(id)value forKey:(NSString *)key {
    if (key == nil) {
        NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages : [&lt;%@ %p&gt; setNilValueForKey]: could not set nil as the value for the key %@.&quot;,NSStringFromClass([self class]),self,key];
        NSLog(@&quot;%@&quot;, crashMessages);
        return;
    }

    [self ysc_setValue:value forKey:key];
}

- (void)setNilValueForKey:(NSString *)key {
    NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages : [&lt;%@ %p&gt; setNilValueForKey]: could not set nil as the value for the key %@.&quot;,NSStringFromClass([self class]),self,key];
    NSLog(@&quot;%@&quot;, crashMessages);
}

- (void)setValue:(id)value forUndefinedKey:(NSString *)key {
    NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages : [&lt;%@ %p&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key: %@,value:%@'&quot;,NSStringFromClass([self class]),self,key,value];
    NSLog(@&quot;%@&quot;, crashMessages);
}

- (nullable id)valueForUndefinedKey:(NSString *)key {
    NSString *crashMessages = [NSString stringWithFormat:@&quot;crashMessages :[&lt;%@ %p&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key: %@&quot;,NSStringFromClass([self class]),self,key];
    NSLog(@&quot;%@&quot;, crashMessages);
    
    return self;
}

@end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autoreleasepool"><a class="header" href="#autoreleasepool">AutoreleasePool</a></h1>
<h2 id="autoreleasepool-解析"><a class="header" href="#autoreleasepool-解析">AutoreleasePool 解析</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.md">draveness/analyze</a></p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>
<p>整个 iOS 的入口都是放到 <code>@autoreleasepool</code> 的 <code>block</code> 中：</p>
<pre><code class="language-objectivec">int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>
<p>然后编译器会将其改写成下面的代码：</p>
<pre><code class="language-objectivec">void *context = objc_autoreleasePoolPush();
// {}中的代码
objc_autoreleasePoolPop(context);
</code></pre>
<p>我们也可以通过手动调用 <code>@autoreleasepool</code> 来创建自己的自动释放池。</p>
<p>RunLoop 每次处理事件时也会创建和释放 <code>autoreleasepool</code> 。App 启动后，会在主线程的 RunLoop 里注册两个 <code>autoreleasepool</code> 相关的 Observer ，其回调的方法都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code> 。</p>
<ol>
<li>第一个 Observer 监听的事件是 Entry ，即将进入 Loop ，会调用 <code>_objc_autoreleasePoolPush()</code> 来创建自动释放池，order 是 -2147483647 ，优先级最高，确保自动释放池的创建在其它回调之前；</li>
<li>第二个 Observer 监听了 BeforeWaiting 事件，当处理完事件即将进入休眠时调用，会调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池，order 是 2147483647 ，优先级最低，确保自动释放池的释放在所有回调之后，同时也会调用 <code>_objc_autoreleasePoolPush()</code> 来创建一个新的自动释放池，以供下一次唤醒使用；</li>
</ol>
<pre><code class="language-objectivec">void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}

void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre>
<p><code>AutoreleasePage</code> 的定义如下：</p>
<pre><code class="language-objectivec">class AutoreleasePoolPage {
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
};
</code></pre>
<p>自动释放池是由一系列的 <code>AutoreleasePoolPage</code> 组成，每个 <code>AutoreleasePoolPage</code> 的大小都是 4096 bit 大小。</p>
<ul>
<li>自动释放池是由 <code>AutoreleasePoolPage</code> 以双向链表的方式实现的</li>
<li>当对象调用 <code>autorelease</code> 方法时，会将对象加入 <code>AutoreleasePoolPage</code> 的栈中</li>
<li>调用 <code>AutoreleasePoolPage::pop</code> 方法会向栈中的对象发送 <code>release</code> 消息</li>
</ul>
<p>当使用容器的 <code>block</code> 枚举时，内部会自动添加一个 <code>AutoreleasePool</code> ：</p>
<pre><code class="language-objectivec">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    // 这里被一个局部@autoreleasepool包围着
}];
</code></pre>
<p>但是普通的 for 循环和 for in 循环中是没有的，所以当遍历中的 <code>autorelease</code> 变量所占用的内存较大时，需要手动添加 <code>@autoreleasepool</code> 。</p>
<h2 id="autoreleasepool-uses-in-swift"><a class="header" href="#autoreleasepool-uses-in-swift"><code>@autoreleasepool</code> uses in Swift</a></h2>
<p><a href="https://swiftrocks.com/autoreleasepool-in-2019-swift.html">@autoreleasepool uses in 2019 Swift</a></p>
<p>本文先是简单的介绍了 <code>autoreleasepool</code> 在 Objective-C 中的使用场景——在循环体中大量创建 <code>autorelease</code> 对象。而 ARC 对 Swift 的优化在过去几年中进步了很多，根据作者的测试，似乎 ARC for Swift 从不调用 <code>autorelease</code> ，而是用多次调用 <code>release</code> 来替代。所以对于纯粹的 Swift 对象我们可能不再需要 <code>autoreleasepool</code> 。但在 Swift 开发中 <code>autoreleasepool</code> 仍然有用，因为在 UIKit 和 Foundation 中仍然存在调用 <code>autorelease</code> 的遗留 <code>Objective-C</code> 类。在 Swift 5.2 上测试确实如此。</p>
<p><a href="https://swifter.tips/autoreleasepool/">Swifter</a></p>
<p>其实对于这个特定的例子，我们并不一定需要加入自动释放。在 Swift 中更提倡的是用初始化方法而不是用像上面那样的类方法来生成对象，而且从 Swift 1.1 开始，因为加入了可以<a href="https://swifter.tips/init-nil/">返回 <code>nil</code> 的初始化方法</a>，像上面例子中那样的工厂方法都已经从 API 中删除了。今后我们都应该这样写：</p>
<pre><code class="language-swift">let data = Data(contentsOfFile: path)
</code></pre>
<p>使用初始化方法的话，我们就不需要面临自动释放的问题了，每次在超过作用域后，自动内存管理都将为我们处理好内存相关的事情。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dealloc"><a class="header" href="#dealloc">dealloc</a></h1>
<h2 id="llvm-关于-dealloc-的说明"><a class="header" href="#llvm-关于-dealloc-的说明">LLVM 关于 <code>dealloc</code> 的说明</a></h2>
<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc">Clang 12 documentation</a></p>
<blockquote>
<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>
</blockquote>
<p><code>dealloc</code> 在最后 <code>release</code> 时调用，但此时实例变量（ <code>Ivars</code> ）并未释放，父类的  <code>dealloc</code> 会在子类的 <code>dealloc</code> 返回后调用。</p>
<blockquote>
<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>
</blockquote>
<p>实例变量会在 <code>root class</code> （根类）的 <code>dealloc</code> 中释放，一般来说就是 <code>NSObject</code> 的 <code>dealloc</code> 方法，释放顺序不确定。</p>
<h3 id="dealloc-调用时机"><a class="header" href="#dealloc-调用时机">dealloc 调用时机</a></h3>
<p><a href="https://zhongwuzw.github.io/2017/09/21/%E8%81%8A%E8%81%8Adealloc/">聊聊dealloc</a></p>
<p>当对象调用 <code>release</code> 方法时会走到 <code>sidetable_release</code> 这个方法中，而 <code>sidetable_release</code> 这个方法会判断是否需要调用 <code>dealloc</code> 方法：</p>
<pre><code class="language-objectivec">uintptr_t objc_object::sidetable_release(bool performDealloc)
{
#if SUPPORT_NONPOINTER_ISA
    assert(!isa.nonpointer);
#endif
    // 找到当前对象所对应的 SideTable
    SideTable&amp; table = SideTables()[this];
    bool do_dealloc = false;
    table.lock();
    // 找到当前对象所对应的引用计数
    RefcountMap::iterator it = table.refcnts.find(this);
    if (it == table.refcnts.end()) {
        // 如果找不到所对应的应用计数，则表示可以执行 dealloc ，
			  // 同时设置对应的值为 SIDE_TABLE_DEALLOCATING
        do_dealloc = true;
        table.refcnts[this] = SIDE_TABLE_DEALLOCATING;
    } else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) {
        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
        // 如果引用计数小于 SIDE_TABLE_DEALLOCATING ，则表示引用计数为 0 ，可以执行 dealloc
        do_dealloc = true;
        it-&gt;second |= SIDE_TABLE_DEALLOCATING;
    } else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) {
        // 引用计数减 1
        it-&gt;second -= SIDE_TABLE_RC_ONE;
    }
    table.unlock();
    // 进行释放操作，执行 dealloc
    if (do_dealloc  &amp;&amp;  performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
    }
    return do_dealloc;
}
</code></pre>
<p><code>dealloc</code> 有可能在任何线程调用，在最后一个调用 <code>release</code> 方法的线程中调用。</p>
<p>函数调用顺序： <code>dealloc-&gt;_objc_rootDealloc-&gt;objc_object::rootDealloc-&gt;object_dispose-&gt;objc_destructInstance</code> ：</p>
<pre><code class="language-objectivec">- (void)dealloc {
    _objc_rootDealloc(self);
}
</code></pre>
<pre><code class="language-objectivec">void _objc_rootDealloc(id obj)
{
    assert(obj);

    obj-&gt;rootDealloc();
}
</code></pre>
<pre><code class="language-objectivec">inline void
objc_object::rootDealloc()
{
    if (isTaggedPointer()) return;  // fixme necessary?
		// 判断 isa 的各个标志位，确认是否需要进行快速释放。
    if (fastpath(isa.nonpointer  &amp;&amp;  
                 !isa.weakly_referenced  &amp;&amp;  
                 !isa.has_assoc  &amp;&amp;  
                 !isa.has_cxx_dtor  &amp;&amp;  
                 !isa.has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        object_dispose((id)this);
    }
}
</code></pre>
<pre><code class="language-objectivec">id object_dispose(id obj)
{
    if (!obj) return nil;

    objc_destructInstance(obj);    
    free(obj);

    return nil;
}
</code></pre>
<pre><code class="language-objectivec">void *objc_destructInstance(id obj)
{
    if (obj) {
        Class isa_gen = _object_getClass(obj);
        class_t *isa = newcls(isa_gen);

        // Read all of the flags at once for performance.
        bool cxx = hasCxxStructors(isa);
        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);

        // This order is important.
        if (cxx) object_cxxDestruct(obj); // 1
        if (assoc) _object_remove_assocations(obj); // 2

        if (!UseGC) objc_clear_deallocating(obj); // 3
    }

    return obj;
}
</code></pre>
<ol>
<li><code>object_cxxDestruct</code> 调用 C++ 析构器，释放实例变量；</li>
<li><code>_object_remove_assocations</code> 清除 <code>Associated</code> 对象；</li>
<li><code>objc_clear_deallocating</code> ARC 相关操作，清理 <code>SideTable</code> ， <code>weak</code> 设置为 <code>nil</code> 等。</li>
</ol>
<h2 id="arc-下-dealloc-过程及-cxx_destruct-的探究"><a class="header" href="#arc-下-dealloc-过程及-cxx_destruct-的探究">ARC 下 <code>dealloc</code> 过程及 <code>.cxx_destruct</code> 的探究</a></h2>
<p><a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxx_destruct的探究</a></p>
<p>这篇文章对 <code>.cxx_destruct</code> 做了深入研究，包括 <code>.cxx_destruct</code> 如何释放实例变量，如何调用 <code>[super dealloc]</code> 。这两者都是由编译器帮我们完成，插入这部分的代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-pointer"><a class="header" href="#tagged-pointer">Tagged Pointer</a></h1>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Tagged_pointer">Tagged pointer</a></p>
<p>对象存储在内存中的时候总是内存对齐的，所以它们的地址会是单个指针大小的倍数，通常来说会是 16 的倍数。在 64 位系统中，对象的指针为 64 位整形。后面几位为 0 。由于后面几位一直为 0 。所以我们可以使用后面几位来记录一些事情。</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2013/404/">Advances in Objective-C - WWDC 2013 - Videos - Apple Developer</a></p>
<p>WWDC 2013 上相关介绍，从 36:49 开始。</p>
<p><img src="programming-languages/Objective-C/media/16295382272652.jpg" alt="" /></p>
<ul>
<li>苹果使用 Tagged Pointer 来存储一些比较小的数据，如： <code>NSNumber</code> ， <code>NSDate</code> 和 <code>NSString</code> 等；</li>
<li>由于直接使用指针本身来存储数据，不再需要额外生命周期管理，没有 <code>malloc/free</code> ；</li>
<li>3 倍的空间优化， 106 倍的创建或者销毁速度。</li>
</ul>
<p><img src="programming-languages/Objective-C/media/16295384569038.jpg" alt="" /></p>
<p>使用低位的 <code>bit</code> 来作为标识位。</p>
<h2 id="tagged-pointer-解析"><a class="header" href="#tagged-pointer-解析">Tagged Pointer 解析</a></h2>
<p><a href="https://wenghengcong.com/posts/b6becb26/">内存管理（二）Tagged Pointer</a></p>
<p><a href="https://juejin.cn/post/6844904132940136462">iOS - 老生常谈内存管理（五）：Tagged Pointer</a></p>
<p>由于内存对齐的关系，指针的值最后四位都是 0 ，所以可以使用这四位来做一些记录。如果最后一位是 1 ，则这个指针是 Tagged Pointer 。</p>
<pre><code class="language-objectivec">static inline bool 
_objc_isTaggedPointer(const void *ptr) 
{
    return ((intptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
}

#if OBJC_MSB_TAGGED_POINTERS
#   define _OBJC_TAG_MASK (1ULL&lt;&lt;63)
#else
#   define _OBJC_TAG_MASK 1
#endif

#if TARGET_OS_OSX &amp;&amp; __x86_64__
    // 64-bit Mac - tag bit is LSB
#   define OBJC_MSB_TAGGED_POINTERS 0
#else
    // Everything else - tag bit is MSB
#   define OBJC_MSB_TAGGED_POINTERS 1
#endif
</code></pre>
<p>在 iOS 平台上使用的是最高位进行判断，在 macOS 上 使用的是最低位。 Tagged Pointer 支持的类型：</p>
<pre><code class="language-objectivec">enum
{
    OBJC_TAG_NSAtom            = 0, 
    OBJC_TAG_1                 = 1, 
    OBJC_TAG_NSString          = 2, 
    OBJC_TAG_NSNumber          = 3, 
    OBJC_TAG_NSIndexPath       = 4, 
    OBJC_TAG_NSManagedObjectID = 5, 
    OBJC_TAG_NSDate            = 6, 
    OBJC_TAG_RESERVED_7        = 7, 

    OBJC_TAG_First60BitPayload = 0, 
    OBJC_TAG_Last60BitPayload  = 6, 
    OBJC_TAG_First52BitPayload = 8, 
    OBJC_TAG_Last52BitPayload  = 263, 

    OBJC_TAG_RESERVED_264      = 264
};
</code></pre>
<p>Tagged Pointer 不是真的对象，没有 isa 指针，不存在 <code>retain</code> ， <code>release</code> ， <code>autorelease</code> 等对象生命周期管理的流程，其引用计数为 <code>NSUInteger</code> 的最大值。</p>
<pre><code class="language-objectivec">dispatch_queue_t queue = dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i &lt; 1000; i ++) {
    dispatch_async(queue, ^{
        self.name = [NSString stringWithFormat:@&quot;abcdefghijk&quot;];
    })
}
dispatch_queue_t queue = dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i &lt; 1000; i ++) {
    dispatch_async(queue, ^{
        self.name = [NSString stringWithFormat:@&quot;abc&quot;];
    })
}
</code></pre>
<p>上面的代码中，第一个 for 循环会崩溃，因为在多线程中可能会重复 <code>release</code> ，而第二个不会，因为 Tagged Pointer 其实是值类型，不涉及到 <code>retain</code> 和 <code>release</code> 操作，其赋值操作是原子性的。</p>
<h2 id="lets-build-tagged-pointers"><a class="header" href="#lets-build-tagged-pointers">Let's Build Tagged Pointers</a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">mikeash.com: Friday Q&amp;A 2012-07-27: Let's Build Tagged Pointers</a></p>
<p>Mike Ash 尝试自己实现了一个 Tagged Pointer 。</p>
<h2 id="tagged-pointer-strings"><a class="header" href="#tagged-pointer-strings">Tagged Pointer Strings</a></h2>
<p><a href="https://mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html">mikeash.com: Friday Q&amp;A 2015-07-31: Tagged Pointer Strings</a></p>
<p><a href="https://swift.gg/2018/10/08/tagged-pointer-strings/">Tagged Pointer 字符串</a></p>
<p>如果某些字符串可以保存为 60 位以内的二进制数据，那么对应的 <code>NSString</code> 就会被创建为 Tagged Pointer 。</p>
<p>由于 <code>NSString</code> 字符串编码的特殊性，苹果针对 <code>NSString</code> 的 Tagged Pointer 进行优化。</p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<pre><code class="language-objectivec">NSString *a = @&quot;a&quot;;
NSString *b = [[a mutableCopy] copy];
NSLog(@&quot;%p %p %@&quot;, a, b, object_getClass(b));
</code></pre>
<ol>
<li>常量字符串不会被存储为 Tagged Pointer ，因为常量字符串必须保证可以兼容不同的系统，但是 Tagged Pointer 的内部实现细节却不能保证兼容不同的系统，常量字符串嵌入到二进制字符串时有可能会崩溃；</li>
<li>先执行 <code>[a mutableCopy]</code> ，因 <code>copy</code> 返回的是不可变的字符串，所以常量字符串的 <code>copy</code> 得到的还是原来的常量字符串，所以先通过 <code>mutableCopy</code> 生成一个新的可变字符串，然后再通过 <code>copy</code> 得到一个不可变的 Tagged Pointer ， Tagged Pointer 只会在运行时创建。</li>
</ol>
<p>输出结果如下：</p>
<pre><code class="language-objectivec">0x10ba41038 0x6115 NSTaggedPointerString
</code></pre>
<p>首先第一个 <code>a</code> 不是 Tagged Pointer ，是一个对象的指针，第二个是 Tagged Pointer。</p>
<p>然后 <code>NSString</code> 对应的 Tagged Pointer 使用的是 ASCII 编码，占用的长度较少。</p>
<p>伪代码：</p>
<pre><code class="language-objectivec">unsigned short -[NSTaggedPointerString characterAtIndex:](void * self, void * _cmd, unsigned long long index) {
     int8_t buffer[11];
     length = self &gt;&gt; 0x4 &amp; 0xf;
     if (length &gt;= 0x8) {
         stringData = self &gt;&gt; 0x8;
         table = &quot;eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX&quot;;
             cursor = length;
             if (length &lt; 0xa) {
                 do {
                     buffer[cursor - 1] = table[stringData &amp; 0x3f];
                     cursor = cursor - 0x1;
                     stringData = stringData &gt;&gt; 0x6;
                 } while (cursor != 0x0);
             }
             else {
                 do {
                     buffer[cursor - 1] = table[stringData &amp; 0x1f];
                     cursor = cursor - 0x1;
                     stringData = stringData &gt;&gt; 0x5;
                 } while (cursor != 0x0);
             }
     } else {
         *(uint64_t *)buffer = self &gt;&gt; 8;
     }
     if (length &lt;= index) {
         rbx = r8;
         ___CFExceptionProem(self, _cmd);
         [NSException raise:@&quot;NSRangeException&quot; format:@&quot;%@: Index %lu out of bounds; string length %lu&quot;];
         r8 = rbx;
     }
     rax = buffer[index];
     return rax;
 }
</code></pre>
<ol>
<li>长度小于 8 的情况下，直接使用 ASCII 编码，所以 <code>self</code> 按位编译后直接赋值给 <code>buff</code> 即可；</li>
<li>长度大于等于8小于10，就会取出 <code>stringData</code> 的最低 6 位，作为 <code>table</code> 的索引取出相应的值拷贝到 <code>buffer</code> 中，然后将 <code>stringData</code> 右移 6 位，重复操作；</li>
<li>如果大于等于 10 ，那么就会使用 5 位编码，而 <code>table</code> 只使用前半部分。</li>
</ol>
<p>构造 <code>NSString</code> Tagged Pointer 的原理大致上也和上面的一致。</p>
<p>6 位编码表：</p>
<pre><code>eilotrm.apdnsIc ufkMShjTRxgC4013bDNvwyUL2O856P-B79AFKEWV_zGJ/HYX
</code></pre>
<p>猜测是按照在英语中出现的频率进行排序，使得尽量多的字符串可以使用 Tagged Pointer 。通过一个简单又巧妙的查找表方式在有限的空间内存储尽量的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weak"><a class="header" href="#weak">weak</a></h1>
<h2 id="实现-1"><a class="header" href="#实现-1">实现</a></h2>
<p><a href="https://triplecc.github.io/2019/03/20/objective-c-weak-implement/">Objective-C weak 弱引用实现</a></p>
<p>作者在文中提供了一个简单版的 <code>weak</code> 实现：</p>
<pre><code class="language-objectivec">// { 对象地址 : [ 对象指针地址1、 对象指针地址1] }
static NSMutableDictionary *weakTable;
@interface A : NSObject
@end
@implementation A
- (void)dealloc {
    // 获取指向此对象的所有指针变量地址
    for (NSNumber *ptrPtrNumber in weakTable[@((uintptr_t)self)]) {
        // 根据指针变量地址，将指针变量置为 nil
        // 这里就是 w1 置 nil
        uintptr_t **ptrPtr = (uintptr_t **)[ptrPtrNumber unsignedLongValue];
        *ptrPtr = nil;
    }
    // 移除和此对象相关的数据
    [weakTable removeObjectForKey:@((uintptr_t)self)];
}
@end
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        weakTable = @{}.mutableCopy;
        __unsafe_unretained NSObject *w1;
        @autoreleasepool {
            NSObject *obj = [A new];
            uintptr_t objAddr = (uintptr_t)obj;

            w1 = obj;
            // 将对象地址和需要自动置 nil 的指针变量的地址保存至 map 中
            // 使用可变数组方便处理多个需要置 nil 的变量指向 obj
            weakTable[@(objAddr)] = @[@((uintptr_t)&amp;w1)].mutableCopy;
            // 即将走出 w1 所在作用域，将 w1 的地址从 map 中清除
            [weakTable[@((uintptr_t)w1)] removeObject:@((uintptr_t)&amp;w1)];
        }
        NSLog(@&quot;%@&quot;, w1);
    }
    return 0;
}

</code></pre>
<p>系统的 <code>weak</code> 实现总结如下：</p>
<blockquote>
<p>设置 <code>__weak</code> 修饰的变量时， runtime 会生成对应的 <code>entry</code> 结构放入 <code>weak hash table</code> 中，以赋值对象地址生成的 <code>hash</code> 值为 <code>key</code> ，以包装 <code>__weak</code> 修饰的指针变量地址的 <code>entry</code> 为 <code>value</code> ，当赋值对象释放时， runtime 会在目标对象的 <code>dealloc</code> 处理过程中，以对象地址（ <code>self</code> ）为 <code>key</code> 去 <code>weak hash table</code> 查找 <code>entry</code> ，置空 <code>entry</code> 指向的的所有对象指针。
实际上 <code>entry</code> 使用数组保存指针变量地址，当地址数量不大于 4 时，这个数组就是个普通的内置数组，在地址数量大于 4 时，这个数组就会扩充成一个 <code>hash table</code> 。
系统会提供一个 <code>SideTable</code> 来关联对象引用和弱引用表，对于一个对象来说这个结构实例是唯一的。一般来说，objc 2.0 的对象引用计数都会优先保存在 <code>isa</code> 的 <code>extra_rc</code> 位段中，只有超出了存储的限制才会将超出部分保存到对应的 <code>SideTable</code> 中， <code>isa</code> 使用 <code>has_sidetable_rc</code> 标记是否超出限制。
系统的实现需要针对 <code>TaggedPointer</code> 进行特殊处理。
<code>weak_entry_t</code> 使用 <code>union</code> 来进行记录，在 <code>wea</code> 指针数量小于 4 个时可以快速访问。</p>
</blockquote>
<p>文章不算很长，但是把创建和销毁流程讲得非常清晰。主要重点在 <code>weak_entry_t</code> 的处理， <code>hash</code> 的计算。</p>
<h2 id="weak-弱引用的实现方式"><a class="header" href="#weak-弱引用的实现方式">weak 弱引用的实现方式</a></h2>
<p><a href="https://www.desgard.com/objective-c/2016/09/10/weak.html">weak 弱引用的实现方式</a></p>
<p>整体流程说得比较清晰，代码注释和解释也比较详细</p>
<p><img src="programming-languages/Objective-C/media/16295391694403.jpg" alt="" /></p>
<h2 id="引用计数与-weak"><a class="header" href="#引用计数与-weak">引用计数与 weak</a></h2>
<p><a href="https://wenghengcong.com/posts/7162dd05/">内存管理（四）引用计数与weak</a></p>
<p><img src="programming-languages/Objective-C/media/16295391908761.jpg" alt="" /></p>
<p><img src="programming-languages/Objective-C/media/16295392026961.jpg" alt="" /></p>
<h2 id="应用-1"><a class="header" href="#应用-1">应用</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/27832890">iOS weak 关键字漫谈</a></p>
<p><code>weak singleton</code> ，当所有持有单例的对象都释放后，单例也会被释放掉，减少内存浪费：</p>
<pre><code class="language-objectivec">- (void)setContext:(CDDContext*)object {
    id __weak weakObject = object;
    id (^block)() = ^{ return weakObject; };
    objc_setAssociatedObject(self, @selector(context), block, OBJC_ASSOCIATION_COPY);
}

- (CDDContext*)context {
    id (^block)() = objc_getAssociatedObject(self, @selector(context));
    id curContext = (block ? block() : nil);
    return curContext;
}
</code></pre>
<p><code>weak associated object</code> ，<code>associated object</code> 本身并不支持添加具备 <code>weak</code> 特性的 <code>property</code> ，但我们可以通过一个小技巧来完成：</p>
<pre><code class="language-objectivec">- (void)setContext:(CDDContext*)object {
    id __weak weakObject = object;
    id (^block)() = ^{ return weakObject; };
    objc_setAssociatedObject(self, @selector(context), block, OBJC_ASSOCIATION_COPY);
}

- (CDDContext*)context {
    id (^block)() = objc_getAssociatedObject(self, @selector(context));
    id curContext = (block ? block() : nil);
    return curContext;
}
</code></pre>
<p>文章最后一段话写得很好：</p>
<blockquote>
<p>编程语言一直处于进化当中，语言的设计者会站在宏观的角度，结合行业的需要，添加更多的方便特性，如果只是记住官方文档里的几个应用场景，而不去思考背后的设计思路，则很难写出有想象力的代码。</p>
</blockquote>
<h2 id="简易版实现"><a class="header" href="#简易版实现">简易版实现</a></h2>
<p><a href="http://samwei12.com/2016/03/09/Objective-C/%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9Fruntime%E4%B8%ADweak%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F/">如何实现ARC中weak功能？</a></p>
<p><code>weak</code> 的简易版实现。借用 <code>block</code> 和 <code>unsafe_unretained</code> 实现 <code>weak</code> ，在对象 <code>dealloc</code> 时调用 <code>block</code> ，而 <code>block</code> 会将 <code>unsafe_unretained</code> 指针指向 <code>nil</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object"><a class="header" href="#object">Object</a></h1>
<h2 id="objective-c-中的对象"><a class="header" href="#objective-c-中的对象">Objective-C 中的对象</a></h2>
<p><a href="https://kingcos.me//posts/2019/objects_in_obj-c/">Obj-C 中的对象</a></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae81bfb2-aecc-49ba-97d3-44117f694791/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae81bfb2-aecc-49ba-97d3-44117f694791/Untitled.png" /></p>
<p><code>NSObject</code> 定了 <code>isa</code> 指针，用于指向 <code>Class</code> ，而 <code>Class</code> 本质上则是指向 <code>objc_class</code> 结构体的指针：</p>
<pre><code class="language-objectivec">// NSObject.h

@interface NSObject &lt;NSObject&gt; {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;
    Class isa  OBJC_ISA_AVAILABILITY;
#pragma clang diagnostic pop
}
</code></pre>
<p>而 <code>Class</code> 的本质则是指向 <code>objc_class</code> 结构体的指针，存放了 <code>isa</code> 、 <code>superclass</code> 、方法缓存等。</p>
<pre><code class="language-c">typedef struct objc_class *Class;

// objc-runtime-new.h
struct objc_class : objc_object {
    // Class ISA;
    // 父类指针
    Class superclass;
    // 方法缓存
    cache_t cache;             // formerly cache pointer and vtable
    // 可读可写表（class_rw_t）等
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags

    // ...
};

// objc-private.h
struct objc_object {
private:
    // isa 指针
    isa_t isa;

// ...
}

struct class_data_bits_t {
    // Values are the FAST_ flags above.
    uintptr_t bits;

    class_rw_t* data() {
        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);
    }

    // ...
}
</code></pre>
<p><code>bits</code> 标志位作用：</p>
<ul>
<li>0 - 1 ， <code>FAST_IS_SWIFT_LEGACY</code> ，是否来自 ABI 预稳定版本的 Swift ；</li>
<li>1 - 2 ， <code>FAST_IS_SWIFT_STABLE</code> ，是否来自 ABI 稳定版本的 Swift ；</li>
<li>2 - 3 ， <code>FAST_HAS_DEFAULT_RR</code> ，类或父类含有默认的持有或引用；</li>
<li>3 - 47 ， <code>FAST_DATA_MASK</code> ，指向 <code>class_rw_t</code> 结构体的指针；</li>
<li>47 - 63 ，字节对齐，填 0 。</li>
</ul>
<p><code>class_rw_t</code> 是可读可写， Read-Write ，在运行时会进行调整，而 <code>class_ro_t</code> 是只读的，在编译期已经确定，无法调整。</p>
<pre><code class="language-c">struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    // 只读表的指针（const：不可修改指针指向内存空间中的数据）
    const class_ro_t *ro;

    // 方法、属性、协议信息，可用于运行时动态添加
    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    // ...
};
</code></pre>
<p><code>class_ro_t</code> 在编译时会被动态替换为 <code>class_rw_t</code> ，而 <code>class_rw_t</code> 则会通过指针指向 <code>class_ro_t</code> ：</p>
<pre><code class="language-c">struct class_ro_t {
    // 标志位
    uint32_t flags;
    uint32_t instanceStart;
    // 实例大小
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;

    // 类名
    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    // 成员变量
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
</code></pre>
<p>从上面的 <code>class_rw_t</code> 和 <code>class_ro_t</code> 可以看出为什么 Category 不支持添加变量，因为 Category 相关方法和属性是添加到 <code>class_rw_t</code> 中的，而 <code>class_ro_t</code> 表示的示例大小和属性在编译时已经确定了，不支持在运行时进行修改。</p>
<p>基类：</p>
<p><img src="programming-languages/Objective-C/media/16295434389166.jpg" alt="" /></p>
<h2 id="isa-指针"><a class="header" href="#isa-指针">isa 指针</a></h2>
<p><a href="https://kingcos.me//posts/2019/isa_in_objc/">Obj-C 中的 isa 指针</a></p>
<p><img src="programming-languages/Objective-C/media/16295434244296.jpg" alt="" /></p>
<p>实例对象中的 <code>isa</code> 指向类对象，类对象中的 <code>isa</code> 指向元类对象，元类对象中的 <code>isa</code> 指向根元类对象（包括根元类对象也指向自己）。 <code>isa_t</code> 通过 <code>union</code> 来共享内存占用：</p>
<pre><code class="language-c">struct objc_object {
private:
    isa_t isa;

// ...
}

union isa_t {
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;
#if defined(ISA_BITFIELD)
    struct {
        ISA_BITFIELD;  // defined in isa.h
    };
#endif
};

// isa.h
// ARM 64
# if __arm64__
#   define ISA_MASK        0x0000000ffffffff8ULL
#   define ISA_MAGIC_MASK  0x000003f000000001ULL
#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
#   define ISA_BITFIELD                                                      \
      uintptr_t nonpointer        : 1;                                       \
      uintptr_t has_assoc         : 1;                                       \
      uintptr_t has_cxx_dtor      : 1;                                       \
      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \
      uintptr_t magic             : 6;                                       \
      uintptr_t weakly_referenced : 1;                                       \
      uintptr_t deallocating      : 1;                                       \
      uintptr_t has_sidetable_rc  : 1;                                       \
      uintptr_t extra_rc          : 19
#   define RC_ONE   (1ULL&lt;&lt;45)
#   define RC_HALF  (1ULL&lt;&lt;18)

// _uintptr_t.h
#ifndef _UINTPTR_T
#define _UINTPTR_T
typedef unsigned long           uintptr_t;
#endif /* _UINTPTR_T */
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-counting"><a class="header" href="#reference-counting">Reference Counting</a></h1>
<h2 id="说明-1"><a class="header" href="#说明-1">说明</a></h2>
<p><a href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html">Clang 13 documentation</a></p>
<p>LLVM 的关于 ARC 的说明，非常长。</p>
<h2 id="引用计数原理"><a class="header" href="#引用计数原理">引用计数原理</a></h2>
<p><a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/">Objective-C 引用计数原理</a></p>
<p>引用计数如何存储：</p>
<ol>
<li>如果是 Tagged Pointer ，会直接使用其指针值作为引用计数返回；</li>
<li>如果是 64位和 Objective-C 2.0 ，就会使用 <code>isa</code> 的部分空间来存储引用计数；</li>
<li>如果 <code>isa</code> 部分空间不够存储引用计数，或者不是 64位和 Objective-C 2.0 ，就会使用散列表和 <code>SideTable</code> 来存储。</li>
</ol>
<p><a href="https://www.notion.so/b27762eae5664cc0ad46b6db96bed8b8">isa 指针中变量对应的含义</a></p>
<p>获取引用计数：</p>
<pre><code class="language-objectivec">inline uintptr_t 
objc_object::rootRetainCount()
{
    assert(!UseGC);
		// 1. 如果是 Tagged Pointer ，则直接返回指针地址
    if (isTaggedPointer()) return (uintptr_t)this;

    sidetable_lock();
    isa_t bits = LoadExclusive(&amp;isa.bits);
    if (bits.indexed) {
        // 2. 如果有经过优化，则 1 + bits.extra_rc ；
        uintptr_t rc = 1 + bits.extra_rc;
        // 3. 如果有使用 SideTable ，则加上 SideTable 的计数；
        if (bits.has_sidetable_rc) {
            rc += sidetable_getExtraRC_nolock();
        }
        sidetable_unlock();
        return rc;
    }

    sidetable_unlock();
    return sidetable_retainCount();
}
</code></pre>
<p>而 <code>sidetable_retainCount()</code> 则负责从 <code>SideTable</code> 中获取引用计数：</p>
<pre><code class="language-objectivec">uintptr_t
objc_object::sidetable_retainCount()
{
    // 1. 根据指针地址获取对应的 SideTable
    SideTable *table = SideTable::tableForPointer(this);

    size_t refcnt_result = 1;
    
    spinlock_lock(&amp;table-&gt;slock);
    // 2. 获取对象对应的 RefcountMap ；
    RefcountMap::iterator it = table-&gt;refcnts.find(this);
    if (it != table-&gt;refcnts.end()) {
        // 右移二位， SIDE_TABLE_RC_PINNED 可用于判断是否溢出。
        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;
    }
    spinlock_unlock(&amp;table-&gt;slock);
    return refcnt_result;
}
</code></pre>
<p>如官方文档所说的，不要使用 <code>retainCount</code> 方法，它不能真实表达对象所对应的引用计数，以及 Clang 一些优化也会对其造成影响。</p>
<p><a href="https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571952-retaincount">Apple Developer Documentation</a></p>
<p>修改引用计数：</p>
<ol>
<li><code>retain</code> 和 <code>release</code> ；</li>
<li><code>alloc</code> ， <code>new</code> ， <code>copy</code> 和 <code>mutableCopy</code> ；</li>
<li><code>autorelease</code> 。</li>
</ol>
<h2 id="黑箱中的-retain-和-release"><a class="header" href="#黑箱中的-retain-和-release">黑箱中的 <code>retain</code> 和 <code>release</code></a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E9%BB%91%E7%AE%B1%E4%B8%AD%E7%9A%84%20retain%20%E5%92%8C%20release.md">黑箱中的 retain 和 release</a></p>
<h3 id="retain"><a class="header" href="#retain"><code>retain</code></a></h3>
<p>原文把 <code>rootRetain</code> 方法拆散了，方便解析，下面是 <code>rootRetain</code> 的全部实现，易于查看整个流程：</p>
<pre><code class="language-cpp">id 
objc_object::rootRetain(bool tryRetain, bool handleOverflow)
{
    if (isTaggedPointer()) return (id)this;

    bool sideTableLocked = false;
    bool transcribeToSideTable = false;

    isa_t oldisa;
    isa_t newisa;

    do {
        transcribeToSideTable = false;
        // 加载 isa 的值
        oldisa = LoadExclusive(&amp;isa.bits);
        newisa = oldisa;
        // 如果不支持 nonpointer ，即不用 isa 本身来存储引用计数，则直接走 SideTable 流程
        if (slowpath(!newisa.nonpointer)) {
            ClearExclusive(&amp;isa.bits);
            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();
            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;
            else return sidetable_retain();
        }
        // 如果 isa 在 dealloc 流程中，则直接返回 nil
        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) {
            ClearExclusive(&amp;isa.bits);
            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();
            return nil;
        }
				// 
        uintptr_t carry;
        // 将 isa 的值加 1
        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  
        // 引用计数超出 extra_rc 限制，改用 SideTable
        if (slowpath(carry)) {
            // handleOverflow 为 false 
            if (!handleOverflow) {
                ClearExclusive(&amp;isa.bits);
                // handleOverflow 改为 true ，从走 retain
                return rootRetain_overflow(tryRetain);
            }
            // 把 isa 的 extra_rc 恢复为一半，和做好准备把另外一半拷贝到 SideTable
            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();
            sideTableLocked = true;
            transcribeToSideTable = true;
            // 把 extra_rc 恢复为一半
            newisa.extra_rc = RC_HALF;
            newisa.has_sidetable_rc = true;
        }
    // StoreExclusive 更新 isa 的值
    } while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));
    // 如果说 isa 有溢出， 把一半的引用计数拷贝到 SideTable
    if (slowpath(transcribeToSideTable)) {
        sidetable_addExtraRC_nolock(RC_HALF);
    }

    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();
    return (id)this;
}
</code></pre>
<pre><code class="language-cpp">bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc) {
    SideTable&amp; table = SideTables()[this];

    size_t&amp; refcntStorage = table.refcnts[this];
    size_t oldRefcnt = refcntStorage;
    // 溢出，直接返回 true
    if (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) return true;

    uintptr_t carry;
    size_t newRefcnt = 
        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry);
    if (carry) {
        // 如果有溢出，则将 refcntStorage 设为 SIDE_TABLE_RC_PINNED
        refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);
        return true;
    } else {
        // 没有溢出，新值赋给 refcntStorage
        refcntStorage = newRefcnt;
        return false;
    }
}
</code></pre>
<p>可以看到 <code>retain</code> 时会动态结合 <code>isa</code> 的 <code>extra_rc</code> 和 <code>SideTable</code> 来存储引用计数：</p>
<ol>
<li><code>extra_rc</code> 不需要查找，速度会更快，所以优先使用 <code>extra_rc</code> 管理引用计数；</li>
<li>如果 <code>extra_rc</code> 溢出，则把 <code>extra_rc</code> 的一半拷贝到 <code>SideTable</code> 中， <code>SideTable</code> 并没有直接参与引用计数管理；</li>
<li>如果引用计数为 1 ， <code>extra_rc</code> 为 0 ，保存的是额外的引用计数。</li>
</ol>
<h2 id="release"><a class="header" href="#release"><code>release</code></a></h2>
<pre><code class="language-cpp">bool 
objc_object::rootRelease(bool performDealloc, bool handleUnderflow)
{
    if (isTaggedPointer()) return false;

    bool sideTableLocked = false;

    isa_t oldisa;
    isa_t newisa;

 retry:
    do {
        oldisa = LoadExclusive(&amp;isa.bits);
        newisa = oldisa;
        // 如果不支持 nonpointer ，即不用 isa 本身来存储引用计数，则直接走 SideTable 流程
        if (slowpath(!newisa.nonpointer)) {
            ClearExclusive(&amp;isa.bits);
            if (sideTableLocked) sidetable_unlock();
            return sidetable_release(performDealloc);
        }
        uintptr_t carry;
	      // extra_rc 减 1
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);
        // 如果不够，则走 SideTable 流程
        if (slowpath(carry)) {
            goto underflow;
        }
        // 调用 StoreReleaseExclusive 方法保存新的引用计数
    } while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, 
                                             oldisa.bits, newisa.bits)));

    if (slowpath(sideTableLocked)) sidetable_unlock();
    return false;

 underflow:
    newisa = oldisa;
    // 判断是否有使用 SideTable
    if (slowpath(newisa.has_sidetable_rc)) {
        // 将 handleUnderflow 设为 true ，递归调用
        if (!handleUnderflow) {
            ClearExclusive(&amp;isa.bits);
            return rootRelease_underflow(performDealloc);
        }
        if (!sideTableLocked) {
            ClearExclusive(&amp;isa.bits);
            sidetable_lock();
            sideTableLocked = true;
            goto retry;
        }
        // 从 SideTable 中获取 extra_rc 最大值的一半，即 RC_HALF
        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);
        if (borrowed &gt; 0) {
            // 将一半引用计数放到 extra_rc 中
            newisa.extra_rc = borrowed - 1;  
            bool stored = StoreReleaseExclusive(&amp;isa.bits, 
                                                oldisa.bits, newisa.bits);
            if (!stored) {
                // 如果存放到 extra_rc 中失败，重新加载 isa 和尝试存放
                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);
                isa_t newisa2 = oldisa2;
                if (newisa2.nonpointer) {
                    uintptr_t overflow;
                    newisa2.bits = 
                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);
                    if (!overflow) {
                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, 
                                                       newisa2.bits);
                    }
                }
            }
            // 如果还是失败，则把引用计数放回 SideTable
            if (!stored) {
                sidetable_addExtraRC_nolock(borrowed);
                goto retry;
            }
            sidetable_unlock();
            return false;
        }
        else {
			  // SideTable 为空，执行 dealloc ，不需要执行任何处理
        }
    }
    if (slowpath(newisa.deallocating)) {
		    // 对象正在释放
        ClearExclusive(&amp;isa.bits);
        if (sideTableLocked) sidetable_unlock();
        return overrelease_error();
    }
    // 设置 deallocating 标志位
    newisa.deallocating = true;
    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;

    if (slowpath(sideTableLocked)) sidetable_unlock();
    __sync_synchronize();
    if (performDealloc) {
        // 通过 objc_msgSend 直接执行 dealloc
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
    }
    return true;
}
</code></pre>
<p><code>release</code> 的处理流程和 <code>retain</code> 类似，多了一个 <code>dealloc</code> 的执行流程。</p>
<h2 id="引用计数与-weak-1"><a class="header" href="#引用计数与-weak-1">引用计数与 <code>weak</code></a></h2>
<p><a href="https://wenghengcong.com/posts/7162dd05/">内存管理（四）引用计数与weak</a></p>
<p>源码解析在上面已经有提及，所以这里贴上这篇的文章里的图就好了。</p>
<p><img src="programming-languages/Objective-C/media/16312400607405.jpg" alt="" />
<img src="programming-languages/Objective-C/media/16312401885967.jpg" alt="" />
<img src="programming-languages/Objective-C/media/16312402028925.jpg" alt="" />
<img src="programming-languages/Objective-C/media/16312402241320.jpg" alt="" />
<img src="programming-languages/Objective-C/media/16312402401032.jpg" alt="" />
<img src="programming-languages/Objective-C/media/16312402565861.jpg" alt="" />
<img src="programming-languages/Objective-C/media/16312402651997.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c-2"><a class="header" href="#objective-c-2">Objective-C</a></h1>
<h2 id="runtime-2"><a class="header" href="#runtime-2">Runtime</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Runtime 官方文档</a></p>
<ul>
<li><a href="programming-languages/Objective-C/./associated-objects.html">Associated Objects</a></li>
<li><a href="programming-languages/Objective-C/./initialize.html">initialize</a></li>
<li><a href="programming-languages/Objective-C/./load.html">load</a></li>
<li><a href="programming-languages/Objective-C/./Block.html">Block</a></li>
<li><a href="programming-languages/Objective-C/./Category.html">Category</a></li>
<li><a href="programming-languages/Objective-C/./Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li>
<li><a href="programming-languages/Objective-C/./KVO.html">KVO</a></li>
<li><a href="programming-languages/Objective-C/./KVC.html">KVC</a></li>
<li><a href="programming-languages/Objective-C/./AutoreleasePool.html">AutoreleasePool</a></li>
<li><a href="programming-languages/Objective-C/./dealloc.html">dealloc</a></li>
<li><a href="programming-languages/Objective-C/./Tagged-Pointer.html">Tagged Pointer</a></li>
<li><a href="programming-languages/Objective-C/./weak.html">weak</a></li>
<li><a href="programming-languages/Objective-C/./Object.html">Object</a></li>
</ul>
<h2 id="tips-2"><a class="header" href="#tips-2">Tips</a></h2>
<ul>
<li><a href="programming-languages/Objective-C/./getting-subclasses-of-objective-c-class.html">如何获取某个类的全部子类</a></li>
<li><a href="programming-languages/Objective-C/./objective-c-class-properties.html">Objective-C 类属性</a></li>
</ul>
<h2 id="books-2"><a class="header" href="#books-2">Books</a></h2>
<ul>
<li><a href="https://github.com/oa414/objc-zen-book-cn">禅与 Objective-C 编程艺术</a></li>
<li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0</a></li>
<li><a href="https://book.douban.com/subject/24720270/">Objective-C高级编程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何获取某个类的全部子类"><a class="header" href="#如何获取某个类的全部子类">如何获取某个类的全部子类</a></h1>
<p><a href="https://www.cocoawithlove.com/2010/01/getting-subclasses-of-objective-c-class.html">Getting the subclasses of an Objective-C class</a></p>
<p>获取某个 Objective-C 类的全部子类看起来是个相当简单的任务。虽然 Objective-C runtime 提供了高度的反射和内省，或许应该有个 <code>class_getSubclasses(Class parentClass)</code>  方法用于获取全部子类，但是很遗憾，没有。</p>
<p>Objective-C runtime 没有提供这个方法可能有以下几个原因：</p>
<ul>
<li>类可以动态生成和加载；</li>
<li>需要考虑线程和锁；</li>
<li><code>class_t</code> 结构体的历史遗留问题；</li>
<li>过早的性能优化，或者说故意引导程序员脱离某些特定的设计。</li>
</ul>
<p>通常情况下不推荐获取子类，除非是说只有这么个解决办法或者只在调试中使用，否则更推荐使用其它方法，比如说子类主动注册，</p>
<p><a href="https://www.cocoawithlove.com/2009/07/simple-extensible-http-server-in-cocoa.html">A simple, extensible HTTP server in Cocoa</a></p>
<pre><code class="language-objectivec">+ (void)load
{
    [HTTPResponseHandler registerHandler:self];
}
</code></pre>
<p>父类会在注册的子类中查找对应的 handler 来处理请求。</p>
<p>但是我们在调试时可以通过获取所有 <code>HTTPResponseHandler</code> 的子类来检查是否已经注册。</p>
<p>看下 <code>class</code> 在 Objective-C 中的定义：</p>
<pre><code class="language-objectivec">struct objc_class {
    Class isa;
    Class super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
    struct objc_method_list **methodLists;
    struct objc_cache *cache;
    struct objc_protocol_list *protocols;
};
</code></pre>
<p><code>objc_class</code> 包含指向父类的指针，但是没有包含指向所有子类的指针。如果想通过公开 API 来获取，那么只能获取所有类，然后判断它是否为某个类的子类。这是个非常笨拙的方法，它会遍历 Foundation ， CocoaFramework 和当前项目添加的类。虽然查询这些类只需要一两毫秒，但是如果在循环或者其它频繁调用的操作中进行，这里的耗时就显得非常大，所以可以考虑将结果缓存起来。获取所有类的操作如下：</p>
<pre><code class="language-objectivec">// 获取所有类的数量
int numClasses = objc_getClassList(NULL, 0);
Class *classes = NULL;

// 分配存储所有类的空间
classes = malloc(sizeof(Class) * numClasses);
// 将类信息存到 classes 中
numClasses = objc_getClassList(classes, numClasses);

// do something with classes

free(classes);
</code></pre>
<p>那么如何判断是否为某个类的子类呢？一个比较直觉的方法如下：</p>
<pre><code class="language-objectivec">NSMutableArray *result = [NSMutableArray array];
for (NSInteger i = 0; i &lt; numClasses; i++)
{
    if ([classes[i] isSubclassOfClass:parentClass])
    {
        [result addObject:classes[i]];
    }
}
</code></pre>
<p>但是并不能这样操作， <code>isSubclassOfClass:</code> 是个 <code>NSObject</code> 方法，但是不是所有类都继承自 <code>NSObject</code> ，比如说 <code>_NSZombie_</code> 和 <code>NSProxy</code> 。所以只能通过 runtime 的方法来获取，使用 <code>class_getSuperclass()</code> 来查找子类的父类，然后进行比较：</p>
<pre><code class="language-objectivec">NSArray *ClassGetSubclasses(Class parentClass)
{
    int numClasses = objc_getClassList(NULL, 0);
    Class *classes = NULL;

    classes = malloc(sizeof(Class) * numClasses);
    numClasses = objc_getClassList(classes, numClasses);
    
    NSMutableArray *result = [NSMutableArray array];
    for (NSInteger i = 0; i &lt; numClasses; i++)
    {
        Class superClass = classes[i];
        do
        {
            superClass = class_getSuperclass(superClass);
        } while(superClass &amp;&amp; superClass != parentClass);
        
        if (superClass == nil)
        {
            continue;
        }
        
        [result addObject:classes[i]];
    }

    free(classes);
    
    return result;
}
</code></pre>
<p>作者又提供了另外一种更快更 hack 的方法。在 Objective-C runtime 2.0 版本中， <code>class</code> 包含了一种直接链接至子类的方式。 <code>class_t</code> 结构如下：</p>
<pre><code class="language-objectivec">typedef struct class_t {
    struct class_t *isa;
    struct class_t *superclass;
    Cache cache;
    IMP *vtable;
    class_rw_t *data;
} class_t;
</code></pre>
<p>再看看 <code>class_rw_t</code> 的结构：</p>
<pre><code class="language-objectivec">typedef struct class_rw_t {
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;
    
    struct method_list_t **methods;
    struct chained_property_list *properties;
    struct protocol_list_t ** protocols;

    struct class_t *firstSubclass;
    struct class_t *nextSiblingClass;
} class_rw_t;
</code></pre>
<p>这意味着我们可以通过遍历 <code>firstSubclass</code> 和 <code>nextSiblingClass</code> 来获取所有子类，不需要通过 runtime 来遍历所有类。深度优选遍历：</p>
<pre><code class="language-objectivec">typedef void *Cache;
#import &quot;objc-runtime-new.h&quot;

void AddSubclassesToArray(Class parentClass, NSMutableArray *subclasses)
{
    struct class_t *internalRep = (struct class_t *)parentClass;
    
    // Traverse depth first
    Class subclass = (Class)internalRep-&gt;data-&gt;firstSubclass;
    while (subclass)
    {
        [subclasses addObject:subclass];
        AddSubclassesToArray(subclass, subclasses);
    
        // Then traverse breadth-wise
        struct class_t *subclassInternalRep = (struct class_t *)subclass;
        subclass = (Class)subclassInternalRep-&gt;data-&gt;nextSiblingClass;
    }
}
</code></pre>
<p>然而这个高效的方法不是线程安全的，根据 </p>
<p><a href="https://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m"></a></p>
<p>的实现，在获取 <code>class_t</code> 的 <code>data</code> 数据时都需要 <code>runtimeLock</code> 来进行加锁，但是 <code>runtimeLock</code> 无法在外部获取。因此所有线程（包括 Cocoa 自动开启的线程）都会造成崩溃。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<ol>
<li>虽然说在新的 runtime 中已经有存储子类的数据，但是没有提供相关的 API 来给外部访问；</li>
<li>不是所有的类都继承自 <code>NSObject</code> ；</li>
<li>如果 Apple 在新版本的 runtime 中提供子类数据的 API ，效率会更高。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c-类属性"><a class="header" href="#objective-c-类属性">Objective-C 类属性</a></h1>
<p><a href="https://useyourloaf.com/blog/objective-c-class-properties/">Objective-C Class Properties</a></p>
<p>虽然说 Swift 出来后 Objective-C 改进都比较少了，基本上都是为了更好地和 Swift 进行交互，但是对于需要编写 Objective-C 的程序员来说依旧是喜闻乐见的。</p>
<p>Xcode 8 release notes ：</p>
<blockquote>
<p>Objective-C now supports class properties, which interoperate with Swift type properties. They are declared as: @property (class) NSString *someStringProperty;. They are never synthesized. (23891898)</p>
</blockquote>
<p>通过 <code>class</code> 声明属性：</p>
<pre><code class="language-objectivec">@interface User : NSObject
@property (class, nonatomic, assign, readonly) NSInteger userCount;
@property (class, nonatomic, copy) NSUUID *identifier;
+ (void)resetIdentifier;
@end
</code></pre>
<p>上述代码声明了两个类属性，可读的 <code>userCount</code> 和可写的 <code>identifier</code> 。由于 Objective-C 不像 Swift 那样支持 <code>class</code> 层级的变量存储，所以需要声明对应的静态变量：</p>
<pre><code class="language-objectivec">@implementation User
static NSUUID *_identifier = nil;
static NSInteger _userCount = 0;
</code></pre>
<p>对应 Objective-C 的 <code>class</code> 属性，Xcode 不会自动生成 <code>setter</code> 和 <code>getter</code> 方法，所以需要手动编译对应的方法。由于 <code>userCount</code> 只是可读的，所以只需要 <code>getter</code> 方法：</p>
<pre><code class="language-objectivec">+ (NSInteger)userCount {
  return _userCount;
}
</code></pre>
<p>而对于 <code>identifier</code> 则需要补充 <code>setter</code> 和 <code>getter</code> 方法，同时需要支持 <code>copy</code> 语义：</p>
<pre><code class="language-objectivec">+ (NSUUID *)identifier {
  if (_identifier == nil) {
    _identifier = [[NSUUID alloc] init];
  }
  return _identifier;
}

+ (void)setIdentifier:(NSUUID *)newIdentifier {
  if (newIdentifier != _identifier) {
    _identifier = [newIdentifier copy];
  }
}
</code></pre>
<p>也可以通过初始化方法来更新 <code>userCount</code> 属性：</p>
<pre><code class="language-objectivec">- (instancetype)init
{
  self = [super init];
  if (self) {
    _userCount += 1;
  }
  return self;
}
</code></pre>
<p><code>resetIdentifier</code> 可用于创建一个新的 <code>identifier</code> ：</p>
<pre><code class="language-objectivec">+ (void)resetIdentifier {
  _identifier = [[NSUUID alloc] init];
}

@end
</code></pre>
<p>可以直接通过类名进行访问：</p>
<pre><code class="language-objectivec">User.userCount;
User.identifier;
for (int i = 0; i &lt; 3; i++) {
    self.user = [[User alloc] init];
    NSLog(@&quot;User count: %ld&quot;,(long)User.userCount);
    NSLog(@&quot;Identifier = %@&quot;,User.identifier);
}

[User resetIdentifier];    
NSLog(@&quot;Identifier = %@&quot;,User.identifier);
</code></pre>
<p>生成对应的 Swift 代码如下：</p>
<pre><code class="language-swift">public class User : NSObject { 
  public class var userCount: Int { get }
  public class var identifier: UUID!   
  public class func resetIdentifier()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="多线程导读"><a class="header" href="#多线程导读">多线程导读</a></h1>
<h2 id="官方文档-2"><a class="header" href="#官方文档-2">官方文档</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html">Introduction</a></p>
<p>中文版本：</p>
<p><a href="http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/">Threading Programming Guide(1)</a></p>
<p><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/">Threading Programming Guide(2)</a></p>
<p><a href="http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/">Threading Programming Guide(3)</a></p>
<h2 id="官方的并行编程指南"><a class="header" href="#官方的并行编程指南">官方的并行编程指南</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html">Concurrency and Application Design</a></p>
<h3 id="远离线程"><a class="header" href="#远离线程">远离线程</a></h3>
<h3 id="为什么要使用并行编程"><a class="header" href="#为什么要使用并行编程">为什么要使用并行编程</a></h3>
<ol>
<li>充分利用计算机的多核；</li>
<li>更好的用户体验。</li>
</ol>
<h3 id="为什么避免使用线程nsthread"><a class="header" href="#为什么避免使用线程nsthread">为什么避免使用线程（<code>NSThread</code>）</a></h3>
<ol>
<li>使用 <code>NSThread</code> 你需要自己管理线程池；</li>
<li>需要根据系统的状态调整线程的数量；</li>
<li>需要保持线程的高效运行，避免互相干扰。</li>
</ol>
<h3 id="dispatch-queues"><a class="header" href="#dispatch-queues">Dispatch Queues</a></h3>
<p>Dispatch Queues 是一种基于 C 的机制，可执行自定义任务，支持串行和并行，任务按照 FIFO 顺序执行。
优点：</p>
<ul>
<li>提供直观简单的接口；</li>
<li>提供自动和全面的线程池管理；</li>
<li>提供了优化后的速度；</li>
<li>更高效率的内存占用（线程栈帧不需要常驻内存）；</li>
<li>不需要与内核交互；</li>
<li>分发到异步队列的任务不会造成队列死锁；</li>
<li>优雅的扩展；</li>
<li>串行队列提供了一个比锁或者其它原始的同步方案更高效的替代品。</li>
</ul>
<h3 id="dispatch-sources"><a class="header" href="#dispatch-sources">Dispatch Sources</a></h3>
<p>Dispatch Sources 是一种基于 C 的机制，用于异步处理特定类型的系统。 Dispatch Source 会包含有关特定类型系统事件的信息，在事件发生时将特定的 block 提交给 Dispatch Queue 。你可以使用 Dispatch Sources 来监听以下几种类型的系统事件：</p>
<ul>
<li>Timer 定时器；</li>
<li>Signal 监听UNIX信号；</li>
<li>Descriptor-related events 监听文件和 Socket 相关操作；</li>
<li>Process-related events 监听进程相关状态；</li>
<li>Mach port events 监听 Mach 相关事件；</li>
<li>Custom events that you trigger 监听自定义事件；</li>
</ul>
<p>Dispatch sources 是 GCD 的一部分。</p>
<h3 id="operation-queues"><a class="header" href="#operation-queues">Operation Queues</a></h3>
<p>Operation Queue 是 Cocoa 提供的，和并行的 Dispatch Queue 是相同概念的东西，具体类型为 <code>NSOperationQueue</code> 类。跟 Dispatch Queue 保持 FIFO 的执行顺序不同， Operation Queue 支持自定义的执行顺序。你可以在定义任务时设置相关的依赖，以此来创造一个复杂的执行顺序图。</p>
<p>Operation Queue 中任务对应的类型为 <code>NSOperation</code> 类。<code>NSOperation</code> 封装了你需要执行的任务和所有相关的数据。 <code>NSOperation</code> 是一个抽象的基类，你可以自定义一些子类来执行自己的任务。系统也提供了一些特定的子类。</p>
<p><code>NSOperation</code> 提供了 KVO 通知，可用于监听任务的进度。Operation Queue 通常会并发执行任务，你可以通过设置依赖来保证它们按照所计划的顺序执行。</p>
<h3 id="asynchronous-design-techniques"><a class="header" href="#asynchronous-design-techniques">Asynchronous Design Techniques</a></h3>
<h3 id="define-your-applications-expected-behavior"><a class="header" href="#define-your-applications-expected-behavior">Define Your Application’s Expected Behavior</a></h3>
<p>当你想要给自己的应用添加并发代码时，你应该先定义好应用的预期行为，以此来验证接入并发编程后的行为是否正确以及测试性能收益。</p>
<p>定义相关任务和数据结构。理清各个任务间的依赖关系。</p>
<h3 id="factor-out-executable-units-of-work"><a class="header" href="#factor-out-executable-units-of-work">Factor Out Executable Units of Work</a></h3>
<p>找出任务的最小执行单元，将其封装进 <code>block</code> 或者 <code>NSOperation</code> ，然后派发到适当的队列中。不用担心任务分得太细而影响性能。队列会帮你处理好这一切，当然了，最好还是通过性能测试来调整任务大小。</p>
<h3 id="identify-the-queues-you-need"><a class="header" href="#identify-the-queues-you-need">Identify the Queues You Need</a></h3>
<p>确定好队列的属性。
当使用 GCD 时，如果需要特定的执行顺序，使用串行队列，如果不需要特定的执行队列，可使用并发队列或者多个队列。
当使用 <code>NSOperation</code> 时，可通过设置各个 <code>NSOperation</code> 之间的依赖来调整它们之间的执行顺序。</p>
<h3 id="tips-for-improving-efficiency"><a class="header" href="#tips-for-improving-efficiency">Tips for Improving Efficiency</a></h3>
<ul>
<li>如果你的应用已经受内存限制，那么现在直接使用计算值可能比从主内存加载缓存的值要快。 计算值直接使用处理器核心的寄存器和缓存，这比主内存快得多。 当然了，还是需要性能测试来确定是否有利于性能优化；</li>
<li>找出串行任务，尽力把它们变得更加并发。 如果由于某个任务依赖某些共享资源而必须串行执行该任务，请考虑更改架构以删除该共享资源。 可以考虑为每个需要共享资源的用户拷贝一份对应的资源，或者完全清除共享资源；</li>
<li>避免使用锁。Dispatch queue 和 Operation Queue 在大多数情况下都不需要使用锁。避免使用锁来保护共享资源，使用串行队列或者设置 NSOperation 间的依赖来确保以正确的顺序执行任务；</li>
<li>尽量使用系统框架。实现功能时优先考虑现有的系统 API 是否可以满足需求。</li>
</ul>
<h2 id="相关分类"><a class="header" href="#相关分类">相关分类</a></h2>
<p><a href="iDev/Multithreading/./NSOperation.html">NSOperation</a> </p>
<p><a href="iDev/Multithreading/./Grand-Central-Dispatch.html">Grand Central Dispatch</a> </p>
<p><a href="iDev/Multithreading/./thread.html">pthread 和 NSThread</a> </p>
<p><a href="iDev/Multithreading/./locks.html">Locks</a></p>
<p><a href="iDev/Multithreading/./RunLoop.html">RunLoop</a> </p>
<h2 id="相关文章"><a class="header" href="#相关文章">相关文章</a></h2>
<h3 id="objc-专题"><a class="header" href="#objc-专题">ObjC 专题</a></h3>
<p><a href="https://objccn.io/issue-2-1/">ObjC 中国 - 并发编程：API 及挑战</a></p>
<p><a href="https://objccn.io/issue-2-3/">ObjC 中国 - 底层并发 API</a></p>
<p><a href="https://objccn.io/issue-2-4/">ObjC 中国 - 线程安全类的设计</a></p>
<p><a href="https://objccn.io/issue-2-5/">ObjC 中国 - 测试并发程序</a></p>
<p><img src="iDev/Multithreading/media/16296020555796.jpg" alt="" /></p>
<h3 id="sindrilin-关于多线程的文章"><a class="header" href="#sindrilin-关于多线程的文章">Sindrilin 关于多线程的文章</a></h3>
<p><a href="http://sindrilin.com/2017/09/09/thread_safe.html">thread_safe</a></p>
<p>如何保证线程安全，从原子性到线程锁（互斥，自旋，信号量），也说到了 <code>barrier</code> 操作。</p>
<p><a href="http://sindrilin.com/2017/09/27/producers_consumers.html">producers_consumers</a></p>
<h3 id="netnewswire-如何处理多线程"><a class="header" href="#netnewswire-如何处理多线程">NetNewsWire 如何处理多线程</a></h3>
<p><a href="https://inessential.com/2021/03/20/how_netnewswire_handles_threading">How NetNewsWire Handles Threading</a></p>
<ul>
<li>大部分代码都在主线程运行；</li>
<li>通知和 <code>callback</code> 也都是在主线程处理；</li>
<li>对于耗时操作，使用纯函数和串行队列，通过 <code>callback</code> 返回处理结果；</li>
<li>数据库的存取也使用串行队列，外部无法获取内部实现，可获取到的数据都是通过 <code>callback</code> 和异步派发到主线程进行；</li>
<li>多使用 <code>assert(Thread.isMainThread)</code> 和 <code>precondition(Thread.isMainThread)</code> 来判断是否为主线程。</li>
</ul>
<p>NetNewsWire 在响应和运行上都非常快速，同时也非常稳定。上述策略的好处是开发者通过查看代码就可以了解当前代码是在哪个线程上运行的，几乎全部代码都是在主线程运行。如果你在处理 RSS 解析，数据库或者其它类似的耗时操作，那么就是在串行队列中进行。即使是接入 Combine ， SwiftUI 和 Concurrency ，也可以继续使用这套策略。虽然线程机制的内部有调整，但是对外提供的逻辑是一致的。</p>
<p>作者认为高级开发者应该尽可能地减少多线程的部分，保持应用简单。因为多线程的代码很难去维护和阅读，虽然你可能创造出一套机制来正确使用多线程，但是团队互相理解代码也是有成本的，即使是独立开发者，你和六个月之后的你也是一个团队。虽然有可能阻塞主线程，但是解决一个主线程阻塞的 BUG 比解决一个奇怪的，不稳定复现的多线程的 BUG 或者崩溃要好多了。</p>
<p>对于主线程的阻塞，可以使用 Time Profiler 来排查，一般有以下三种解决方案：</p>
<ol>
<li>通过数据结构和算法来进行优化；</li>
<li>或许是一些不必要的操作；</li>
<li>最后的解决方案：迁移到后台串行队列中进行。</li>
</ol>
<p>最后的实操建议：</p>
<ul>
<li>明确标注哪些应该在主线中运行，在代码中通过 <code>assert(Thread.isMainThread)</code> 进行判断；</li>
<li>开启 Xcode 的 Main Thread Checker ；</li>
<li>确保你 App 上所有的 <code>Notification</code> 都是在主线程进行，在回调中添加 <code>assert(Thread.isMainThread)</code> 。</li>
</ul>
<p>更激进点可以使用 <code>precondition(Thread.isMainThread)</code> 代替 <code>assert(Thread.isMainThread)</code> ，前者在生产环境下也会崩溃，确保你的线程模型正常运行。</p>
<p>对于 GCD 或者 <code>NSOperation</code> 的 API 的错误调用，改动成本不大，而对于整个 App 的线程模型来说，在工程创建之初就会确定下来，或者怎么高兴怎么来，又或者根据不同的业务分配不同的队列，在发展到一定阶段后再来修改避免不了会有一定的成本。我的观点和作者一致：尽量避免多线程。</p>
<h3 id="swift-专题"><a class="header" href="#swift-专题">Swift 专题</a></h3>
<p><a href="https://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/">Swift 中的并发编程(第一部分：现状）</a></p>
<p>这篇文章介绍了 Swift 未支持协程 ( <code>async/await</code> )前的并发编程模式，很好地总结了 Swift 中目前可用的外部并发框架，包括锁类型， GCD 和操作队列。</p>
<p>Swift 3 中已经去掉了 <code>dispatch_once</code> ， <code>dispatch_once</code> 在 Objective-C 中常用于构建线程安全的单例。在 Swift 中可以通过全局常量来初始化单例，Swift 确保使用原子化的方式来进行初始化：</p>
<pre><code class="language-swift">final class Singleton {

    public static let sharedInstance: Singleton = Singleton()

    private init() { }

    ...
}
</code></pre>
<p>也可以通过串行队列加 token 实现类似 <code>dispatch_once</code> 功能：</p>
<pre><code class="language-swift">import Foundation

public extension DispatchQueue {
    
    private static var onceTokens = [Int]()
    private static var internalQueue = DispatchQueue(label: &quot;dispatchqueue.once&quot;)
    
    public class func once(token: Int, closure: (Void)-&gt;Void) {
        internalQueue.sync {
            if onceTokens.contains(token) {
                return
            }else{
                onceTokens.append(token)
            }
            closure()
        }
    }
}

let t = 1
DispatchQueue.once(token: t) {
    print(&quot;only once!&quot;)
}
DispatchQueue.once(token: t) {
    print(&quot;Two times!?&quot;)
}
DispatchQueue.once(token: t) {
    print(&quot;Three times!!?&quot;)
}
</code></pre>
<p>Swift 3 新增了一个函数，可用于判断任务是否在预期的队列中执行， <code>DispatchPredicate</code> 提供了三个枚举值：</p>
<ul>
<li><code>onQueue</code> ：验证任务是否在指定队列中执行；</li>
<li><code>notOnQueue</code> ：与 <code>onQueue</code> 情况相反；</li>
<li><code>onQueueAsBarrier</code> ：验证当前任务是否作为一个队列的屏障。</li>
</ul>
<pre><code class="language-swift">dispatchPrecondition(condition: .notOnQueue(mainQueue))
dispatchPrecondition(condition: .onQueue(queue))
</code></pre>
<h3 id="重点"><a class="header" href="#重点">重点</a></h3>
<p><a href="https://juejin.im/post/6844904138623418376">iOS探索 多线程面试题分析</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nsoperation"><a class="header" href="#nsoperation">NSOperation</a></h1>
<h2 id="官方文档-3"><a class="header" href="#官方文档-3">官方文档</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1">Operation Queues</a></p>
<p><a href="https://developer.apple.com/documentation/foundation/operation">Operation</a></p>
<p><a href="https://developer.apple.com/documentation/foundation/operationqueue">OperationQueue</a></p>
<p><a href="https://developer.apple.com/documentation/foundation/blockoperation">BlockOperation</a></p>
<p>官方文档写的非常详细， <code>Operation</code> 和 <code>OperationQueue</code> 都写到，强烈推荐。</p>
<ul>
<li><code>Operation</code> 支持异步和同步，可以通过 <code>isAsynchronous</code> 来判断是否异步，如果添加到 <code>OperationQueue</code> 中， <code>OperationQueue</code> 会忽略掉这个属性，且默认为异步，可以通过设置 <code>OperationQueue</code> 的 <code>maxConcurrentOperationCount</code> 为 1 来强制串行。</li>
<li>自定义 <code>Operation</code> 时记得设置相关状态和 <code>KVO</code> 配置，如果 A 操作依赖 B 操作，即使 B 操作取消了， A 操作也会执行，A 操作是否 Ready 是通过 B 操作的 <code>isFinished</code> 来判断的，所以可能需要加入额外的判断，判断 B 操作是否成功执行。</li>
<li><code>Operation</code> 的 <code>start()</code> 和 <code>main()</code> 的区别。</li>
<li>优先级配置： <code>Operation.QueuePriority</code> ， <code>Operation</code> 不是严格按照优先级高低来执行，如果高优先级的 <code>Operation</code> 还没准备好， <code>OperationQueue</code> 就会选择去执行低优先级的 <code>Opeartion</code> 。如果对顺序有严格要求的话还是要通过依赖来进行配置。</li>
<li><code>Operation</code> 执行完毕，它就会调用它的 <code>completionBlock</code> 。</li>
</ul>
<h2 id="ios多线程nsoperationnsoperationqueue详尽总结"><a class="header" href="#ios多线程nsoperationnsoperationqueue详尽总结">iOS多线程：『NSOperation、NSOperationQueue』详尽总结</a></h2>
<p><a href="https://juejin.im/post/5a9e57af6fb9a028df222555">iOS多线程：『NSOperation、NSOperationQueue』详尽总结</a></p>
<p><code>NSOperation</code> 和 <code>NSOperationQueue</code> 的优点：</p>
<ol>
<li>可添加完成时调用的任务，便于在操作完成后执行；</li>
<li>方便管理各操作之间的依赖关系；</li>
<li>设定操作执行的优先级；</li>
<li>支持取消；</li>
<li>支持通过 KVO 观察操作的状态： <code>isExecuteing</code> 、 <code>isFinished</code> 、<code>isCancelled</code> 。</li>
</ol>
<p><code>NSOperation</code> 是一个抽象类，不支持直接使用，需要使用系统提供的子类或者自定义子类：</p>
<ol>
<li>使用子类 <code>NSInvocationOperation</code> ；</li>
<li>使用子类 <code>NSBlockOperation</code> ；</li>
<li>使用自定义子类。</li>
</ol>
<p><code>NSOperationQueue</code> 支持以下两种队列：</p>
<ol>
<li>主队列， <code>NSOperationQueue *queue = [NSOperationQueue mainQueue]</code> ；</li>
<li>自定义队列，<code>NSOperationQueue *queue = [[NSOperationQueue alloc] init]</code> 。</li>
</ol>
<p>进阶：</p>
<ol>
<li>通过 <code>maxConcurrentOperationCount</code> 可以在串行和并发间切换；</li>
<li>通过 <code>-addDependency:</code> 和 <code>- removeDependency:</code> 可以进行依赖关系管理；</li>
<li>通过 <code>queuePriority</code> 进行优先级设置，默认为 <code>NSOperationQueuePriorityNormal</code> ，优先级不能取代依赖关系，执行任务的顺序以依赖关系为优先。</li>
</ol>
<h2 id="nsoperation-1"><a class="header" href="#nsoperation-1">NSOperation</a></h2>
<p><a href="https://nshipster.com/nsoperation/">NSOperation</a></p>
<p>NSHipster 出品的简短介绍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grand-central-dispatch"><a class="header" href="#grand-central-dispatch">Grand Central Dispatch</a></h1>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/documentation/dispatch">Apple Developer Documentation</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">Dispatch Queues</a></p>
<p>源代码：</p>
<p><a href="https://opensource.apple.com/source/libdispatch/">Source Browser</a></p>
<p>Dispatch ， aka Grand Central Dispatch （GCD），还有个中文名叫做大中枢派发，包括语言特性， runtime 库（上面的 lib dispatch ）和系统级别的支持，以便在 macOS ，iOS 等多核设备上编写和执行并发代码。</p>
<h2 id="gcd-详尽总结"><a class="header" href="#gcd-详尽总结">GCD 详尽总结</a></h2>
<p><a href="https://juejin.im/post/5a90de68f265da4e9b592b40">iOS多线程：『GCD』详尽总结</a></p>
<p>GCD 好处：</p>
<ul>
<li>不需要我们手动管理线程的声明周期，GCD 会帮我们进行管理；</li>
<li>充分利用多核 CPU 的性能；</li>
<li>基于 block 的 API ，便于使用。</li>
</ul>
<p><code>sync</code> 和 <code>async</code> 表示是否开启新线程，而 <code>Serial Dispatch Queue</code> 和 <code>Concurrent Dispatch Queue</code> 则表示是否具备开启新线程的能力。</p>
<p>需要注意同步/异步执行 + 并发/串行/主队列的执行情况。</p>
<h2 id="细说gcdgrand-central-dispatch如何用"><a class="header" href="#细说gcdgrand-central-dispatch如何用">细说GCD（Grand Central Dispatch）如何用</a></h2>
<p><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8">ming1016/study</a></p>
<p>GCD 的用法，没涉及到源码解析部分。</p>
<h2 id="lets-build-dispatch_queue"><a class="header" href="#lets-build-dispatch_queue">Let's Build <code>dispatch_queue</code></a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html">mikeash.com: Friday Q&amp;A 2015-09-04: Let's Build dispatch_queue</a></p>
<p>Mikeash 自己实现的一个简易版的 <code>dispatch_queue</code> ，源码：</p>
<p><a href="https://github.com/mikeash/MADispatchQueue">GitHub - mikeash/MADispatchQueue: A spiritual reimplementation of the basics of dispatch_queue, for educational purposes</a></p>
<p>支持以下功能：</p>
<ol>
<li>串行或者并发；</li>
<li>同步和异步派发；</li>
<li>底层使用同一个线程池。</li>
</ol>
<p>与 GCD 提供的 C API 不同，接口层通过 Objective-C 实现。 <code>MADispatchQueue</code> 提供了四个接口：</p>
<pre><code class="language-objectivec">@interface MADispatchQueue : NSObject
// 全局队列， GCD 支持根据不同优先级获取不同的队列， MADispatchQueue 没有实现这个功能 
+ (MADispatchQueue *)globalQueue;

// 初始化方法，通过 serial 来定义是串行还是并发
- (id)initSerial: (BOOL)serial;

// 执行异步 block
- (void)dispatchAsync: (dispatch_block_t)block;

// 执行同步 block
- (void)dispatchSync: (dispatch_block_t)block;

@end
</code></pre>
<p>线程池能力由 <code>MAThreadPool</code> 提供，只提供了一个能力：执行所提交的任务，所以对外只提供了以下接口：</p>
<pre><code class="language-objectivec">@interface MAThreadPool : NSObject

- (void)addBlock: (dispatch_block_t)block;

@end
</code></pre>
<pre><code class="language-objectivec">@implementation MAThreadPool {
    // 使用 NSCondition 来作为锁，可以通过 signal 和 wait 进行通信
    NSCondition *_lock;
    
    // 当前所开启的线程
    NSUInteger _threadCount;
    // 执行任务中的线程
    NSUInteger _activeThreadCount;
    // 最大线程数
    NSUInteger _threadCountLimit;
    // 需要执行的 block
    NSMutableArray *_blocks;
}

- (id)init {
    if((self = [super init])) {
        _lock = [[NSCondition alloc] init];
        _blocks = [[NSMutableArray alloc] init];
        _threadCountLimit = 128;
    }
    return self;
}

- (void)addBlock: (dispatch_block_t)block {
    // 加锁保证线程安全
    [_lock lock];
    // 添加 block 到 blocks 数组中
    [_blocks addObject: block];
    
	  // 判断当前空闲线程是否可以处理完所有待处理的 blocks 
    // 如果说 blocks 数量大于空闲线程数且当前线程数小于最大线程数，则可以开启新线程
    NSUInteger idleThreads = _threadCount - _activeThreadCount;
    if([_blocks count] &gt; idleThreads &amp;&amp; _threadCount &lt; _threadCountLimit) {
        [NSThread detachNewThreadSelector: @selector(workerThreadLoop:) toTarget: self withObject: nil];
        _threadCount++;
    }
    // signal 执行任务
    [_lock signal];
    [_lock unlock];
}

- (void)workerThreadLoop: (id)ignore {
    [_lock lock];
    // 线程保活，实现类似 RunLoop 的流程
    while(1) {
        while([_blocks count] == 0) {
            // wait 等待任务派发
            [_lock wait];
        }
        // 获取第一个任务
        dispatch_block_t block = [_blocks firstObject];
        [_blocks removeObjectAtIndex: 0];
        _activeThreadCount++;
        [_lock unlock];
        
        block();
        
        [_lock lock];
        _activeThreadCount--;
    }
}

@end
</code></pre>
<p><code>MADispatchQueue</code> 的实现：</p>
<pre><code class="language-objectivec">@implementation MADispatchQueue {
    NSLock *_lock;
    NSMutableArray *_pendingBlocks;
    BOOL _serial;
    // 是否在执行任务
    BOOL _serialRunning;
}

static MADispatchQueue *gGlobalQueue;
static MAThreadPool *gThreadPool;

// 借用 initialize 机制初始化 gGlobalQueue 和 gThreadPool 
// 因为 dispatch_once 是 GCD 提供的能力，作者不想通过 GCD API 来实现 GCD 的功能，所以改用通过 initialize 来实现
+ (void)initialize {
    if(self == [MADispatchQueue class]) {
        gGlobalQueue = [[MADispatchQueue alloc] initSerial: NO];
        gThreadPool = [[MAThreadPool alloc] init];
    }
}

+ (MADispatchQueue *)globalQueue {
    return gGlobalQueue;
}

- (id)initSerial: (BOOL)serial {
    if ((self = [super init])) {
        _lock = [[NSLock alloc] init];
        _pendingBlocks = [[NSMutableArray alloc] init];
        _serial = serial;
    }
    return self;
}

// 异步派发
- (void)dispatchAsync: (dispatch_block_t)block {
    [_lock lock];
    [_pendingBlocks addObject: block];
    // 如果是串行，且没有在执行 block
    if(_serial &amp;&amp; !_serialRunning) {
        _serialRunning = YES;
        [self dispatchOneBlock];
    } else if (!_serial) {
        // 并发队列，直接执行 block 即可
        [self dispatchOneBlock];
    }
    // 如果是串行且在执行 block 中，则不需要做任何处理， dispatchOneBlock 执行完后会自动检查是否还需要处理 blocks
    [_lock unlock];
}

// 同步派发，基于 async 进行任务派发，通过 condition 强行同步😂
- (void)dispatchSync: (dispatch_block_t)block {
    NSCondition *condition = [[NSCondition alloc] init];
    __block BOOL done = NO;
    [self dispatchAsync: ^{
        block();
        [condition lock];
        done = YES;
        [condition signal];
        [condition unlock];
    }];
    [condition lock];
    while (!done) {
        [condition wait];
    }
    [condition unlock];
}

// 负责处理 pendingBlocks 的任务
- (void)dispatchOneBlock {
    [gThreadPool addBlock: ^{
				// 加 lock 保证线程安全
        [_lock lock];
        dispatch_block_t block = [_pendingBlocks firstObject];
        [_pendingBlocks removeObjectAtIndex: 0];
        [_lock unlock];
        
        block();
        // 如果是串行，则判断是否还有处理中的 blocks
        if(_serial) {
            [_lock lock];
            if([_pendingBlocks count] &gt; 0) {
                [self dispatchOneBlock];
            } else {
                // 结束任务执行
                _serialRunning = NO;
            }
            [_lock unlock];
        }
    }];
}

@end
</code></pre>
<p>作者的总结：</p>
<p>全局线程池可以通过一个工作队列 （ Queue ）和自动管理线程来实现，使用共享的全局线程池，可以提供基本的调度队列 API ，支持基本的串行/并发和同步/异步调度，虽然说缺少了不少 GCD 的功能，但是可以很好地了解 GCD 的运作方式。</p>
<h2 id="dispatch_once-实现原理"><a class="header" href="#dispatch_once-实现原理">dispatch_once 实现原理</a></h2>
<p><a href="https://mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html">mikeash.com: Friday Q&amp;A 2014-06-06: Secrets of dispatch_once</a></p>
<pre><code class="language-objectivec">static dispatch_once_t predicate;    
dispatch_once(&amp;predicate, ^{
		// some one-time task
});
</code></pre>
<p><code>dispatch_once</code>  只需要提供两个参数：</p>
<ul>
<li><code>predicate</code> ，一个 <code>token</code> ，用于保证执行一次；</li>
<li><code>block</code> ，需要执行的具体操作；</li>
</ul>
<p>在单线程中， 我们使用一个 <code>if</code> 就可以保证方法只执行一次。但是在多线程中，就需要通过 <code>dispatch_once</code> 来保证 <code>block</code> 只执行一次，且其它线程需要等待 <code>dispatch_once</code> 执行完成。自己实现对应的版本并不难，但是 <code>dispatch_once</code> 的速度极快，这点比较难实现。</p>
<p>单线程版本：</p>
<pre><code class="language-objectivec">void SimpleOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		if(!*predicate) {
		    block();
        *predicate = 1;
    }
}
</code></pre>
<p><code>dispatch_once_t</code> 只是一个 <code>long</code> 的 <code>typedef</code> ，初始化为 <code>0</code> ， <code>block</code> 执行完毕后设置为 <code>1</code> 以保证不会多次执行。但是在多线程时，可能会同时进入到 <code>if</code> 条件判断中，导致多次执行。</p>
<p>关于 <code>dispatch_once</code> 的性能部分，有下面三个场景需要考虑清楚：</p>
<ol>
<li>首次调用 <code>dispatch_once</code> 的调用者会直接执行 <code>block</code> ；</li>
<li>在首次调用到 <code>block</code> 完成执行之间调用，需要等待 <code>block</code> 完成；</li>
<li>在 <code>block</code> 完成后调用，无需等待，可以直接继续后续流程；</li>
</ol>
<p>1 和 2 都不是非常重要，1 只会出现一次，而 2 基本上很少出现。</p>
<p>最重要的是第3点，在程序中会有可能出现成千上万次，每次我们都需要保证 <code>dispatch_once</code> 只执行一次。可以使用 <code>SimpleOnce</code> 作为我们性能测试的黄金准则。</p>
<h3 id="locks"><a class="header" href="#locks">Locks</a></h3>
<pre><code class="language-objectivec">void LockedOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

    pthread_mutex_lock(&amp;mutex);
    if(!*predicate) {
		    block();
        *predicate = 1;
    }
    pthread_mutex_unlock(&amp;mutex);
}
</code></pre>
<p>简易版的 <code>Lock</code> 实现，由于 <code>predicate</code> 是一个 <code>long</code> 指针，无法存放 <code>Lock</code> ，所以新建了一个全局 <code>mutex</code> 来保证线程安全，这样会导致不相关的 <code>predicate</code> 也需要互相等待，但是对于试验性的代码来说够用了。</p>
<h3 id="spinlocks"><a class="header" href="#spinlocks">Spinlocks</a></h3>
<pre><code class="language-objectivec">void SpinlockOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		static OSSpinLock lock = OS_SPINLOCK_INIT;

    OSSpinLockLock(&amp;lock);
		if(!*predicate) {
				block();
        *predicate = 1;
		}
    OSSpinLockUnlock(&amp;lock);
}
</code></pre>
<p>Spinlocks 会让线程忙等，而不是休眠，以此来减少唤醒线程的耗时。相比 <code>mutex</code> 版本有相当大的改进，但是比起单线程版本耗时还是较长。</p>
<h3 id="atomic-operations"><a class="header" href="#atomic-operations">Atomic Operations</a></h3>
<pre><code class="language-objectivec">BOOL CompareAndSwap(long *ptr, long testValue, long newValue) {
		if(*ptr == testValue) {
		    *ptr = newValue;
        return YES;
    }
    return NO;
}
</code></pre>
<p>原子操作，提供 CPU 操作，不需要进行加锁操作。 </p>
<p><code>ptr</code> 有三个值：</p>
<ul>
<li>0 表示 <code>block</code> 从未执行</li>
<li>1 表示 <code>block</code> 执行中</li>
<li>2 表示 <code>block</code> 执行中</li>
</ul>
<p>尽早退出，如果 <code>*predicate</code> 为 2 就 <code>return</code> ：</p>
<pre><code class="language-objectivec">void EarlyBailoutAtomicBuiltinsOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		if(*predicate == 2) {
		    __sync_synchronize();
        return;
    }

    volatile dispatch_once_t *volatilePredicate = predicate;

    if(__sync_bool_compare_and_swap(volatilePredicate, 0, 1)) {
		    block();
	      __sync_synchronize();
        *volatilePredicate = 2;
    } else {
        while(*volatilePredicate != 2)
			  ;
        __sync_synchronize();
    }
}
</code></pre>
<p>源码：</p>
<p><a href="https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/src/once.c"></a></p>
<h2 id="dispatch_once-的死锁分析"><a class="header" href="#dispatch_once-的死锁分析"><code>dispatch_once</code> 的死锁分析</a></h2>
<p><a href="http://satanwoo.github.io/2016/04/11/dispatch-once/">滥用单例之dispatch_once死锁</a></p>
<p>延伸阅读：</p>
<p><a href="https://my.oschina.net/moooofly/blog/175019">【整理】__builtin_expect 解惑 - 摩云飞的个人页面 - OSCHINA</a></p>
<p><a href="http://lday.me/2017/11/04/0016_what_is_memory_barriers/">什么是内存屏障(Memory Barriers)</a></p>
<h2 id="gcd-源码分析"><a class="header" href="#gcd-源码分析">GCD 源码分析</a></h2>
<p>结合源码分析用法和原理，非常详尽。</p>
<p><a href="http://cocoa-chen.github.io/2018/03/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/">深入浅出GCD之基础篇 | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_queue/">深入浅出GCD之dispatch_queue | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_semaphore/">深入浅出GCD之dispatch_semaphore | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_queue/">深入浅出GCD之dispatch_queue | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_once/">深入浅出GCD之dispatch_once | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/19/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_source/">深入浅出GCD之dispatch_source | cocoa_chen</a></p>
<h2 id="gcd-注意点"><a class="header" href="#gcd-注意点">GCD 注意点</a></h2>
<p><a href="https://gist.github.com/tclementdev/6af616354912b0347cdf6db159c37057">Making efficient use of the libdispatch (GCD)</a></p>
<ul>
<li>只使用非常少，明确定义的 <code>queues</code> 。 所有的 <code>queues</code> 激活后，就会使用很多线程。 <code>queues</code> 应该根据 App 中特定的环境进行定义：UI ，存储，后台工作等，以此从多线程中获利；</li>
<li>先使用主线程，当你发现性能瓶颈时，找到原因，如果多线程可以优化性能，必须要小心地应用，同时观察系统的压力。重复使用默认的 <code>queues</code> ，如果需要添加多一个 <code>queue</code> 必须要经过测量。在大多数 Apps 中，尽量不要使用超过 3 个或者 4 个 <code>queues</code> ；</li>
<li>Queues that target other (non-global) queues are fine, these are the ones which scale. （这段不太明白）；</li>
<li>不要使用 <code>dispatch_get_global_queue()</code> ，它不能很好地处理优先级，同时会导致线程爆炸。使用自己的特定 <code>queue</code> 是最好的选择；</li>
<li>如果 <code>dispatch</code> 对应的 <code>block</code> 小于 1ms ，使用 <code>dispatch_async()</code> 会造成性能上的浪费，因为 <code>libdispatch</code> 的过载行为，很有可能会创建一个新的线程来执行这个 <code>block</code> 。使用锁来保护共享状态会是一个更好的选择；</li>
<li>一些类/库被更好地设计为复用其调用者的执行上下文，这意味这它们使用传统的锁来保证线程安全。 <code>os_unfair_lock</code> 通常是系统中的最快的锁（优先级更高，更少的上下文切换）；</li>
<li>如果并行运行，那么你的 <code>work item</code> 不应该相互竞争（竞态），否则性能会急剧下降。竞态有多种形式，锁是其中一种，这意味着使用共享资源有可能成为性能瓶颈：IPC/系统服务， <code>malloc(lock)</code> ， 共享内存， I/O ， ...</li>
<li>你不需要为了避免线程爆炸而一直使用同步方法。使用一定数量的 <code>queue</code> 而不是 <code>dispatch_get_global_queue()</code> 会是一个更好的选择；</li>
<li>异步编程的 bug 和复杂度都会增加，同步编程更容易阅读，编写和维护；</li>
<li>串行队列比并行队列优化得更好。只有在你需要性能改善时才使用并行队列，否则有可能是过早优化；</li>
<li>如果你需要在同一个队列中混合异步和同步调用，请使用 <code>dispatch_async</code> 和 <code>wait</code> 而不是 <code>dispatch_sync()</code> 。 <code>dispatch_async</code> 和 <code>wait</code> 结合使用可以减少队列切换；</li>
<li>充分利用3-4个以上的内核不是件容易的事，大多数尝试着么做的人都是在浪费精力来获得微不足道的性能；</li>
<li>测量 App 的真实性能，以此确保 App 通过优化后变得更快，而不是更慢。进行性能测试时应该进行全局的性能测试，而不是局部的性能测试，避免缓存影响和保持线程池活跃；</li>
<li><code>libdispatch</code> 非常有效率但是并不是魔术，资源是有限的。你无法忽略掉你正在使用的底层系统和硬件。不是所有代码可以并行运行。</li>
</ul>
<p>检查你代码所有 <code>dispatch_async()</code> 的调用，看看它们需要执行的任务是否值得切换至不同的上下文来执行。大多数情况下，锁都是更好的选择。</p>
<p>一旦你开始使用定义的队列和复用它们，你有可能在调用 <code>dispatch_sync()</code> 时导致死锁，在队列用于线程安全时经常会出现这种情况，再次声明一下使用锁是一个比较好的解决方案，只有在需要切换至不同的上下文时才使用 <code>dispatch_async()</code> 。</p>
<h3 id="如何取消-gcd-任务"><a class="header" href="#如何取消-gcd-任务">如何取消 GCD 任务</a></h3>
<ul>
<li>如果还未执行的子线程可以用 <code>dispatch_block_cancel</code> 来取消，需要使用 <code>dispatch_block_create</code> 创建 <code>dispatch_block_t</code> 。</li>
</ul>
<pre><code class="language-objectivec">- (void)stopSync{
    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block1 = dispatch_block_create(0, ^{
        NSLog(@&quot;block1 begin&quot;);
        [NSThread sleepForTimeInterval:3];
        NSLog(@&quot;block1 end&quot;);
    });

    dispatch_block_t block2 = dispatch_block_create(0, ^{
        NSLog(@&quot;block2 &quot;);
    });
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    //取消执行block2
    dispatch_block_cancel(block2);
}

</code></pre>
<ul>
<li>对于执行中的任务，可以通过变量判断是否需要提前 <code>return</code> 来取消任务。线程外设置__block变量，配合线程中return结束。</li>
</ul>
<pre><code class="language-objectivec">- (void)stopAsync {
    __block BOOL isFinish =NO;
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        for(long i=0; i&lt;10000; i++) {
            NSLog(@&quot;执行第 %ld 次&quot;,i);
            sleep(1);
            if(isFinish ==YES) {
                NSLog(@&quot;停止&quot;);
                return;
            }
        };
    });
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW,(int64_t)(10 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^{
        NSLog(@&quot;停止任务&quot;);
        isFinish =YES;
    });
}
</code></pre>
<h2 id="gcd-造成卡顿"><a class="header" href="#gcd-造成卡顿">GCD 造成卡顿</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/37463055">iOS App 使用 GCD 导致的卡顿问题</a></p>
<ol>
<li>
<p>iOS 系统本身是一个资源调度和分配系统，CPU，disk IO，VM 等都是稀缺资源，各个资源之间会互相影响，主线程的卡顿看似 CPU 资源出现瓶颈，但也有可能内核忙于调度其他资源，比如当前正在发生大量的磁盘读写，或者大量的内存申请和清理，都会导致下面这个简单的创建线程的内核调用出现卡顿：</p>
<p><code>libsystem_kernel.dylib __workq_kernreturn</code></p>
<p>所以解决办法只能是自己分析各 thread 的 call stack ，根据用户场景分析当前正在消耗的系统资源。后面也确实通过最近提交的代码分析，发现是由于增加了一些非常耗时的磁盘 io 任务（虽然也是放在在子线程），才出现这个看着不怎么沾边的 call stack。revert 之后卡顿警报就消失了。</p>
</li>
<li>
<p>现有的卡顿检测工具都只能在超时的情况下 dump call stack ，但出现超时有可能是任务 A，B，C 共同作用导致的，A 和 B 可能是真正耗时的任务，C 不耗时但碰巧是最后一个，所以被当成元凶，而 A 和 B 却没有出现在上报日志里。我暂时也没有想到特别好的解决办法。很明显， <code>libsystem_kernel.dylib __workq_kernreturn</code> 就是一个不怎么耗时的 C 任务。 </p>
</li>
<li>
<p>在使用 GCD 创建 queue，或者说一个 App 内部使用 GCD 执行子线程任务时，最好有一套 App 所有团队都能遵循的队列使用机制，避免创建过多的 thread ，而出现意料之外的线程资源紧缺，代码无法及时执行的情况。这很难，尤其是在大公司动则上百人的团队里面。</p>
</li>
</ol>
<h2 id="gcd-原理详解"><a class="header" href="#gcd-原理详解">GCD 原理详解</a></h2>
<p><a href="https://github.com/bestswifter/blog/blob/master/articles/objc-gcd.md">objc-gcd</a></p>
<ol>
<li><code>fastpath(x)</code> 和 <code>slowpath(x)</code> 的作用：手动提醒编译器哪种情况比较容易发生；</li>
<li><code>dispatch_queue_t</code> 源码解析，设置线程并发数， <code>target queue</code> 等；</li>
<li><code>dispatch_async</code> ，根据并发数调用不同的函数，主要流程是用链表保存所有提交的 <code>block</code> ，然后在底层线程池中取出或者新建线程，执行最早添加的 <code>block</code> ；</li>
<li><code>dispatch_sync</code> ，使用信号量来保证每次只有一个 <code>block</code> 被执行；</li>
<li><code>dispatch_semaphore</code> 通过 <code>signal</code> 和 <code>wait</code> 来进行信号量管理，；</li>
<li><code>dispatch_group</code> 基于信号量进行处理， value 恢复初始值会调用所有注册的回调， <code>dispatch_group_notify</code> 将所有回调封装成链表，在 <code>dispatch_async</code> 完成时判断 value 是否恢复初始值，如果恢复初始值就调用 <code>dispatch_async</code> 执行所有注册的回调；</li>
<li><code>dispatch_once</code> 通过一个静态变量来标记 <code>block</code> 是否执行中或者已执行，通过信号量来确保只有一个线程能执行 <code>block</code> ，执行完成后会唤醒其它等待的线程；</li>
<li><code>dispatch_barrier_async</code> 改变 <code>block</code> 的 <code>vtable</code> 标记位，会等待前面的 <code>block</code> 执行完后才执行；</li>
<li><code>dispatch_source</code> 可以用来实现定时器，所有的 source 会提交到用户指定的队列，然后提交到 manager 队列中，和 <code>NSTimer</code> 不同，没有依赖 RunLoop 。</li>
</ol>
<h2 id="gcd-总结"><a class="header" href="#gcd-总结">GCD 总结</a></h2>
<p><a href="https://folobe26.github.io/2020/09/18/gcd/">GCD</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pthread-和-nsthread"><a class="header" href="#pthread-和-nsthread"><code>pthread</code> 和 <code>NSThread</code></a></h1>
<h2 id="远离线程-1"><a class="header" href="#远离线程-1">远离线程</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html">Migrating Away from Threads</a></p>
<p>苹果官方推荐使用 <code>GCD</code> 和 <code>NSOperationQueu</code> 来代替线程，好处如下：</p>
<ul>
<li>减少存储线程栈帧的内存占用；</li>
<li>清除创建和配置线程的代码；</li>
<li>清除在线程中管理和安排任务的代码；</li>
<li>简化所需要编写的代码。</li>
</ul>
<h3 id="替换线程"><a class="header" href="#替换线程">替换线程</a></h3>
<p>在 App 中使用线程的方式：</p>
<ul>
<li>执行单次任务的线程。创建一个线程执行一个任务，然后在任务完成后释放它；</li>
<li>工作者线程。创建一个或者多个线程来执行一些特定的任务。定期分配任务给每个线程；</li>
<li>线程池。创建一个包含线程的线程池，为每个线程起一个 <code>RunLoop</code> 。当你需要执行一个任务时，从线程池中提取一个线程来执行。如果没有空闲的线程，就加入到任务队列中，等到有线程可用时执行。</li>
</ul>
<p>替换方案：</p>
<ul>
<li>对于单任务线程，把任务封装进 <code>block</code> 或者 <code>Operation</code> 对象中，然后提交到并发队列；</li>
<li>对于工作者线程，你需要决定使用串行队列还是并发队列。如果你使用工作者线程来同步一些特定任务的执行，那么使用串行队列。如果你使用工作者线程来执行任意一个任务，没有相互依赖，可以使用并发队列；</li>
<li>对于线程池，可以把你的任务封装到 <code>block</code> 或者 <code>Operation</code> 对象，然后把它们分配到指定的并发队列中执行 。</li>
</ul>
<p>对于任务间的共享资源，使用队列仍然有不少好处。它可以提供一种更加可预测的方式来执行你的代码。这意味着可以不通过锁或者其它重量级的装置来同步代码的执行顺序。你可以使用队列来执行相同的任务。</p>
<h2 id="清除基于锁的代码"><a class="header" href="#清除基于锁的代码">清除基于锁的代码</a></h2>
<p>相比于锁，队列更加高效。即是不实在竞争状态下，也需要消耗一定的性能来获取锁。在竞争状态下，无法确定等待锁释放需要多长时间。</p>
<p>结合之前 <code>GCD</code> 部分提到的如何高效使用 <code>GCD</code> ，如果是那种耗时较小的任务，那么直接使用锁是个更好的选择，因为线程的上下文切换也是需要消耗时间的，如果耗时较长的任务，建议使用 <code>GCD</code> 。</p>
<p>使用 <code>dispatch_async</code> 和串行队列可以建立异步的锁，在对应的 <code>block</code> 中执行任务，由于任务先进先出的关系，任务会按照调用的顺序执行，而且不会阻塞调用者的线程。</p>
<p>使用 <code>dispatch_sync</code> 执行同步任务，只有当需要等待任务执行完毕时才调用 <code>dispatch_sync</code> 时才调用。</p>
<h2 id="改进循环代码"><a class="header" href="#改进循环代码">改进循环代码</a></h2>
<p>如果代码中的每次循环对于其它循环来说都是独立的，那么可以考虑使用 <code>dispatch_apply</code> 或者 <code>dispatch_apply_f</code> 。它们会把循环中每次迭代独立提交到队列中。当与并发队列结合时，就可以同时执行多个迭代。必须要保证每次迭代都是可重入的。</p>
<pre><code class="language-objectivec">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
   printf(&quot;%u\n&quot;, i);
});
</code></pre>
<p>当然，也可以通过在一个 <code>dispatch_apply</code> <code>block</code> 里执行多个迭代来提高效率。你需要确定 <code>dispatch_apply</code> 的步长。当原来的迭代数字非常大时，通过设置步长可以减少派发 <code>block</code> 的次数，这意味着需要更多时间来执行 <code>block</code> ，而不是派发 <code>block</code> 。你需要通过性能测试来确定具体的步长。</p>
<h3 id="替换-thread-joins"><a class="header" href="#替换-thread-joins">替换 Thread Joins</a></h3>
<p>Thread Joins 允许你创建一个或多个线程，然后在当前线程中等待其它线程完成任务。如果父线程需要创建多个子线程来完成任务，可以通过这个方法来实现。</p>
<p><code>Dispatch groups</code> 提供了相同意义上的机制，同时还有其它优点。它可以阻塞当前线程以等待子任务完成。可以同时执行多个子任务 。由于使用 <code>Dispatch queues</code> 的关系，效率非常高。</p>
<p>也可以通过 <code>Operation</code> 对象间的依赖关系来实现上面的需求。</p>
<h2 id="pthread-和-nsthread-详尽总结"><a class="header" href="#pthread-和-nsthread-详尽总结"><code>pthread</code> 和 <code>NSThread</code> 详尽总结</a></h2>
<p><a href="https://juejin.im/post/5a66c9b751882573520d8abc">iOS多线程：『pthread、NSThread』详尽总结</a></p>
<p><code>pthread</code> 是通用的多线程 API ，可以在 Unix/Linux/Windows 等平台使用，需要自己管理线程的声明周期，使用比较麻烦，在 iOS 上很少使用。</p>
<p><code>NSThread</code> 是苹果提供的，面向对象的 Objective-C 类，使用起来比  <code>pthread</code> 方便一点，不过也很少使用，大多数情况下只是通过 <code>[NSThread currentThread]</code> 获取一下线程名。而 <code>NSThread</code> 间的通信都是通过 <code>performSelector</code> 进行。</p>
<h2 id="pthread-的源码解析"><a class="header" href="#pthread-的源码解析"><code>pthread</code> 的源码解析</a></h2>
<p><a href="https://kingcos.me/posts/2019/multithreading_techs_in_ios-1/">iOS 多线程技术实践之 pthreads（一）</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="锁"><a class="header" href="#锁">锁</a></h1>
<h2 id="自旋锁"><a class="header" href="#自旋锁">自旋锁</a></h2>
<p>当线程等待自旋锁时不会进入睡眠，自旋锁由于在获取锁时，线程会一直处于忙等状态，有可能会造成任务的优先级反转。</p>
<h3 id="osspinlock"><a class="header" href="#osspinlock">OSSpinLock</a></h3>
<blockquote>
<p>新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p>
</blockquote>
<blockquote>
<p>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。</p>
</blockquote>
<p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a></p>
<h2 id="互斥锁"><a class="header" href="#互斥锁">互斥锁</a></h2>
<p>当等待互斥锁时，线程会进入睡眠，锁释放时就会唤醒线程。互斥锁又分为递归锁和非递归锁：</p>
<ul>
<li>递归锁：可重入，同一个线程在锁释放前可再次获取锁，可以递归调用；</li>
<li>非递归锁：不可重入，必须等锁释放后才能再次获取。</li>
</ul>
<h3 id="pthread_mutex"><a class="header" href="#pthread_mutex">pthread_mutex</a></h3>
<p><code>pthread_mutex</code> 是互斥锁，对性能要求比较高的场景可以使用， API 比较简单：</p>
<pre><code class="language-objectivec">// 导入头文件
#import &lt;pthread.h&gt;
// 全局声明互斥锁
pthread_mutex_t _lock;
// 初始化互斥锁
pthread_mutex_init(&amp;_lock, NULL);
// 加锁
pthread_mutex_lock(&amp;_lock);
// 这里做需要线程安全操作

// 解锁
pthread_mutex_unlock(&amp;_lock);
// 释放锁
pthread_mutex_destroy(&amp;_lock);

</code></pre>
<h3 id="synchronized"><a class="header" href="#synchronized">@synchronized</a></h3>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-02-20-lets-build-synchronized.html">mikeash.com: Friday Q&amp;A 2015-02-20: Let's Build @synchronized</a></p>
<p><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/">关于 @synchronized，这儿比你想知道的还要多</a></p>
<p>性能比较低，因为有容错处理，和使用全局表。</p>
<ol>
<li>不能使用<code>非OC对象</code>作为加锁条件——<code>id2data</code>中接收参数为id类型</li>
<li>多次锁同一个对象会有什么后果吗——会从高速缓存中拿到data，所以只会锁一次对象</li>
<li>都说@synchronized性能低——是因为在底层<code>增删改查</code>消耗了大量性能</li>
<li>加锁对象不能为nil，否则加锁无效，不能保证线程安全</li>
</ol>
<h3 id="nslock"><a class="header" href="#nslock">NSLock</a></h3>
<p><code>NSLock</code> 对 <code>pthread_mutex</code> 进行了一层封装，提供了 <code>Objective-C</code> 层级的 API ：</p>
<pre><code class="language-objectivec">NSLock *lock = [[NSLock alloc] init]
[lock lock];
[lock unlock];
</code></pre>
<p>从 Swift 开源版的 Foundation 中可以看到 NSLock 是基于 <code>pthread_mutex</code> 的封装：</p>
<p><a href="https://github.com/apple/swift-corelibs-foundation/blob/main/Sources/Foundation/NSLock.swift">NSLock.swift</a></p>
<p>删除其它平台的代码后大概实现如下：</p>
<pre><code class="language-swift">open class NSLock: NSObject, NSLocking {
		public override init() {
        pthread_mutex_init(mutex, nil)
        pthread_cond_init(timeoutCond, nil)
        pthread_mutex_init(timeoutMutex, nil)
    }

		open func lock() {
        pthread_mutex_lock(mutex)
    }

    open func unlock() {
        pthread_mutex_unlock(mutex)
        // Wakeup any threads waiting in lock(before:)
        pthread_mutex_lock(timeoutMutex)
        pthread_cond_broadcast(timeoutCond)
        pthread_mutex_unlock(timeoutMutex)
    }
}
extension NSLock {
    // 同步执行 closure 操作
    internal func synchronized&lt;T&gt;(_ closure: () -&gt; T) -&gt; T {
        self.lock()
        defer { self.unlock() }
        return closure()
    }
}

</code></pre>
<p>而 <code>NSLock</code> 非递归锁，在递归调用时会堵塞。如果需要递归调用可以通过 <code>NSRecursiveLock</code> 加锁， <code>NSRecursiveLock</code> 实现与 <code>NSLock</code> 类似，只是在初始化时设置 <code>mutex</code> 为 <code>RECURSIVE</code> 类型：</p>
<pre><code class="language-swift">open class NSRecursiveLock: NSObject, NSLocking {
    internal var mutex = _RecursiveMutexPointer.allocate(capacity: 1)
    private var timeoutCond = _ConditionVariablePointer.allocate(capacity: 1)
    private var timeoutMutex = _MutexPointer.allocate(capacity: 1)

    public override init() {
        super.init()
        var attrib = pthread_mutexattr_t()
        withUnsafeMutablePointer(to: &amp;attrib) { attrs in
            pthread_mutexattr_init(attrs)
						// 设置为 RECURSIVE
            pthread_mutexattr_settype(attrs, Int32(PTHREAD_MUTEX_RECURSIVE))
            pthread_mutex_init(mutex, attrs)
        }
        pthread_cond_init(timeoutCond, nil)
        pthread_mutex_init(timeoutMutex, nil)
    }

    open func lock() {
        pthread_mutex_lock(mutex)
    }

    open func unlock() {
        pthread_mutex_unlock(mutex)
        // Wakeup any threads waiting in lock(before:)
        pthread_mutex_lock(timeoutMutex)
        pthread_cond_broadcast(timeoutCond)
        pthread_mutex_unlock(timeoutMutex)
    }
}

</code></pre>
<p>而递归锁同时对同一个对象使用锁时也会产生死锁：</p>
<h3 id="nscondition"><a class="header" href="#nscondition">NSCondition</a></h3>
<p><a href="https://developer.apple.com/documentation/foundation/nscondition">NSCondition</a></p>
<p><code>NSCondition</code> 对象在给定线程中充当锁和检查点 （ checkpoint ）。锁在检测条件和执行由条件触发的任务时保护你的代码。检查点则要求线程在执行其任务之前条件为 <code>true</code> 。当条件为 <code>false</code> 时，线程会阻塞，直到另一个线程向条件对象发出信号。伪代码：</p>
<pre><code>lock the condition
while (!(boolean_predicate)) {
    wait on condition
}
do protected work
(optionally, signal or broadcast the condition again or change a predicate value)
unlock the condition

</code></pre>
<p>与信号量类似， Swift 源码中也有 <code>NSCondition</code> 的实现：</p>
<pre><code class="language-swift">open class NSCondition: NSObject, NSLocking {
    internal var mutex = _MutexPointer.allocate(capacity: 1)
    internal var cond = _ConditionVariablePointer.allocate(capacity: 1)

    public override init() {
        pthread_mutex_init(mutex, nil)
        pthread_cond_init(cond, nil)
    }

    deinit {
        pthread_mutex_destroy(mutex)
        pthread_cond_destroy(cond)
        mutex.deinitialize(count: 1)
        cond.deinitialize(count: 1)
        mutex.deallocate()
        cond.deallocate()
    }

    open func lock() {
        pthread_mutex_lock(mutex)
    }

    open func unlock() {
        pthread_mutex_unlock(mutex)
    }

    open func wait() {
        pthread_cond_wait(cond, mutex)
    }

    open func wait(until limit: Date) -&gt; Bool {
        guard var timeout = timeSpecFrom(date: limit) else {
            return false
        }
        return pthread_cond_timedwait(cond, mutex, &amp;timeout) == 0
    }

    open func signal() {
        pthread_cond_signal(cond)
    }

    open func broadcast() {
        pthread_cond_broadcast(cond)
    }

    open var name: String?
}

</code></pre>
<p>用法如下：</p>
<pre><code class="language-swift">let cond = NSCondition()
var available = false
var SharedString = &quot;&quot;

class WriterThread : Thread {

    override func main(){
        for _ in 0..&lt;5 {
            cond.lock()
            SharedString = &quot;😅&quot;
            available = true
            cond.signal() // 通知并且唤醒等待的线程
            cond.unlock()
        }
    }
}

class PrinterThread : Thread {

    override func main(){
        for _ in 0..&lt;5 { // 循环 5 次
            cond.lock()
            while(!available){   // 通过伪信号进行保护
                cond.wait()
            }
            print(SharedString)
            SharedString = &quot;&quot;
            available = false
            cond.unlock()
        }
    }
}

let writet = WriterThread()
let printt = PrinterThread()
printt.start()
writet.start()

</code></pre>
<h3 id="nsconditionlock"><a class="header" href="#nsconditionlock">NSConditionLock</a></h3>
<p><a href="https://developer.apple.com/documentation/foundation/nsconditionlock">NSConditionLock</a></p>
<p><code>NSConditionLock</code> 与 <code>NSCondition</code> 不同，自带支持复杂的条件锁，比如说：消费者-提供者场景。 <code>lock(whenCondition:)</code> 在条件成立时可以获取到锁，或者等待另外一个线程调用 <code>unlock(withCondition:)</code> 释放锁和设置对应的值。</p>
<pre><code class="language-swift">let NO_DATA = 1
let GOT_DATA = 2
let clock = NSConditionLock(condition: NO_DATA)
var SharedInt = 0

class ProducerThread : Thread {

    override func main(){
        for i in 0..&lt;5 {
            clock.lock(whenCondition: NO_DATA) //当条件为 NO_DATA 获取该锁
              // 如果不想等待消费者，直接调用 clock.lock() 即可
            SharedInt = i
            clock.unlock(withCondition: GOT_DATA) //解锁并设置条件为 GOT_DATA
        }
    }
}

class ConsumerThread : Thread {

    override func main(){
        for i in 0..&lt;5 {
            clock.lock(whenCondition: GOT_DATA) // 当条件为 GOT_DATA 获取该锁
            print(i)
            clock.unlock(withCondition: NO_DATA) //解锁并设置条件为 NO_DATA
        }
    }
}

let pt = ProducerThread()
let ct = ConsumerThread()
ct.start()
pt.start()

</code></pre>
<h3 id="dispatch_semaphore"><a class="header" href="#dispatch_semaphore">dispatch_semaphore</a></h3>
<p><a href="https://developer.apple.com/documentation/dispatch/dispatchsemaphore">dispatch_semaphore</a></p>
<p><code>distpatch_semaphore</code> 在 Swift 上已替换为 <code>DispatchSemaphore</code> ，相应的 API 也有所改变。</p>
<p>信号量，可以作为同步锁使用，也可以控制 GCD 的最大并发数：</p>
<pre><code>let semaphore = DispatchSemaphore(value: 0)
semaphore.signal()
semaphore.wait()

</code></pre>
<h3 id="os_unfair_lock"><a class="header" href="#os_unfair_lock">os_unfair_lock</a></h3>
<p><code>os_unfair_lock</code> 是苹果在 iOS 10/macOS 10.12 上提供的，用于替换 <code>OSSpinLock</code> 。</p>
<p><a href="https://developer.apple.com/documentation/os/1646466-os_unfair_lock_lock">os_unfair_lock_lock</a></p>
<h2 id="各个锁在-swift-上的性能测试"><a class="header" href="#各个锁在-swift-上的性能测试">各个锁在 Swift 上的性能测试</a></h2>
<p><a href="https://gist.github.com/steipete/36350a8a60693d440954b95ea6cbbafc">Updated for Xcode 8, Swift 3; added os_unfair_lock</a></p>
<p>这里有个锁的性能测试，如果只需要支持到 iOS10 ，那么使用 <code>os_unfair_lock_s</code> 是最好的选择， <code>OSSpinLock</code> 性能最好，但是有优先级反转的问题：</p>
<p>如果需要支持 iOS10 以下那么信号量或者 <code>pthread_mutex</code> 在性能上表现最好。如果需要支持 <code>Linux</code> 平台可以选择 <code>pthread_mutex</code> 。</p>
<p>其余的 <code>NSLock</code> ， <code>DispatchQueue</code> 和 <code>@Syncronized</code> 性能都较差，因为苹果在里面做了不少容错处理和进行一些全局记录（ <code>@Syncronized</code> ）</p>
<h2 id="locks-thread-safety-and-swift"><a class="header" href="#locks-thread-safety-and-swift">Locks, Thread Safety, and Swift</a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2017-10-27-locks-thread-safety-and-swift-2017-edition.html">mikeash.com: Friday Q&amp;A 2017-10-27: Locks, Thread Safety, and Swift: 2017 Edition</a></p>
<p>锁是一个确保在同一时机内只能有一个线程访问特定区间内代码的机制，确保了多线程访问可变数据时的一致性。锁有以下三种类型：</p>
<ol>
<li>线程等待锁时会进入休眠状态，获取到锁后再唤醒；</li>
<li>线程等待锁时会一直忙等，直到获取锁，在等待时间较短时会更有效率，但是会浪费 CPU 时间；</li>
<li>读写锁，支持多个读线程同时进入同一区间，但是只能支持一个写线程进行写数据；</li>
<li>递归锁，支持同一个线程多次获取同一锁。</li>
</ol>
<p>相关 API ：</p>
<ol>
<li><code>pthread_mutex_t</code> 互斥锁，支持配置为递归锁；</li>
<li><code>pthread_rwlock_t</code> 互斥的读写锁；</li>
<li><code>DispatchQueue</code> 可以派发阻塞的 <code>block</code> ，结合并发队列和 <code>barrier blocks</code> 实现读写锁，也支持异步派发；</li>
<li><code>OperationQueue</code> 支持的功能和 <code>DispatchQueue</code> 类似；</li>
<li><code>NSLock</code> 是 Objective-C 层级的锁， <code>NSRecursiveLock</code> 为支持递归的锁；</li>
<li><code>os_unfair_lock</code> 是更底层的锁；</li>
<li><code>@synchronized</code> 为 Objective-C 提供的语言特性。</li>
</ol>
<p><code>pthread</code> 在初始化时需要多注意下，需要通过 <code>pthread</code> 提供的方法 <code>pthread_mutex_init</code> 或者 <code>pthread_rwlock_init</code> 进行初始化：</p>
<pre><code class="language-c">var mutex = pthread_mutex_t()
pthread_mutex_init(&amp;mutex, nil)
</code></pre>
<h3 id="值类型"><a class="header" href="#值类型">值类型</a></h3>
<p><code>phtread_mutex_t</code> ， <code>pthread_rwlock_t</code> 和 <code>os_unfair_lock</code> 都是值类型。如果使用 <code>=</code> 进行赋值，那么就会进行值拷贝，但是这些锁类型并不支持拷贝。如果对 <code>pthread</code> 类型进行拷贝，拷贝得到的值是不可用的，会在使用时触发崩溃。 <code>pthread</code> 函数会假设 <code>pthread</code> 类型在初始化时是同一个内存地址，所以拷贝到别的内存地址并不是个好主意。 <code>os_unfair_lock</code> 不会崩溃，但是会得到另外一个锁。</p>
<h3 id="如何选择对应的-lock-api"><a class="header" href="#如何选择对应的-lock-api">如何选择对应的 Lock API</a></h3>
<p><code>DispatchQueue</code> 是比较好的选择，有着友好的，更加 Swift 的 API ，同时也支持各种各样的特性。但是 <code>DispatchQueue</code> 也不是完美的，在内存中，队列会作为一个对象来使用，所以会有一些性能上的开销。同时也不支持条件变量或者递归。</p>
<p><code>os_unfair_lock</code> 在对性能有较高追求和不需要一些高级特性时是个不错的选择。它的实现相当于一个 32-bit 的整数，所以性能开销极小。但是正如它名字所说的那样，这是一个不公平的锁，它不会确保每个线程都有机会来获取锁，所以有可能某个线程会迅速地释放和获取锁，而其它线程则一直在等待。</p>
<p><code>pthread_mutex</code> 则位于两者中间，它比 <code>os_unfair_lock</code> 考虑得更多，占用内存为 64 bytes ，在苹果的实现上，它是一个公平的锁。</p>
<p><code>pthread_rwlock</code> 提供了一个读写锁，使用了 200 bytes ，但是没有提供更多的特性。</p>
<p><code>NSLock</code> 基于 <code>pthread_mutex</code> 进行封装，如果说你不想手动管理 <code>phread_mutex</code> 的初始化和销毁，那么可以使用 <code>NSLock</code> 。</p>
<p><code>OperationQueue</code> 提供了依赖管理。</p>
<p>优先考虑使用 <code>DispatchQueue</code> ，对性能有追求时可以使用 <code>os_unfair_lock</code> ，只有少数情况才需要考虑其它锁。</p>
<p>Swift 没有用于线程同步的语言工具，但是锁的 API 弥补了这一点。 GCD 依然是 Apple 皇冠上的明珠之一。虽然说我们没有 <code>@synchronized</code> 或者原子属性，但是我们有更好的选择。</p>
<h2 id="ios-locks"><a class="header" href="#ios-locks">iOS Locks</a></h2>
<p><a href="https://github.com/bestswifter/blog/blob/master/articles/ios-lock.md">blog/ios-lock.md at master · bestswifter/blog</a></p>
<p>自旋锁伪代码：</p>
<pre><code class="language-cpp">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁
do {
    while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁
    lock = true; // 挂上锁，这样别的线程就无法获得锁
        Critical section  // 临界区
    lock = false; // 相当于释放锁，这样别的线程可以进入临界区
        Reminder section // 不需要锁保护的代码        
}
</code></pre>
<p>原子操作需要由硬件支持，在执行时会把总线锁住，使得其它 CPU 不能执行相同的操作：</p>
<pre><code class="language-cpp">bool test_and_set (bool *target) {
    bool rv = *target; 
    *target = TRUE; 
    return rv;
}
</code></pre>
<p>也介绍了其它锁的相关原理。</p>
<h2 id="ios-中的那些锁"><a class="header" href="#ios-中的那些锁">iOS 中的那些锁</a></h2>
<p><a href="https://juejin.cn/post/6844904167010467854">iOS探索 细数iOS中的那些锁</a></p>
<h3 id="atomic-的原理"><a class="header" href="#atomic-的原理"><code>atomic</code> 的原理：</a></h3>
<pre><code class="language-cpp">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
{
    if (offset == 0) {
        object_setClass(self, newValue);
        return;
    }

    id oldValue;
    id *slot = (id*) ((char*)self + offset);

    if (copy) {
        newValue = [newValue copyWithZone:nil];
    } else if (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:nil];
    } else {
        if (*slot == newValue) return;
        newValue = objc_retain(newValue);
    }

    if (!atomic) {
        oldValue = *slot;
        *slot = newValue;
    } else {
        spinlock_t&amp; slotlock = PropertyLocks[slot];
        slotlock.lock();
        oldValue = *slot;
        *slot = newValue;        
        slotlock.unlock();
    }

    objc_release(oldValue);
}
</code></pre>
<p>如果使用了 <code>atomic</code> 进行声明，那么就会改用 <code>spinlock_t</code> 来进行加锁，而 <code>spinlock_t</code> 则是使用 <code>os_unfair_lock</code> 实现：</p>
<pre><code class="language-cpp">using spinlock_t = mutex_tt&lt;LOCKDEBUG&gt;;

class mutex_tt : nocopy_t {
    os_unfair_lock mLock;
    ...
}
</code></pre>
<p>且由于 <code>atomic</code> 的性能问题，在 iOS 上基本上都是使用 <code>nonatomic</code> 来进行声明。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="官方文档-4"><a class="header" href="#官方文档-4">官方文档</a></h2>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Run Loops</a></p>
<h2 id="深入理解-runloop"><a class="header" href="#深入理解-runloop">深入理解 RunLoop</a></h2>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
<p>这篇文章写得非常好，推荐反复阅读。</p>
<p>RunLoop 相关类和关系图：</p>
<p><img src="iDev/Multithreading/media/16302061705901.jpg" alt="" /></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer 。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode 。如果需要切换 Mode ，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer ，让其互不影响。</p>
<p>RunLoop 通知 Observers 的流程：</p>
<p><img src="iDev/Multithreading/media/16302061864944.jpg" alt="" /></p>
<p>RunLoop 的应用：</p>
<ol>
<li>AutoreleasePool ，苹果在主线程的 RunLoop 里注册了两个 Observer ，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code> 。第一个 Observer 监听 Entry ，调用 <code>_objc_autoreleasePoolPush()</code> 创建 AutoreleasePool ， order 是 -2147483647 ，优先级最高，这样可以在其它回调之前就进行创建 AutoreleasePool 。第二个 Observer 监听了 BeforeWaiting 和 Exit ， BeforeWaiting 时调用 <code>_objc_autoreleasePoolPop()</code> 来退出旧的 AutoreleasePool ，然后调用 <code>_objc_autoreleasePoolPush()</code> 来创建新的 AutoreleasePool ，给下一轮使用。而在 Exit 时也会调用 <code>_objc_autoreleasePoolPop()</code> 来退出 AutoreleasePool ， Observer 的优先级是 2147483647 ，优先级最低，确保在最后进行处理；</li>
<li>事件响应，注册了一个基于 mach port 的 Source1 来接收系统事件，流程：IOKit.framework 生成 IOHIDEvent 事件 → SpringBoard 接收 → mach port 转发给 App → 触发 Source1 回调 → <code>_UIApplicationHandleEventQueue()</code> 进行分发。包括点击事件/屏幕旋转等；</li>
<li>界面更新，在操作 UI 时，比如更新 <code>frame</code> ，对 <code>UIView/CALayer</code> 视图相关的属性进行操作，或者手动调用 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，系统会将记录这个 <code>UIView/CALayer</code> ，然后通过监听 BeforeWaiting 和 Exit 事件，执行 <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> ，在这里面对所有待处理的 <code>UIView/CALayer</code> 进行绘制，更新界面；</li>
<li><code>NSTimer</code> 回调， <code>NSTimer</code> 其实是 <code>CFRunLoopTimerRef</code> 的桥接， <code>NSTimer</code> 注册到 RunLoop 后， RunLoop 会持有这个 <code>NSTimer</code> ，直到 <code>invalidate</code> 或者方法执行完毕。所以如果 <code>NSTimer</code> 的 <code>repeat</code> 为 <code>YES</code> 及和强引用 <code>target</code> 时，会导致 <code>NSTimer</code> 和 <code>target</code>  无法释放。且如果 RunLoop 切换了 mode ，而对应的 <code>NSTimer</code> 没有添加到 commonMode ，那么 <code>NSTimer</code> 就不会执行；</li>
<li><code>NSObject</code> 调用 <code>performSelector:afterDelay:</code> 后，内部会创建一个 <code>Timer</code> 添加到当前线程的 RunLoop 中，如果说当前线程没有 RunLoop ，那么这个方法就会失效。 <code>performSelector:onThread:</code> 则可以指定对应的线程；</li>
<li>通过 GCD 的 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 切换到主队列执行 <code>block</code> 时， libDispatch 会向主线程 RunLoop 发送消息，唤醒 RunLoop ，然后从消息中获取和执行 <code>block</code> 。</li>
</ol>
<p>关于线程保活：</p>
<p>线程在执行完任务后就会退出和销毁，通过创建 RunLoop 和添加 Timer/Observer/Source 到 RunLoop 中，使得线程不退出，这样可以在该线程中接收和处理消息。比较经典的是 AFNetworking 2.0 中的做法：</p>
<pre><code class="language-cpp">+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&amp;oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}

+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];
        // 在当前线程创建 RunLoop
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        // 添加一个 NSMachPort ，防止 RunLoop 退出
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        // 启动 RunLoop
				[runLoop run];
    }
}
</code></pre>
<p>Texture 也依赖 RunLoop 的机制，将耗时的不需要在主线程进行的操作放到后台线程中进行，然后添加一个 Observer 到 RunLoop 中，监听了 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code> 事件，在 RunLoop 休眠前在主线程提交相关事务，对 UI 进行修改。相关实现：</p>
<p><a href="https://github.com/TextureGroup/Texture/blob/master/Source/Details/Transactions/_ASAsyncTransactionGroup.mm">Texture/_ASAsyncTransactionGroup.mm at master · TextureGroup/Texture</a></p>
<p>流程代码：</p>
<pre><code class="language-objectivec">{
    /// 1. 通知Observers，即将进入RunLoop
    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
    do {
 
        /// 2. 通知 Observers: 即将触发 Timer 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
 
        /// 4. 触发 Source0 (非基于port的) 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
 
        /// 6. 通知Observers，即将进入休眠
        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);
 
        /// 7. sleep to wait msg.
        mach_msg() -&gt; mach_msg_trap();
        
 
        /// 8. 通知Observers，线程被唤醒
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);
 
        /// 9. 如果是被Timer唤醒的，回调Timer
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);
 
        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);
 
        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);
 
 
    } while (...);
 
    /// 10. 通知Observers，即将退出RunLoop
    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
}
</code></pre>
<p>详细的代码：</p>
<pre><code class="language-objectivec">/// 用DefaultMode启动
void CFRunLoopRun(void) {
    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
}
 
/// 用指定的Mode启动，允许设置RunLoop超时时间
int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}
 
/// RunLoop的实现
int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {
    
    /// 首先根据modeName找到对应mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);
    /// 如果mode里没有source/timer/observer, 直接返回。
    if (__CFRunLoopModeIsEmpty(currentMode)) return;
    
    /// 1. 通知 Observers: RunLoop 即将进入 loop。
    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);
    
    /// 内部函数，进入loop
    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {
        
        Boolean sourceHandledThisLoop = NO;
        int retVal = 0;
        do {
 
            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);
            
            /// 4. RunLoop 触发 Source0 (非port) 回调。
            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);
 
            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
            if (__Source0DidDispatchPortLastTime) {
                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)
                if (hasMsg) goto handle_msg;
            }
            
            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。
            if (!sourceHandledThisLoop) {
                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
            }
            
            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。
            /// • 一个基于 port 的Source 的事件。
            /// • 一个 Timer 到时间了
            /// • RunLoop 自身的超时时间到了
            /// • 被其他什么调用者手动唤醒
            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) {
                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg
            }
 
            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);
            
            /// 收到消息，处理消息。
            handle_msg:
 
            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。
            if (msg_is_timer) {
                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
            } 
 
            /// 9.2 如果有dispatch到main_queue的block，执行block。
            else if (msg_is_dispatch) {
                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            } 
 
            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件
            else {
                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
                if (sourceHandledThisLoop) {
                    mach_msg(reply, MACH_SEND_MSG, reply);
                }
            }
            
            /// 执行加入到Loop的block
            __CFRunLoopDoBlocks(runloop, currentMode);
            
 
            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
                /// 进入loop时参数说处理完事件就返回。
                retVal = kCFRunLoopRunHandledSource;
            } else if (timeout) {
                /// 超出传入参数标记的超时时间了
                retVal = kCFRunLoopRunTimedOut;
            } else if (__CFRunLoopIsStopped(runloop)) {
                /// 被外部调用者强制停止了
                retVal = kCFRunLoopRunStopped;
            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
                /// source/timer/observer一个都没有了
                retVal = kCFRunLoopRunFinished;
            }
            
            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。
        } while (retVal == 0);
    }
    
    /// 10. 通知 Observers: RunLoop 即将退出。
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
}
</code></pre>
<h2 id="nsrunloop-internals"><a class="header" href="#nsrunloop-internals"><code>NSRunLoop</code> Internals</a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-01-nsrunloop-internals.html">mikeash.com: Friday Q&amp;A 2010-01-01: NSRunLoop Internals</a></p>
<p><code>NSRunLoop</code> 伪代码。</p>
<p><code>run</code> 方法的实现非常简单，先判断是否有 Source 或者 Timer ，如果没有，就直接退出：</p>
<pre><code class="language-objectivec">- (void)run
{
    while([self hasSourcesOrTimers])
        [self runMode: NSDefaultRunLoopMode beforeDate: [NSDate distantFuture]];
}

- (void)runUntilDate: (NSDate *)limitDate
{
    while([self hasSourcesOrTimers])
    {
        [self runMode: NSDefaultRunLoopMode beforeDate: limitDate];
            
        // check limitDate at the end of the loop to ensure that
        // the runloop always runs at least once
        if([limitDate timeIntervalSinceNow] &lt; 0)
            break;
    }
}
</code></pre>
<p><code>NSRunLoop</code> 提供了添加 Source 的方法：</p>
<pre><code class="language-objectivec">- (void)addPort: (NSPort *)aPort forMode: (NSString *)mode
{
    NSMutableSet *sourcesSet = [_inputSources objectForKey: mode];
    if(!sourcesSet)
    {
        // 如果当前 mode 还没有创建关于 source 的 NSMutableSet ，就动态创建一个
        sourcesSet = [NSMutableSet set];
        [_inputSources setObject: sourcesSet forKey: mode];
    }
    [sourcesSet addObject: aPort];
}
</code></pre>
<p>同时也有对应的移除 Source 方法：</p>
<pre><code class="language-objectivec">- (void)removePort: (NSPort *)aPort forMode: (NSString *)mode
{
    NSMutableSet *sourcesSet = [_inputSources objectForKey: mode];
    [sourcesSet removeObject: aPort];
        
    // 如果 source 的 NSMutableSet 为空，则移除
    if(![sourcesSet count])
        [_inputSources removeObjectForKey: mode];
}
</code></pre>
<pre><code class="language-objectivec">- (BOOL)runMode: (NSString *)mode beforeDate: (NSDate *)limitDate
{
    // 如果没有 Source 或者 Timer ，就直接退出
    if(![self hasSourcesOrTimersForMode: mode])
        return NO;
        
    // with timer support, this code has to loop until an input
    // source fires
    // 
    BOOL didFireInputSource = NO;
    while(!didFireInputSource)
    {
        fd_set fdset;
        FD_ZERO(&amp;fdset);
            
        for(inputSource in [_inputSources objectForKey: mode])
            FD_SET([inputSource fileDescriptor], &amp;fdset);
        // 根据 limitDate 获取 timeout
        NSTimeInterval timeout = [limitDate timeIntervalSinceNow];
            
        // 选择 timeout 和 timerSources 中最小值
        for(timer in [_timerSources objectForKey: mode])
            timeout = MIN(timeout, [[timer fireDate] timeIntervalSinceNow]);

        select(fdset, timeout);
            
        // 处理 Source
        for(inputSource in [[[_inputSources objectForKey: mode] copy] autorelease])
            if(FD_ISSET([inputSource fileDescrptor], &amp;fdset))
            {
                didFireInputSource = YES;
                [inputSource fileDescriptorIsReady];
            }

        // 处理 Timer ，根据 fireDate 判断是否要调用 Timer 的 fire 方法，执行对应的事件
        // 根据 repeat 是否为 YES 判断要不要移除 Timer
        for(timer in [[[_timerSources objectForKey: mode] copy] autorelease])
            if([[timer fireDate] timeIntervalSinceNow] &lt;= 0)
                [timer fire];

        // 如果已经超出了 limitDate 的时间戳，就立即返回
        if([limitDate timeIntervalSinceNow] &lt; 0)
            break;
    }
    return YES;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit"><a class="header" href="#uikit">UIKit</a></h1>
<h2 id="交互"><a class="header" href="#交互">交互</a></h2>
<ul>
<li><a href="iDev/UIKit/./touches_presses_and_gestures.html">点击，按压与手势</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="点击按压与手势"><a class="header" href="#点击按压与手势">点击，按压与手势</a></h1>
<h2 id="官方文档-5"><a class="header" href="#官方文档-5">官方文档</a></h2>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures">Apple Developer Documentation</a></p>
<h3 id="处理-uikit-手势"><a class="header" href="#处理-uikit-手势">处理 UIKit 手势</a></h3>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures">Apple Developer Documentation</a></p>
<p>使用手势可以使得点击处理更加简单和创建统一的用户体验。</p>
<p>手势识别器（ Gesture Recognizers ）是在自定义控件上处理点击和按压事件最简单的方法。可以在任何控件上添加一到多个手势。手势识别器封装了所有需要处理和解释对应传入事件的逻辑，并将它们和已知的模式进行匹配。当检测到对应的模式时，手势识别器会通知对应的目标对象，可以是一个 <code>ViewController</code> ，也可以是控件（ <code>View</code> ）自己，或者 App 中的任何一个对象。</p>
<p>手势识别器通过 Target-Action 的方式来发送通知：</p>
<p><img src="iDev/UIKit/media/16312376320646.jpg" alt="" /></p>
<p>手势识别器分为两种类型：离散的和连续的。离散的手势识别器只会手势被识别后调用一次 Action 方法。而连续的手势则不同，当检测到满足初始化的标准时，它会多次调用 Action 方法，借此通知你手势信息的变化，比如说 <code>UIPanGestureRecognizer</code> 。
可以通过 <code>UIGestureRecognizer</code> 的 <code>state</code> 进行不同的处理。</p>
<h3 id="uitapgesturerecognizer"><a class="header" href="#uitapgesturerecognizer"><code>UITapGestureRecognizer</code></a></h3>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_tap_gestures">Apple Developer Documentation</a></p>
<p><code>UITapGestureRecognizer</code> 可以处理屏幕上短时间内的一次或多次点击。触发手势的手指不能从最初的接触点进行明显的移动，且支持配置点击的次数。可以通过配置点击次数来检测单次，双次或者三次点击。</p>
<p>如果 <code>UITapGestureRecognizer</code> 没有调用对应的 Target-Action ，可以检查下面的属性是否有正确设置：</p>
<ul>
<li><code>isUserInteractionEnabled</code> 是否有设置为 <code>true</code> ， <code>UILabel</code> 和 <code>UIImageView</code> 默认设置为 <code>false</code> ；</li>
<li>点击的次数是否和 <code>numberOfTapsRequired</code> 一致；</li>
<li>点击的手指是否和 <code>numberOfTouchesRequired</code> 一致。</li>
</ul>
<h3 id="uilongpressgesturerecognizer"><a class="header" href="#uilongpressgesturerecognizer"><code>UILongPressGestureRecognizer</code></a></h3>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_long-press_gestures">Apple Developer Documentation</a></p>
<p><code>UILongPressGestureRecognizer</code> 可以检测到一个或者多个手指（或者触摸笔）在屏幕上的长时间点击。支持配置持续时间和手指个数。</p>
<p>长按手势是持续类型的手势，这意味着当 <code>state</code> 改变时会调用多次 Target-Action 。当用户手指停留在屏幕上的时间满足长按手势的要求时，就会进入 <code>UIGestureRecognizerStateBegan</code> 状态。当手指开始移动或者点击事件有其它变化时进入 <code>UIGestureRecognizerStateChanged</code> 状态。即使手指移出最开始接收到事件的视图时， <code>state</code> 也会保持在 <code>UIGestureRecognizerStateChanged</code> 状态。直到手指离开屏幕，进入 <code>UIGestureRecognizerStateEnded</code> 状态。</p>
<p>通过长按手势可以实现 <code>context menu</code> ：</p>
<pre><code class="language-swift">@IBAction func showResetMenu(_ gestureRecognizer: UILongPressGestureRecognizer) {
   if gestureRecognizer.state == .began {
      self.becomeFirstResponder()
      self.viewForReset = gestureRecognizer.view

      // Configure the menu item to display
      let menuItemTitle = NSLocalizedString(&quot;Reset&quot;, comment: &quot;Reset menu item title&quot;)
      let action = #selector(ViewController.resetPiece(controller:))
      let resetMenuItem = UIMenuItem(title: menuItemTitle, action: action)

      // Configure the shared menu controller
      let menuController = UIMenuController.shared
      menuController.menuItems = [resetMenuItem]

      // Set the location of the menu in the view.
      let location = gestureRecognizer.location(in: gestureRecognizer.view)
      let menuLocation = CGRect(x: location.x, y: location.y, width: 0, height: 0)
      menuController.setTargetRect(menuLocation, in: gestureRecognizer.view!)

      // Show the menu.
      menuController.setMenuVisible(true, animated: true)
   }
}
</code></pre>
<p>如果长按手势的方法没有调用，可以检查下面的属性是否有正确设置：</p>
<ul>
<li><code>isUserInteractionEnabled</code> 是否有设置为 <code>true</code> ， <code>UILabel</code> 和 <code>UIImageView</code> 默认设置为 <code>false</code> ；</li>
<li>点击持续时间是否大于 <code>minimumPressDuration</code> ；</li>
<li>点击的次数是否等于 <code>numberOfTapsRequired</code> ；</li>
<li>点击的手指是否等于 <code>numberOfTouchesRequired</code> 。</li>
</ul>
<h3 id="uipangesturerecognizer"><a class="header" href="#uipangesturerecognizer"><code>UIPanGestureRecognizer</code></a></h3>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures/handling_pan_gestures?language=objc">Apple Developer Documentation</a></p>
<p>手指在屏幕上移动时可以由 <code>UIPanGestureRecognizer</code> 进行处理，针对屏幕边缘的移动手势，可以交给 <code>UIPanGestureRecognizer</code> 的子类 <code>UIScreenEdgePanGestureRecognizer</code> 来处理。</p>
<ol>
<li>当手指的移动距离满足要求时， <code>UIPanGestureRecognizer</code> 就会进入 <code>UIGestureRecognizerStateBegan</code> 状态；</li>
<li>当初始化完成后，随之而来的改变会使得 <code>UIPanGestureRecognizer</code> 进入 <code>UIGestureRecognizerStateChanged</code> 状态；</li>
<li>当手指离开屏幕后，就会变为 <code>UIGestureRecognizerStateEnded</code> 状态。</li>
</ol>
<p>为了简化追踪处理， <code>UIPanGestureRecognizer</code> 提供了 <code>translationInView:</code> 方法来获取用户手指距离原始位置的距离。苹果提供的示例：</p>
<pre><code class="language-swift">var initialCenter = CGPoint()  // The initial center point of the view.
@IBAction func panPiece(_ gestureRecognizer : UIPanGestureRecognizer) {   
   guard gestureRecognizer.view != nil else {return}
   let piece = gestureRecognizer.view!
   // Get the changes in the X and Y directions relative to
   // the superview's coordinate space.
   let translation = gestureRecognizer.translation(in: piece.superview)
   if gestureRecognizer.state == .began {
      // Save the view's original position. 
      self.initialCenter = piece.center
   }
      // Update the position for the .began, .changed, and .ended states
   if gestureRecognizer.state != .cancelled {
      // Add the X and Y translation to the view's original position.
      let newCenter = CGPoint(x: initialCenter.x + translation.x, y: initialCenter.y + translation.y)
      piece.center = newCenter
   }
   else {
      // On cancellation, return the piece to its original location.
      piece.center = initialCenter
   }
}
</code></pre>
<h2 id="使用响应链来处理事件"><a class="header" href="#使用响应链来处理事件">使用响应链来处理事件</a></h2>
<p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events">Apple Developer Documentation</a></p>
<p>Apps 使用 <code>UIResponder</code> 来接收和处理事件。 <code>UIResponder</code> 子类包括 <code>UIView</code> ， <code>UIViewController</code> 和 <code>UIApplication</code> 。 <code>UIResponder</code> 接收到原始事件数据后，需要对事件进行处理或者将其转发给另一个响应者。当你的 App 接收到事件时， UIKit 会自动找到最合适的 <code>UIResponder</code> 对象作为第一响应者。</p>
<p>未处理的事件会在响应链上进行传递，找到合适的响应者：</p>
<p><img src="iDev/UIKit/media/16312377669372.jpg" alt="" /></p>
<p><code>UIControl</code> 会直接和它们的目标对象进行关联。当用户和 <code>UIControl</code> 进行交互时， <code>UIControl</code> 会直接发送 <code>Action</code> 消息给目标对象， <code>Action</code> 消息不是事件，但是仍可以享受响应链的好处。当目标对象为空时， UIKit 会在响应链上进行遍历，直到找到有实现对应 <code>Action</code> 方法的响应者。</p>
<p>UIKit 基于 <code>UIView</code> 的 <code>hit-testing</code> 来判断事件发生在哪。会通过 <code>UIView</code> 的 <code>hitTest:withEvent:</code> 方法来找到 <code>bounds</code> 包含该点击的最上层的子视图，将其作为第一响应者来处理。</p>
<p>如果点击的位置超出了 <code>UIView</code> 的 <code>bounds</code> ，那么 <code>hitTest:withEvent:</code> 方法就会忽略这个 <code>UIView</code> 以及所有它的 <code>subviews</code> 。</p>
<p>很多 <code>UIKit</code> 的类都重写了 <code>UIResponder</code> 的 <code>next</code> 属性来为我们返回下一个 <code>Responder</code> 对象：</p>
<ul>
<li><code>UIView</code> ，如果它是 <code>viewController</code> 的 <code>root view</code> ，那么 <code>next</code> 就会返回这个 <code>viewController</code> ，否则就会返回 <code>superview</code> ；</li>
<li><code>UIViewController</code>
<ul>
<li>如果 <code>viewController</code> 的 <code>view</code> 是 <code>window</code> 的 <code>root view</code>  ，那么 <code>next</code> 就返回 <code>window</code>  ；</li>
<li>如果 <code>viewController</code> 由其它 <code>viewController</code> 弹出，那么 <code>next</code> 就返回其它 <code>viewController</code> ；</li>
</ul>
</li>
<li><code>UIWindow</code> ， <code>next</code> 返回 <code>UIApplication</code> ；</li>
<li><code>UIApplication</code> ， <code>next</code> 返回 <code>app delegate</code> , 但是只有在 <code>app delegate</code> 是 <code>UIResponder</code> 时才会这样，它不能是 <code>view</code> 或者 <code>viewController</code> 。</li>
</ul>
<h2 id="ios-响应链"><a class="header" href="#ios-响应链">iOS 响应链</a></h2>
<p><a href="https://juejin.cn/post/6894518925514997767">iOS | 事件传递及响应链</a></p>
<p><img src="iDev/UIKit/media/16312377877705.jpg" alt="" /></p>
<p>iOS 中处理响应事件的是 <code>UIResponder</code> ，只要是 <code>UIResponder</code> 的子类都可以进行处理。在触摸事件发生后， <code>UIApplication</code> 会调用 <code>sendEvennt(_ event: UIEvent)</code> 方法来将 <code>UIEvent</code> 传递给 <code>UIWindow</code> ，而 <code>UIWindow</code> 则会通过 <code>hitTest</code> 和 <code>point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool</code> 方法来查找第一响应者。</p>
<p><img src="iDev/UIKit/media/16312378060280.jpg" alt="" /></p>
<ul>
<li>检查自身是否可接收事件：
<ul>
<li><code>view.isUserInteractionEnabled</code> 为 <code>true</code> ；</li>
<li><code>view.alpha &gt; 0.01</code> ；</li>
<li><code>view.isHidden = false</code> 。</li>
</ul>
</li>
<li>判断左边是否在自身内部，通过 <code>point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool</code> ，可以通过重写这个方法来扩大点击范围。</li>
</ul>
<p>类似的代码实现：</p>
<pre><code class="language-swift">class HitTestExampleView: UIView {
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? {
        if !isUserInteractionEnabled || isHidden || alpha &lt;= 0.01 {
            return nil // 此处指视图无法接受事件
        }
        if self.point(inside: point, with: event) { // 判断触摸点是否在自身内部
            for subview in subviews.reversed() { // 按 FILO 遍历子视图
                let convertedPoint = subview.convert(point, from: self)
                let resultView = subview.hitTest(convertedPoint, with: event) 
                // ⬆️这句是判断触摸点是否在子视图内部，在就返回视图，不在就返回nil
                if resultView != nil { return resultView }
            }
            return self // 此处指该视图的所有子视图都不符合要求，而触摸点又在该视图自身内部
        }
        return nil // 此处指触摸点是否不在该视图内部
    }
}
</code></pre>
<p>当找到对应的第一响应者，响应链也随之确认了：</p>
<p><img src="iDev/UIKit/media/16312378237447.jpg" alt="" /></p>
<p>当确认响应链后，就会调用 <code>UIResponder</code> 中对应的方法：</p>
<pre><code class="language-swift">class TouchesExampleView: UIView {
    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        print(&quot;Touches Began on &quot; + colorBlock)
        super.touchesBegan(touches, with: event)
    }
    
    override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        print(&quot;Touches Moved on &quot; + colorBlock)
        super.touchesMoved(touches, with: event)
    }
  
    override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        print(&quot;Touches Ended on &quot; + colorBlock)
        super.touchesEnded(touches, with: event)
    }
}
</code></pre>
<p>如果是 <code>UIControl</code> 或者其子类，则会拦截掉其响应链的事件传递，不会向下调用 <code>UIResponder</code> 的相关方法。 <code>UIScrollView</code> 也是相同的工作机制。</p>
<p><a href="https://juejin.cn/post/6905914367171100680">iOS | 响应链及手势识别</a></p>
<p><img src="iDev/UIKit/media/16312378600837.jpg" alt="" /></p>
<ol>
<li>在 <code>UIResponder</code> 的 <code>touches</code> 系列方法中的 <code>UITouch</code> 包含了收集到 的 <code>UIGestureRecognizers</code> 。在触发 <code>touches</code> 方法的过程中，也会判断 <code>UITouch</code> 是否符号收集到的手势；</li>
<li>当成功识别手势时，第一响应者会收到 <code>touchesCancelled</code> 方法，且不会再收到来自该 <code>UITouch</code> 的 <code>touches</code> 事件，同时该 <code>UITouch</code> 关联的其它手势也会收到 <code>touchesCancelled</code> 。使得可以独占该 <code>UITouch</code> ；</li>
<li>手势未识别成功时， <code>UIGestureRecognizer</code> 的 <code>state</code> 为 <code>.possible</code> ，表示可能有机会识别成功。</li>
</ol>
<p><img src="iDev/UIKit/media/16312378736155.jpg" alt="" /></p>
<h3 id="相关的属性配置"><a class="header" href="#相关的属性配置">相关的属性配置</a></h3>
<ul>
<li><code>cancelsTouchesInView</code> ，默认为 <code>true</code> ，如果设置为 <code>false</code> ，那么当手势识别成功时，不会发送 <code>touchesCancelled</code> 给目标视图，目标视图还可以继续处理其它方法，比如说 <code>UIControl</code> 的 <code>.touchUpInside</code> 对应的方法等；</li>
<li><code>delaysTouchesBegan</code> ，默认为 <code>false</code> 。当设置为 <code>true</code> 时， <code>touches</code> 的系列方法会延迟到手势识别成功或者失败之后才开始；</li>
<li><code>delaysTouchesEnded</code> ，默认为 <code>true</code> ， <code>touchesEnded</code> 则会延迟大约 0.15s 触发，如果设置为 <code>false</code> ，那么 <code>touchesEnded</code> 则不会延迟，双击手势也会被识别为两次单击。</li>
</ul>
<h3 id="uicontrol-与手势识别"><a class="header" href="#uicontrol-与手势识别">UIControl 与手势识别</a></h3>
<p><code>UIControl</code> 接收 Target-Action 方法的方式是在其 <code>touches</code> 方法中识别、接收、处理，而手势的 <code>touches</code> 方法一定比其所在视图的 <code>touches</code> 方法早触发。对于自定义的 <code>UIControl</code> 来说，手势识别的优先级比 <code>UIControl</code> 自身处理事件的优先级高。</p>
<ul>
<li>如果同时给 <code>UIControl</code> 添加了 <code>.touchUpInside</code> 方法和 <code>UITapGestureRecognizer</code> ，只会处理 <code>UITapGestureRecognizer</code> ；</li>
<li>如果给已经添加了 <code>UITapGestureRecognizer</code> 的视图添加一个 <code>UIControl</code> 作为子视图，同时给这个 <code>UIControl</code> 添加 <code>.touchUpInside</code> 方法，最终也只会处理该视图的 <code>UITapGestureRecognize</code> ，不会处理 <code>.touchUpInside</code> 方法，如果是 <code>UIButton</code> ，则会优先处理 <code>UIButton</code> 的方法；</li>
<li>如果想要两种都生效，可以设置 <code>cancelsTouchesInView</code> 为 false 。</li>
</ul>
<p>手势识别器在大多数情况下，识别屏幕触摸事件的优先级，比控件本身的方法的优先级高。</p>
<h2 id="ios-事件机制"><a class="header" href="#ios-事件机制">iOS 事件机制</a></h2>
<p><a href="https://juejin.im/post/5d396ef7518825453b605afa#heading-23">深入理解 iOS 事件机制</a></p>
<p><a href="https://juejin.im/entry/6844903493640290311">iOS触摸事件全家桶</a></p>
<p>事件生命周期：</p>
<p><img src="iDev/UIKit/media/16312379048435.jpg" alt="" /></p>
<ol>
<li>系统通过 <code>hitTest:withEvent:</code> 方法沿视图层级树从底向上（从根视图开始）从后向前（从逻辑上更靠近屏幕的视图开始）进行遍历，最终返回一个适合响应触摸事件的 View ；</li>
<li>原生触摸事件从 Hit-Testing 返回的 View 开始，沿着响应链从上向下进行传递；</li>
<li>系统在探测阶段结束后创建了 <code>UITouch</code> ，并封装了 <code>UIEvent</code> 将其传递；</li>
<li>手势上下文 <code>UIGestureEnvironment</code> 最先收到 <code>UIEvent</code> ，并负责通知给相关的 <code>UIGestureRecognizer</code> ；</li>
<li><code>UIGestureEnvironment</code> 根据 <code>UIGestureRecognizer</code> 的 <code>delegate</code> 方法来判断其是否能够对触摸事件进行响应；</li>
<li><code>UIGestureRecognizer</code> 仍然会先于 <code>UIControl</code> 接收到触摸事件；</li>
<li><code>UIButton</code> 等部分 <code>UIControl</code> 会拦截其父 <code>View</code> 上的 <code>UIGestureRecognizer</code> ，但不会拦截自己和子 <code>View</code> 上的 <code>UIGestureRecognizer</code> ；</li>
<li><code>UIButton</code> 会截断响应链的事件传递，也可以利用响应链来寻找 Action Method 。</li>
</ol>
<h2 id="应用-2"><a class="header" href="#应用-2">应用</a></h2>
<h3 id="扩大子视图的点击范围"><a class="header" href="#扩大子视图的点击范围">扩大子视图的点击范围</a></h3>
<p><a href="https://juejin.im/post/5b83dcf9518825278e2729c5">谈谈响应链</a></p>
<p>本文先是介绍了响应链的基本原理，然后讲述了如何响应在父视图外的子视图点击事件。</p>
<h3 id="全局监听用户的点击事件"><a class="header" href="#全局监听用户的点击事件">全局监听用户的点击事件</a></h3>
<p>之前做过一个需求是用户在一定时间内没有点击屏幕就进行一些处理，我们可以对响应事件的顶层 <code>UIApplication</code> 进行操作，<code>hook</code> 它的 <code>sendEvent:</code> 事件，在用户停止点击时开始计时，记录用户没有点击的时间，进行一些操作。有几个需要注意的地方：</p>
<ol>
<li><code>sendEvent</code> 不仅仅是处理点击事件，所以需要判断下  <code>allTouches.count</code> 是否为 0 ，如果为 0 则表示不是点击事件；</li>
<li>如果 <code>touch.phase == UITouchPhaseBegan</code> 表示用户点击屏幕，停止计时；</li>
<li>如果 <code>phase == UITouchPhaseEnded</code> ，则表示有手指离开屏幕，因为有可能是多指同时点击，所以这里记录下 <code>countOfEnded</code> ，如果 <code>touches.count == countOfEnded</code> ，表示所有手指都离开屏幕，可以开始计时；</li>
</ol>
<pre><code class="language-objectivec">- (void)dt_sendEvent:(UIEvent *)event
{
    [self dt_sendEvent:event];

    if (event.allTouches.count == 0) {
        return;
    }
    NSArray &lt;UITouch *&gt; *touches = [event.allTouches allObjects];
    NSUInteger countOfEnded = 0;
    for (UITouch *touch in touches) {
        UITouchPhase phase = touch.phase;
        if (phase == UITouchPhaseBegan) {
            // 开始点击，停止计时
            // stopTimer 
						return;
        } else if (phase == UITouchPhaseEnded) {
            countOfEnded += 1;
        }
    }
    // 所有点击事件都结束，开始计时
    if (touches.count == countOfEnded) {
        // startTimer
    }
}
</code></pre>
<h3 id="巧用-uiapplication-的-sendaction"><a class="header" href="#巧用-uiapplication-的-sendaction">巧用 <code>UIApplication</code> 的 <code>sendAction</code></a></h3>
<p><a href="https://swiftrocks.com/understanding-the-ios-responder-chain.html">iOS Responder Chain: UIResponder, UIEvent, UIControl and uses</a></p>
<p>这篇文章虽然也是讲了下 <code>UIResponder</code> ， <code>UIEvent</code> 和 <code>UIControl</code> ，但是后面有几个非常有趣的用法。</p>
<pre><code class="language-swift">final class BlinkableView: UIView {
    override var canBecomeFirstResponder: Bool {
        return true
    }

    func select() {
        becomeFirstResponder()
    }

    @objc func performBlinkAction() {
        //Blinking animation
    }
}

UIApplication.shared.sendAction(#selector(BlinkableView.performBlinkAction), to: nil, from: nil, for: nil)
//Will precisely blink the last BlinkableView that had select() called.
</code></pre>
<p><code>BlinkableView</code> 的 <code>canBecomeFirstResponder</code> 返回 <code>true</code> ，调用 <code>select</code> 时 <code>becomeFirstResponder()</code> 。然后说下具体用法，比如说现在我们想让当前的 <code>BlinkableView</code> 执行 <code>performBlinkAction()</code> 方法，其它的 <code>BlinkableView</code> 都不执行，可以通过 <code>UIApplication.shared.sendAction(#selector(BlinkableView.performBlinkAction), to: nil, from: nil, for: nil)</code> 方法来达到目的，当响应链找到第一个 <code>BlinkableView</code> (firstResponder) 时就会停止。</p>
<pre><code class="language-swift">final class PushScreenEvent: UIEvent {

    let viewController: CoordenableViewController

    override var type: UIEvent.EventType {
        return .touches
    }

    init(viewController: CoordenableViewController) {
        self.viewController = viewController
    }
}

final class Coordinator: UIResponder {

    weak var viewController: CoordenableViewController?

    override var next: UIResponder? {
        return viewController?.originalNextResponder
    }

    @objc func pushNewScreen(sender: Any?, event: PushScreenEvent) {
        let new = event.viewController
        viewController?.navigationController?.pushViewController(new, animated: true)
    }
}

class CoordenableViewController: UIViewController {

    override var canBecomeFirstResponder: Bool {
        return true
    }

    private(set) var coordinator: Coordinator?
    private(set) var originalNextResponder: UIResponder?

    override var next: UIResponder? {
        return coordinator ?? super.next
    }

    override func viewDidAppear(_ animated: Bool) {
        //Fill info at viewDidAppear to make sure UIKit
        //has configured this view's next responder.
        super.viewDidAppear(animated)
        guard coordinator == nil else {
            return
        }
        originalNextResponder = next
        coordinator = Coordinator()
        coordinator?.viewController = self
    }
}

final class MyViewController: CoordenableViewController {
    //...
}

//From anywhere in the app:

let newVC = NewViewController()
UIApplication.shared.push(vc: newVC)

// 源代码漏了这段，给补上
extension UIApplication {
    func push(vc: CoordenableViewController) {
	      UIApplication.shared.sendAction(#selector(Coordinator.pushNewScreen(sender:event:)), 
																			  to: nil, 
																			  from: nil, 
																			  for: PushScreenEvent(viewController: CoordenableViewController))
	  }
}
</code></pre>
<p>调整后的响应链如下：</p>
<pre><code class="language-swift">// MyView -&gt; MyViewController -&gt; Coordinator -&gt; UIWindow -&gt; UIApplication -&gt; AppDelegate
</code></pre>
<p>当通过 <code>UIApplication</code> 发送 <code>action</code> 时，通过响应链查找可以找到 <code>Coordinator</code> ， <code>Coordinator</code> 通过 <code>PushScreenEvent</code> 进行 <code>push</code> 。</p>
<p>上面两个例子只是理论上可以这么做，原作者并没有在实际项目中尝试，这里是为了说明通过响应链做一些有趣的事情。</p>
<h3 id="查找某个-uiview-所在-viewcontroller"><a class="header" href="#查找某个-uiview-所在-viewcontroller">查找某个 <code>UIView</code> 所在 <code>viewController</code></a></h3>
<p>当我们需要获取某个 <code>UIView</code> 所在的 <code>viewController</code> 时，也可以通过响应链来进行处理：</p>
<pre><code class="language-swift">extension UIView {
  var closestViewController: UIViewController? {
    if let nextResponder = self.next as? UIViewController {
      return nextResponder
    } else if let nextResponder = self.next as? UIView {
      return nextResponder.closestViewController
    } else {
      return nil
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architectures"><a class="header" href="#architectures">Architectures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvc"><a class="header" href="#mvc">MVC</a></h1>
<h2 id="苹果关于-mvc-的介绍"><a class="header" href="#苹果关于-mvc-的介绍">苹果关于 MVC 的介绍</a></h2>
<p><a href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/">The Role of View Controllers</a></p>
<h2 id="如何使-uiviewcontroller-更整洁"><a class="header" href="#如何使-uiviewcontroller-更整洁">如何使 UIViewController 更整洁</a></h2>
<p><a href="https://objccn.io/issue-1-1/">ObjC 中国 - 更轻量的 View Controllers</a></p>
<p><a href="https://objccn.io/issue-1-2/">ObjC 中国 - 整洁的 Table View 代码</a></p>
<h2 id="如何写出更好的-mvc"><a class="header" href="#如何写出更好的-mvc">如何写出更好的 MVC</a></h2>
<p><a href="https://davedelong.com/blog/2017/11/06/a-better-mvc-part-1-the-problems/">A Better MVC, Part 1: The Problems</a></p>
<p>问题：</p>
<ol>
<li>违反封装，充斥着大量面条代码</li>
<li>Massview View Controller</li>
</ol>
<p>解决办法：
开发者为了解决上面两个问题通常会使用其它架构方式。但是会增加团队成员的学习成本。系统更新时也有可能需要更多时间来进行适配，同样地，如果你依赖了其它第三库，还需要等得第三库的更新。</p>
<p><a href="https://davedelong.com/blog/2017/11/06/a-better-mvc-part-2-fixing-encapsulation/">A Better MVC, Part 2: Fixing Encapsulation</a></p>
<p>对 View Controller 进行解耦，View Controller 不需要知道其它 View Controller ，做法是生成一个更高层 View Controller，这个 View Controller 不包含其它逻辑，只负责对 View Controller 的跳转进行处理。所有子 View Controller 都通过它来进行跳转。</p>
<p><a href="https://davedelong.com/blog/2017/11/06/a-better-mvc-part-3-fixing-massive-view-controller/">A Better MVC, Part 3: Fixing Massive View Controller</a></p>
<p>1 View Controller ≠ 1 screen of content</p>
<p>开始写 app 时，我们都会使用一个 View Controller 来表示一个屏幕的内容，但是当 app 变得复杂时，我们可以将某些比较复杂的界面分成多个小的 View Controller。</p>
<p><a href="https://davedelong.com/blog/2017/11/06/a-better-mvc-part-4-future-directions/">A Better MVC, Part 4: Future Directions</a></p>
<p>承接上面所说的 1 View Controller ≠ 1 screen of content，单个 cell 也可以使用单个 ViewController 来管理，将 cell 中的逻辑分离出来。
总结：</p>
<ul>
<li>使用 View Controllers 来分解 UI</li>
<li>使用 View Controllers 来管理列表控件</li>
<li>View Controllers 不一定要填充屏幕</li>
</ul>
<p><a href="https://davedelong.com/blog/2018/04/24/a-better-mvc-part-5-an-evolution/">A Better MVC, Part 5: An Evolution</a></p>
<p>作者在五个月后又写了一篇关于 MVC 的文章。</p>
<p>MVC 不是一种设计模式，是一种思想，它追求封装，将不同的东西分隔开来。
View Controller 其实不是 Controller，而是 View，它负责的其实是 View 相关的逻辑。
View Controller 应该只负责处理业务逻辑或者传递数据给它包含的 UIViews，不应该两者都包含。
UIViewControllers 应该只负责下面的其中一个部分：</p>
<ol>
<li>组合 Child View Controller</li>
<li>给自己拥有的 UIViews 填充数据</li>
</ol>
<blockquote>
<p>So instead of saying a UIViewController should “manage either sequence or UI”, perhaps a better way of saying it would be that a UIViewController should either compose children or put stuff in to UIViews (with the understanding that this is a guideline, and not a rule).</p>
</blockquote>
<h2 id="关于-mvc-的一个常见的误用"><a class="header" href="#关于-mvc-的一个常见的误用">关于 MVC 的一个常见的误用</a></h2>
<p><a href="https://onevcat.com/2018/05/mvc-wrong-use/">关于 MVC 的一个常见的误用</a></p>
<p>传统 MVC 由于自由度非常大，没有规则显示，在经过业务迭代后，稍不注意 ViewController 就会膨胀为 Massive View Controller ，一些潜在问题：</p>
<ol>
<li>包含 Model 层；</li>
<li>违反数据流动规则和单一职责。</li>
</ol>
<p><img src="iDev/Architectures/media/16324010421073.jpg" alt="" /></p>
<p>作者通过将 Model 层抽出和借助 KVO 简单录了一个单向流的 MVC ，意在说明即使没有借用其他结构（比如说 MVVM 和 RxSwift ），也可以写出一个符合规范和易维护的 ViewController 。</p>
<h2 id="单向流数据流动"><a class="header" href="#单向流数据流动">单向流数据流动</a></h2>
<p><a href="https://onevcat.com/2017/07/state-based-viewcontroller/">单向数据流动的函数式 View Controller</a></p>
<p>传统 MVC 的问题：</p>
<ol>
<li>修改 UI 的代码到处散落，随着逻辑变得复杂， UI 的状态将难以追踪；</li>
<li>难以测试；</li>
<li>无法重构。</li>
</ol>
<p>结合纯函数将其重构为单向流：</p>
<pre><code class="language-swift">func reducer(state: State, userAction: Action) -&gt; State
</code></pre>
<p>输出结果 <code>State</code> 只受输入 <code>state</code> 和 <code>userAction</code> 影响，在两者相同的情况下，输出 <code>state</code> 永远相同，其原理与 Swift 中的 <code>reduce</code> 函数类似：</p>
<pre><code class="language-swift">func reduce&lt;Result&gt;(_ initialResult: Result, 
                    _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result
</code></pre>
<p>在实际使用中，仅仅靠纯函数可能无法满足我们的需求，有时候还希望有“副作用”选项，希望在完成异步操作后可以执行对应的 <code>command</code> ：</p>
<pre><code class="language-swift">func reducer(state: State, userAction: Action) -&gt; (State, Command?)
</code></pre>
<p>整体的架构图</p>
<p><img src="iDev/Architectures/media/16324010666112.jpg" alt="" /></p>
<p>使用一个 <code>Store</code> 来存储 <code>subscriber</code> 和相关数据：</p>
<pre><code class="language-swift">protocol ActionType {}
protocol StateType {}
protocol CommandType {}

class Store&lt;A: ActionType, S: StateType, C: CommandType&gt; {
    let reducer: (_ state: S, _ action: A) -&gt; (S, C?)
    var subscriber: ((_ state: S, _ previousState: S, _ command: C?) -&gt; Void)?
    var state: S
    
    init(reducer: @escaping (S, A) -&gt; (S, C?), initialState: S) {
        self.reducer = reducer
        self.state = initialState
    }
    
    func subscribe(_ handler: @escaping (S, S, C?) -&gt; Void) {
        self.subscriber = handler
    }
    
    func unsubscribe() {
        self.subscriber = nil
    }
    
    func dispatch(_ action: A) {
        let previousState = state
        let (nextState, command) = reducer(state, action)
        state = nextState
        subscriber?(state, previousState, command)
    }
}
</code></pre>
<p>ViewController 通过 <code>subscribe</code> 方法来订阅数据源的改动进行 UI 调整， 通过 <code>dispatch</code> 传递 <code>action</code> 。同时也编写了一些单元测试来证明其可测试性。</p>
<p>这里在没有接入三方库的情况实现了单向数据流，如果想要尝试，也可试一下 </p>
<p><a href="https://github.com/ReSwift/ReSwift">ReSwift/ReSwift</a></p>
<p>Objective-C 版本在这里：</p>
<p><a href="https://wereadteam.github.io/2017/09/30/reflow/">Objective-C单向数据流方案</a></p>
<p>提供了一个 <code>RFStore</code> 的 <code>Store</code> 基类，内部做了一些 <code>hook</code> 处理，对于 <code>action</code> 开头的 <code>selector</code> 调用，都会调用 <code>listeners</code>  的 <code>block</code> ：</p>
<pre><code class="language-objectivec">+ (void)hookActionMethodsIfNeededForClass:(Class)class {
    static const void * const kHasHookedKey = &amp;kHasHookedKey;
    @synchronized(class) {
        id hasHooked = objc_getAssociatedObject(class, kHasHookedKey);
        if (!hasHooked) {
            unsigned int outCount = 0;
            Method *methods = class_copyMethodList(class, &amp;outCount);
            for (unsigned int i = 0; i &lt; outCount; ++i) {
                Method method = methods[i];
                SEL selector = method_getName(method);
                NSString *methodName = NSStringFromSelector(selector);
                if (![methodName hasPrefix:@&quot;action&quot;]) {
                    continue;
                }
                
                [RFStore registerActionForClass:class selector:selector];
            }
            objc_setAssociatedObject(class, kHasHookedKey, @YES, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        }
    }
}

+ (void)registerActionForClass:(Class)class selector:(SEL)selector {
    [class rfaspect_hookSelector:selector
                     withOptions:AspectPositionAfter
                      usingBlock:^(id&lt;RFAspectInfo&gt; aspectInfo) {
                          RFAction *action = [[RFAction alloc] initWithObject:aspectInfo.instance
                                                                     selector:selector
                                                                    arguments:aspectInfo.arguments];
                          
                          NSArray *globalListeners = [objc_getAssociatedObject([RFStore class], kListernersKey) allObjects];
                          NSArray *listeners = [objc_getAssociatedObject(action.object, kListernersKey) allObjects];
                          dispatch_async(dispatch_get_main_queue(), ^{
                              for (RFSubscription *subscription in globalListeners) {
                                  subscription.block(action);
                              }
                              for (RFSubscription *subscription in listeners) {
                                  subscription.block(action);
                              }
                          });
                      }
                           error:nil];
}
</code></pre>
<p><code>listeners</code> 使用 <code>weak</code> 的 <code>NSPointerArray</code> 进行存储，所以当 ViewController 释放后， <code>RFStore</code> 也会释放掉：</p>
<pre><code class="language-objectivec">+ (void)associateObject:(id)object withSubscription:(RFSubscription *)subscription {
    @synchronized(object) {
        NSPointerArray *listeners = objc_getAssociatedObject(object, kListernersKey);
        if (!listeners) {
            listeners = [NSPointerArray weakObjectsPointerArray];
            objc_setAssociatedObject(object, kListernersKey, listeners, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        }
        [listeners compact];
        [listeners addPointer:(void *)subscription];
    }
}
</code></pre>
<p>作者在最后提到对于 Reflow ，更重要的是其架构设计和规范：</p>
<ul>
<li>model 对象不可变；</li>
<li>整个 app 的数据存于 store 层；</li>
<li>更新和通知也收拢于 store 层。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅读"><a class="header" href="#阅读">阅读</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="未来简史"><a class="header" href="#未来简史">未来简史</a></h1>
<p><a href="https://book.douban.com/subject/26943161/">未来简史</a></p>
<p><img src="books/media/16296186411807.jpg" alt="" /></p>
<h2 id="第1章-人类的新议题"><a class="header" href="#第1章-人类的新议题">第1章 人类的新议题</a></h2>
<blockquote>
<p>这正是历史知识的悖论。知识如果不能改变行为，就没有用处。但知识一旦改变了行为，本身就立刻失去意义。我们拥有越多数据，对历史了解越深入，历史的轨迹就改变得越快，我们的知识也过时得越快。</p>
</blockquote>
<h2 id="第7章-人文主义革命"><a class="header" href="#第7章-人文主义革命">第7章 人文主义革命</a></h2>
<blockquote>
<p>他们认为战争是光荣的、开战的理由是正义的、领军的将军是个天才，但经过几个星期真正的战火洗礼，所有的泥泞、流血加上死亡的气味，让他们的幻想一一破灭。如果他们活了下来，这些原本天真的士兵离开战场后，就会成为更聪明的人，不再相信学校、电影和政客花言巧语中的陈词滥调与理想。</p>
</blockquote>
<blockquote>
<p>剑桥大学、索邦大学和伯克利大学（当时还有“伯克利人民共和国”的戏称）的学生，除了会翻阅毛主席的“红宝书”，也会把切·格瓦拉的英雄肖像挂在床头。</p>
</blockquote>
<blockquote>
<p>虽然西方学者和运动人士最爱挑自由主义一揽子方案的毛病，但至今仍未能提出更佳的选项。</p>
</blockquote>
<blockquote>
<p>没有信仰，火车就不能决定要开往哪个方向。</p>
</blockquote>
<blockquote>
<p>塑造历史的，往往是一小群向前看的创新者，而不是向后看的大众。</p>
</blockquote>
<blockquote>
<p>要达到马克思所称“各尽所能、各取所需”的理想，社会就必须让距离遥远的各种产品都能够方便集中及分配，而且整个国家也要能够监控和协调国内所有的活动。</p>
</blockquote>
<h2 id="第8章-实验室里的定时炸弹"><a class="header" href="#第8章-实验室里的定时炸弹">第8章 实验室里的定时炸弹</a></h2>
<blockquote>
<p>许多妇女分娩时都会经历难以忍受的痛苦，这会让人认为，只要生过一次，没有哪个心智正常的女性会愿意再生一次。但在分娩后的几天，内分泌系统会分泌皮质醇和β–内啡肽，舒缓疼痛，让人感到安慰，甚至是欢快，再加上对小婴儿的爱与日俱增，又得到来自亲友、宗教和民族主义宣传的多方赞誉，从而合力把分娩从创伤转为正面记忆。</p>
</blockquote>
<blockquote>
<p>叙事自我有一把锋利的剪刀、一支黑色的粗马克笔，一一审查着我们的体验。至少有某些令人恐惧不悦的时刻就这样被删减或抹去，最后整理出一个有欢乐结尾的故事，归档备存。</p>
</blockquote>
<blockquote>
<p>我们的叙事自我宁可在未来继续痛苦，也不想承认过去的痛苦完全没有意义。</p>
</blockquote>
<blockquote>
<p>人类十分擅长应付认知上的矛盾，能允许自己在实验室里信一套，到了法庭或议会又信完全不同的另一套。</p>
</blockquote>
<h2 id="第9章-大分离"><a class="header" href="#第9章-大分离">第9章 大分离</a></h2>
<blockquote>
<ol>
<li>生物是算法。每种动物（包括智人）都是各种有机算法的集合，是数百万年进化自然选择的结果。</li>
<li>算法的运作不受组成物质的影响。算盘的算珠无论是木质、铁质还是塑料质，两个珠子加上两个珠子还是等于四个珠子。</li>
<li>因此，没有理由相信非有机算法永远无法复制或超越有机算法能做的事。只要运算结果有效，算法是以碳为载体还是以硅为载体又有何差别？</li>
</ol>
</blockquote>
<blockquote>
<p>人工智能目前绝无法做到与人类匹敌。但对大多数的现代工作来说，99%的人类特性及能力都是多余的。人工智能要把人类挤出就业市场，只要在特定行业需要的特定能力上超越人类，就已足够。</p>
</blockquote>
<blockquote>
<p>想要不被淘汰只有一条路：一辈子不断学习，不断打造全新的自己。只不过，许多人，甚至是大多数人，大概都做不到这一点。</p>
</blockquote>
<blockquote>
<p>美国生物科技公司越来越担心，由于美国严格管控个人隐私，导致未来可能将整个基因市场拱手让给中国。</p>
</blockquote>
<blockquote>
<p>正如卡尼曼的冷水实验，叙事自我到了政治领域，一样会遵循“峰终定律”，忘了绝大多数的事情，只记得几件极端的事件，并对最近的事件赋予完全不成比例的高权重。</p>
</blockquote>
<blockquote>
<p>在欧洲帝国主义的全盛时期，殖民者和商人用彩色的珠子，就从当地人那里换来了整座岛屿、整个国家。而在21世纪，个人数据可能是大多数人能够提供的最宝贵资源，但我们正亲手把这些数据交给各大科技企业，好换来免费的电子邮箱或是有趣的小猫视频。</p>
</blockquote>
<blockquote>
<p>自由主义面对社会不平等的解药，不是让每个人都有同样的体验，而是对于不同的人类体验赋予同等的价值。</p>
</blockquote>
<h2 id="第10章-意识的海洋"><a class="header" href="#第10章-意识的海洋">第10章 意识的海洋</a></h2>
<blockquote>
<p>新宗教浮现的地点，不太可能是阿富汗的洞穴或是中东的宗教学校，反而会是研究实验室。就像社会主义承诺以蒸汽和电力为世界提供救赎，在接下来的几十年间，新的科技宗教也可能承诺以算法和基因为世界提供救赎，进而征服世界。</p>
</blockquote>
<blockquote>
<p>智人之所以统治世界，并不是因为智人的情感更深刻或音乐体验更复杂。至少在某些体验领域里，智人确实可能不如鲸鱼、蝙蝠、老虎或鹈鹕。</p>
</blockquote>
<blockquote>
<p>现代人类已经患上“错过恐惧症”（Fear Of Missing Out，FOMO），总在担心自己错过了什么；虽然手中的选择比以往任何时候都多，但选了之后又很难全心全意对待。</p>
</blockquote>
<blockquote>
<p>数百万年来，人类曾经是升级版的黑猩猩。而到了未来，人类则可能变成放大版的蚂蚁。</p>
</blockquote>
<blockquote>
<p>人的意志是宇宙中最重要的东西，同时人类在开发能够控制、重新设计意志的科技。毕竟，能够控制全世界最重要的东西，岂不是太棒了？然而一旦这样的控制成真，过去神圣的人类就会成为另外一种设计品，反而让科技人文主义不知该何去何从。只要我们仍然相信人类的意志和经验是权威和意义的本源，就永远无法处理和这些科技的关系。</p>
</blockquote>
<h2 id="第11章-数据主义"><a class="header" href="#第11章-数据主义">第11章 数据主义</a></h2>
<blockquote>
<p>这种所有数据都由单处理器来处理并决定的极端情况，就是苏联式共产主义。在苏联经济里，号称要让人人“各尽所能、各取所需”。换句话说，政府会把你的利润全部取走，再判断你有什么需求，并提供给你。</p>
</blockquote>
<blockquote>
<p>资本主义能够赢得“冷战”，是因为至少在这个科技加速改变的时期，分散式数据处理的效果就是比集中式数据处理更好。</p>
</blockquote>
<blockquote>
<p>政府确保教师每月拿到薪水、下水道不会堵塞，却不知道20年后国家该走向何方。</p>
</blockquote>
<blockquote>
<p>整部历史的进程就要通过4种方式，提高系统效率：</p>
<ol>
<li>增加处理器数量。拥有10万人口的城市，运算能力会高于拥有1000人口的村庄。</li>
<li>增加处理器种类。处理器不同，运算和分析数据的方式就不同。因此，如果单一系统拥有不同种类的处理器，就能增加其动力与创意。农民、祭司和医生对话中所产生的想法，可能是狩猎采集者之间怎么谈都不会谈到的。</li>
<li>增加处理器之间的连接。如果只是增加处理器数量和种类，但彼此之间无法连接，仍然没有意义。10个有贸易网络连接的城市，产出的经济、科技与社会创新通常会高于10个孤立的城市。</li>
<li>增加现有连接的流通自由度。如果数据无法自由流通，仅仅连接处理器也不会有什么用处。这就像是在10个城市之间修建了道路，但路上满是劫匪，商人或旅行者难以通行，这条路的作用也就会大打折扣。</li>
</ol>
</blockquote>
<blockquote>
<p>我们常常想象，民主和自由市场之所以获胜，是因为它们比较“好”。但事实上，它们之所以胜出，是因为改善了全球数据处理系统。</p>
</blockquote>
<blockquote>
<p>但数据主义指出，民众真正想要的并不是车辆本身，而是移动的便利，只要有优秀的数据处理系统，就能简单又有效地提供这种移动的便利。</p>
</blockquote>
<blockquote>
<p>没有人能真正理解全球经济如何运作，也没有人知道全球政治将走向何方。但也没有人真的需要理解这一切。你该做的，就只是回信回得更快（而且允许系统存取这些内容）。</p>
</blockquote>
<blockquote>
<p>现代的新座右铭是：“如果你体验到了什么，就记录下来。如果你记录下了什么，就上传。如果你上传了什么，就分享。”</p>
</blockquote>
<blockquote>
<p>汽车取代马车，我们并不是让马升级，而是直接让马退休。或许，智人也到了该退休的时候。</p>
</blockquote>
<blockquote>
<p>我们自己设定的标准，会让我们也走上猛玛象和白鳍豚的灭绝之路。到时回首过去，人类也只会成为宇宙数据流里的一片小小涟漪。</p>
</blockquote>
<blockquote>
<ol>
<li>科学正逐渐聚合于一个无所不包的教条，也就是认为所有生物都是算法，而生命则是进行数据处理。</li>
<li>智能正与意识脱钩。</li>
<li>无意识但具备高度智能的算法，可能很快就会比我们更了解我们自己。
这三项发展提出了三个关键问题，希望读者在读完本书之后，仍能常挂于心：</li>
<li>生物真的只是算法，而生命也真的只是数据处理吗？</li>
<li>智能和意识，究竟哪一个才更有价值？</li>
<li>等到无意识但具备高度智能的算法比我们更了解我们自己时，社会、政治和日常生活将会有什么变化？</li>
</ol>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
