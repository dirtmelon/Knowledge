<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FPS - Knowledge</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../About.html">关于</a></li><li class="chapter-item expanded "><a href="../../programming-languages/programming-languages.html">编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Swift/Swift.html">Swift</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Objective-C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/associated-objects.html">Associated Objects</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/initialize.html">initialize</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/load.html">load</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Block.html">Block</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Category.html">Category</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/KVO.html">KVO</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/KVC.html">KVC</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/AutoreleasePool.html">AutoreleasePool</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/dealloc.html">dealloc</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Tagged-Pointer.html">Tagged Pointer</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/weak.html">weak</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Object.html">Object</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/reference-counting.html">Reference Counting</a></li></ol></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/getting-subclasses-of-objective-c-class.html">如何获取某个类的全部子类</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/objective-c-class-properties.html">Objective-C 类属性</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../iDev/iDev.html">iDev</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Multithreading/Introduction.html">多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Multithreading/NSOperation.html">NSOperation</a></li><li class="chapter-item expanded "><a href="../../iDev/Multithreading/Grand-Central-Dispatch.html">Grand Central Dispatch</a></li><li class="chapter-item expanded "><a href="../../iDev/Multithreading/thread.html">pthread 和 NSThread</a></li><li class="chapter-item expanded "><a href="../../iDev/Multithreading/locks.html">Locks</a></li><li class="chapter-item expanded "><a href="../../iDev/Multithreading/RunLoop.html">RunLoop</a></li></ol></li><li class="chapter-item expanded "><a href="../../iDev/UIKit/UIKit.html">UIKit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/UIKit/touches_presses_and_gestures.html">点击，按压与手势</a></li></ol></li><li class="chapter-item expanded "><a href="../../iDev/Architectures/Architectures.html">Architectures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Architectures/MVC.html">MVC</a></li><li class="chapter-item expanded "><a href="../../iDev/Architectures/MVVM.html">MVVM</a></li></ol></li><li class="chapter-item expanded "><a href="../../iDev/Performance/Performance.html">性能优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Performance/FPS.html" class="active">FPS</a></li><li class="chapter-item expanded "><a href="../../iDev/Performance/Size.html">包大小</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../books/books.html">阅读</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../books/Homo-Deus-A-Brief-History-of-Tomorrow.html">未来简史</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Knowledge</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dirtmelon/Knowledge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fps-优化"><a class="header" href="#fps-优化">FPS 优化</a></h1>
<h2 id="如何检测卡顿"><a class="header" href="#如何检测卡顿">如何检测卡顿</a></h2>
<p><a href="https://juejin.cn/post/6844903686620053512">质量监控-卡顿检测</a></p>
<p><a href="https://juejin.cn/post/6844903944867545096">iOS卡顿监测方案总结</a></p>
<h3 id="基于-cadisplaylink"><a class="header" href="#基于-cadisplaylink">基于 <code>CADisplayLink</code></a></h3>
<p><a href="https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m">ibireme/YYText</a></p>
<p><code>CADisplayLink</code> 支持以和屏幕刷新率同步的方式更新屏幕上的内容，当注册到 <code>RunLoop</code> 后，每次当屏幕时，都会执行 <code>CADisplayLink</code> 的方法，与 <code>NSTimer</code> 不同的时其内部操作的是一个 <code>Source</code> 。 <code>YYKit</code> 中通过 <code>CADisplayLink</code> 写了个 debug 时显示 FPS的小工具：</p>
<pre><code class="language-objectivec">- (void)tick:(CADisplayLink *)link {
    if (_lastTime == 0) {
        _lastTime = link.timestamp;
        return;
    }
    
    _count++;
    NSTimeInterval delta = link.timestamp - _lastTime;
    if (delta &lt; 1) return;
    _lastTime = link.timestamp;
    float fps = _count / delta;
    _count = 0;
    
    CGFloat progress = fps / 60.0;
    UIColor *color = [UIColor colorWithHue:0.27 * (progress - 0.2) saturation:1 brightness:0.9 alpha:1];
    
    NSMutableAttributedString *text = [[NSMutableAttributedString alloc] initWithString:[NSString stringWithFormat:@&quot;%d FPS&quot;,(int)round(fps)]];
    [text setColor:color range:NSMakeRange(0, text.length - 3)];
    [text setColor:[UIColor whiteColor] range:NSMakeRange(text.length - 3, 3)];
    text.font = _font;
    [text setFont:_subFont range:NSMakeRange(text.length - 4, 1)];
    
    self.attributedText = text;
}
</code></pre>
<p><code>CADisplayLink</code> 刷新频率跟屏幕刷新一致，刷新频率为 60HZ ，每次刷新时 <code>_count</code> 都会加 1 ，如果 <code>delta &lt; 1</code> ，则表示没有超过 1s ，直接返回，如果超过 1s 则通过 <code>_count</code> 计算出 <code>fps</code> 。记得 <code>CADisplayLink</code> 需要添加 <code>NSRunLoopCommonModes</code> 。</p>
<p>Swift 版本：</p>
<pre><code class="language-swift">class WeakProxy: NSObject {
    
    weak var target: NSObjectProtocol?
    
    init(target: NSObjectProtocol) {
        self.target = target
        super.init()
    }
    
    override func responds(to aSelector: Selector!) -&gt; Bool {
        return (target?.responds(to: aSelector) ?? false) || super.responds(to: aSelector)
    }

    override func forwardingTarget(for aSelector: Selector!) -&gt; Any? {
        return target
    }
}

class FPSLabel: UILabel {
    var link:CADisplayLink!
    //记录方法执行次数
    var count: Int = 0
    //记录上次方法执行的时间，通过link.timestamp - _lastTime计算时间间隔
    var lastTime: TimeInterval = 0
    var _font: UIFont!
    var _subFont: UIFont!
    
    fileprivate let defaultSize = CGSize(width: 55,height: 20)
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        if frame.size.width == 0 &amp;&amp; frame.size.height == 0 {
            self.frame.size = defaultSize
        }
        self.layer.cornerRadius = 5
        self.clipsToBounds = true
        self.textAlignment = NSTextAlignment.center
        self.isUserInteractionEnabled = false
        self.backgroundColor = UIColor.white.withAlphaComponent(0.7)
        
        _font = UIFont(name: &quot;Menlo&quot;, size: 14)
        if _font != nil {
            _subFont = UIFont(name: &quot;Menlo&quot;, size: 4)
        }else{
            _font = UIFont(name: &quot;Courier&quot;, size: 14)
            _subFont = UIFont(name: &quot;Courier&quot;, size: 4)
        }
        
        link = CADisplayLink(target: WeakProxy.init(target: self), selector: #selector(FPSLabel.tick(link:)))
        link.add(to: RunLoop.main, forMode: .commonModes)
    }
    
    //CADisplayLink 刷新执行的方法
    @objc func tick(link: CADisplayLink) {
        
        guard lastTime != 0 else {
            lastTime = link.timestamp
            return
        }
        
        count += 1
        let timePassed = link.timestamp - lastTime
        
        //时间大于等于1秒计算一次，也就是FPSLabel刷新的间隔，不希望太频繁刷新
        guard timePassed &gt;= 1 else {
            return
        }
        lastTime = link.timestamp
        let fps = Double(count) / timePassed
        count = 0
        
        let progress = fps / 60.0
        let color = UIColor(hue: CGFloat(0.27 * (progress - 0.2)), saturation: 1, brightness: 0.9, alpha: 1)
        
        let text = NSMutableAttributedString(string: &quot;\(Int(round(fps))) FPS&quot;)
        text.addAttribute(NSAttributedStringKey.foregroundColor, value: color, range: NSRange(location: 0, length: text.length - 3))
        text.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor.white, range: NSRange(location: text.length - 3, length: 3))
        text.addAttribute(NSAttributedStringKey.font, value: _font, range: NSRange(location: 0, length: text.length))
        text.addAttribute(NSAttributedStringKey.font, value: _subFont, range: NSRange(location: text.length - 4, length: 1))
        self.attributedText = text
    }
    
    // 把displaylin从Runloop modes中移除
    deinit {
        link.invalidate()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
}
</code></pre>
<h3 id="基于-runloop"><a class="header" href="#基于-runloop">基于 RunLoop</a></h3>
<p>监听 <code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopAfterWaiting</code> 之间的耗时：</p>
<pre><code class="language-swift">- (void)start
{
    if (observer)
        return;
    
    // 信号
    semaphore = dispatch_semaphore_create(0);
    
    // 注册RunLoop状态观察
    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};
    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
                                       kCFRunLoopAllActivities,
                                       YES,
                                       0,
                                       &amp;runLoopObserverCallBack,
                                       &amp;context);
    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);
    
    // 在子线程监控时长
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        while (YES)
        {
						// 如果 RunLoop 两个状态之间超过 50ms ，就认为耗时过长
            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));
            if (st != 0)
            {
                if (!observer)
                {
                    timeoutCount = 0;
                    semaphore = 0;
                    activity = 0;
                    return;
                }
                
                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)
                {
                    if (++timeoutCount &lt; 5)
                        continue;
                    
                    PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD
                                                                                       symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];
                    PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];
                    
                    NSData *data = [crashReporter generateLiveReport];
                    PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];
                    NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter
                                                                              withTextFormat:PLCrashReportTextFormatiOS];
                    
                    NSLog(@&quot;------------\n%@\n------------&quot;, report);
                }
            }
            timeoutCount = 0;
        }
    });
}
</code></pre>
<p>开辟一个常驻子线程，然后计算 <code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopAfterWaiting</code> 两个状态之间的耗时是否超过某个阈值。</p>
<h3 id="子线程-ping"><a class="header" href="#子线程-ping">子线程 Ping</a></h3>
<p>创建一个子线程去 Ping 主线程，在主线程中对相关变量进行设置：</p>
<pre><code class="language-swift">public class CatonMonitor {
    
    enum Constants {
        static let timeOutInterval: TimeInterval = 0.05
        static let queueTitle = &quot;com.roy.PerformanceMonitor.CatonMonitor&quot;
    }
    
    private var queue: DispatchQueue = DispatchQueue(label: Constants.queueTitle)
    private var isMonitoring = false
    private var semaphore: DispatchSemaphore = DispatchSemaphore(value: 0)
    
    public init() {}
    
    public func start() {
        guard !isMonitoring else { return }
        
        isMonitoring = true
        queue.async {
            while self.isMonitoring {
                
                var timeout = true
                
                DispatchQueue.main.async {
                    timeout = false
                    // signal 唤醒子线程，继续下一轮检查
                    self.semaphore.signal()
                }
                
                Thread.sleep(forTimeInterval: Constants.timeOutInterval)
                
                // timeout 为 true 表示主线程在这段时间内一直处于执行状态
                if timeout {
                    let symbols = RCBacktrace.callstack(.main)
                    for symbol in symbols {
                        print(symbol.description)
                    }
                }
                self.semaphore.wait()
            }
        }
    }
    
    public func stop() {
        guard isMonitoring else { return }
        
        isMonitoring = false
    }
}
</code></pre>
<p>这套方法实现起来比较简单，缺点是无法获取卡顿时间。</p>
<h3 id="cpu-占用超过阈值"><a class="header" href="#cpu-占用超过阈值">CPU 占用超过阈值</a></h3>
<p><a href="https://mp.weixin.qq.com/s/gPZnR7sF_22KSsqepohgNg">Matrix-iOS 卡顿监控</a></p>
<blockquote>
<p>目前微信使用的卡顿监控，主程序 Runloop 超时的阈值是 2 秒，子线程的检查周期是 1 秒。每隔 1 秒，子线程检查主线程的运行状态；如果检查到主线程 Runloop 运行超过 2 秒则认为是卡顿，并获得当前的线程快照。同时，我们也认为 CPU 过高也可能导致应用出现卡顿，所以在子线程检查主线程状态的同时，如果检测到 CPU 占用过高，会捕获当前的线程快照保存到文件中。目前微信应用中认为，单核 CPU 的占用超过了 80% ，此时的 CPU 占用就过高了。</p>
</blockquote>
<p>GCDFetchFeed 中也有对应的实现：</p>
<pre><code class="language-objectivec">@implementation SMCPUMonitor
//轮询检查多个线程 cpu 情况
+ (void)updateCPU {
    thread_act_array_t threads;
    mach_msg_type_number_t threadCount = 0;
    const task_t thisTask = mach_task_self();
    kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);
    if (kr != KERN_SUCCESS) {
        return;
    }
    for (int i = 0; i &lt; threadCount; i++) {
        thread_info_data_t threadInfo;
        thread_basic_info_t threadBaseInfo;
        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;
        if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) {
            threadBaseInfo = (thread_basic_info_t)threadInfo;
            if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) {
                integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / 10;
                if (cpuUsage &gt; CPUMONITORRATE) {
                    //cup 消耗大于设置值时打印和记录堆栈
                    NSString *reStr = smStackOfThread(threads[i]);
                    SMCallStackModel *model = [[SMCallStackModel alloc] init];
                    model.stackStr = reStr;
                    //记录数据库中
                    [[[SMLagDB shareInstance] increaseWithStackModel:model] subscribeNext:^(id x) {}];
//                    NSLog(@&quot;CPU useage overload thread stack：\n%@&quot;,reStr);
                }
            }
        }
    }
}

uint64_t memoryFootprint() {
    task_vm_info_data_t vmInfo;
    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
    kern_return_t result = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);
    if (result != KERN_SUCCESS)
        return 0;
    return vmInfo.phys_footprint;
}

@end
</code></pre>
<h3 id="stack-backtrace"><a class="header" href="#stack-backtrace">Stack backtrace</a></h3>
<p>耗时比较长的代码有可能会长时间占用 CPU 资源，调用栈有可能总是停留在执行某个地址指令的状态，可以对比两次调用栈的符号信息，如果前者是后者的符号子集，那么就可以认为出现了卡顿：</p>
<pre><code class="language-objectivec">@implementation SMCPUMonitor
//轮询检查多个线程 cpu 情况
+ (void)updateCPU {
    thread_act_array_t threads;
    mach_msg_type_number_t threadCount = 0;
    const task_t thisTask = mach_task_self();
    kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);
    if (kr != KERN_SUCCESS) {
        return;
    }
    for (int i = 0; i &lt; threadCount; i++) {
        thread_info_data_t threadInfo;
        thread_basic_info_t threadBaseInfo;
        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;
        if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) {
            threadBaseInfo = (thread_basic_info_t)threadInfo;
            if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) {
                integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / 10;
                if (cpuUsage &gt; CPUMONITORRATE) {
                    //cup 消耗大于设置值时打印和记录堆栈
                    NSString *reStr = smStackOfThread(threads[i]);
                    SMCallStackModel *model = [[SMCallStackModel alloc] init];
                    model.stackStr = reStr;
                    //记录数据库中
                    [[[SMLagDB shareInstance] increaseWithStackModel:model] subscribeNext:^(id x) {}];
//                    NSLog(@&quot;CPU useage overload thread stack：\n%@&quot;,reStr);
                }
            }
        }
    }
}

uint64_t memoryFootprint() {
    task_vm_info_data_t vmInfo;
    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
    kern_return_t result = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);
    if (result != KERN_SUCCESS)
        return 0;
    return vmInfo.phys_footprint;
}

@end
</code></pre>
<h3 id="msgsend-observe"><a class="header" href="#msgsend-observe">msgSend observe</a></h3>
<p>Objective-C 方法最终都会走到 <code>msgSend</code> ，所以通过 hook <code>msgSend</code> 可以获取到每一个 Objective-C 方法的耗时：</p>
<pre><code class="language-objectivec">#define save() \
__asm volatile ( \
    &quot;stp x8, x9, [sp, #-16]!\n&quot; \
    &quot;stp x6, x7, [sp, #-16]!\n&quot; \
    &quot;stp x4, x5, [sp, #-16]!\n&quot; \
    &quot;stp x2, x3, [sp, #-16]!\n&quot; \
    &quot;stp x0, x1, [sp, #-16]!\n&quot;);

#define resume() \
__asm volatile ( \
    &quot;ldp x0, x1, [sp], #16\n&quot; \
    &quot;ldp x2, x3, [sp], #16\n&quot; \
    &quot;ldp x4, x5, [sp], #16\n&quot; \
    &quot;ldp x6, x7, [sp], #16\n&quot; \
    &quot;ldp x8, x9, [sp], #16\n&quot; );
    
#define call(b, value) \
    __asm volatile (&quot;stp x8, x9, [sp, #-16]!\n&quot;); \
    __asm volatile (&quot;mov x12, %0\n&quot; :: &quot;r&quot;(value)); \
    __asm volatile (&quot;ldp x8, x9, [sp], #16\n&quot;); \
    __asm volatile (#b &quot; x12\n&quot;);

__attribute__((__naked__)) static void hook_Objc_msgSend() {

    save()
    __asm volatile (&quot;mov x2, lr\n&quot;);
    __asm volatile (&quot;mov x3, x4\n&quot;);
    
    call(blr, &amp;push_msgSend)
    resume()
    call(blr, orig_objc_msgSend)
    
    save()
    call(blr, &amp;pop_msgSend)
    
    __asm volatile (&quot;mov lr, x0\n&quot;);
    resume()
    __asm volatile (&quot;ret\n&quot;);
}
</code></pre>
<p><a href="https://www.notion.so/59dfa75498c24456a94b55d52f1ceba5">总结</a></p>
<h2 id="渲染原理"><a class="header" href="#渲染原理">渲染原理</a></h2>
<p><a href="https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/%E7%AC%94%E8%AE%B0/iOS%20Rendering.md">RickeyBoy/Rickey-iOS-Notes</a></p>
<p>具体涉及的内容：</p>
<ol>
<li>计算机渲染原理：CPU + GPU ， 图形渲染流水线；</li>
<li>屏幕成像和卡顿：屏幕撕裂，掉帧的原因，双缓冲与三缓冲；</li>
<li>iOS 中的渲染框架：CALayer，CALayer 与 UIView ；</li>
<li>Core Animation 渲染全内容：CA 渲染流水线， Commit Transaction ， Rendering Pass ；</li>
<li>离屏渲染。</li>
</ol>
<p>文章最后的提问：</p>
<p>CPU 和 GPU 的设计目的分别是什么？</p>
<p>CPU 是运算核心和控制核心，需要有很强的运算通用性，兼容各种数据类型，处理大量不同的跳转命令，而 GPU 处理的是类型统一，更加单纯的运算，也不需要处理复杂的指令，但是需要处理大量运算任务。</p>
<p>CPU 和 GPU 哪个的 Cache\ALU\Control unit 的比例更高？</p>
<p><img src="media/16366082839380.jpg" alt="" /></p>
<p>计算机图像渲染流水线的大致流程是什么？</p>
<p><img src="media/16366082995777.jpg" alt="" /></p>
<p>Application 应用处理阶段 → Geometry 几何处理阶段 → Rasterization 光栅化阶段 → Pixel 像素处理阶段。</p>
<p>Frame Buffer 帧缓冲器的作用是什么？</p>
<p>GPU 渲染之后得到的像素信息会存放在 Frame Buffer 中，视频控制器（ Video Controller ）可以通过读取 Frame Buffer 的信息，显示到 Monitor 上：</p>
<p><img src="media/16366083135919.jpg" alt="" /></p>
<p>Screen Tearing 屏幕撕裂是怎么造成的？</p>
<p><img src="media/16366083490555.jpg" alt="" /></p>
<p>显示器的电子束会从屏幕的左上角开始逐行扫描，从 Frame Buffer 中获取位图信息。在电子束扫描过程中，有可能出现扫描到中间时，CPU + GPU 才完成下一帧的渲染工作，那么就会出现已扫描部分为上一帧，未扫描部分显示为下一帧的情况，这就是屏幕撕裂。</p>
<p>如何解决屏幕撕裂的问题？</p>
<p>通过垂直同步 Vsync 和双缓冲 Double Buffer ， Vsync 相当于给 Frame Buffer 加锁，只有发出 Vsync 信号后，电子束才会开始扫描。而 Double Buffer 则可以缓存多个帧：</p>
<p><img src="media/16366083624068.jpg" alt="" /></p>
<p>掉帧是怎么产生的？</p>
<p>如果接收到 Vsync 信号时 CPU 和 GPU 还没有渲染好下一帧的位图，Video Controller 就会使用上一帧的画面，等于两帧显示了相同的画面，产生了掉帧：</p>
<p><img src="media/16366083764323.jpg" alt="" /></p>
<p>CoreAnimation 的职责是什么？</p>
<p>Core Animation 本质上是一个复合引擎，负责：渲染、构建和实现动画。</p>
<p><img src="media/16366083886636.jpg" alt="" /></p>
<p>可以看到 Core Animation 位于 UIKit/AppKit 和 Metal （ Core Graphics ）中间。</p>
<p>UIView 和 CALayer 是什么关系？有什么区别？</p>
<p><img src="media/16366084001780.jpg" alt="" /></p>
<ol>
<li>CALayer 是 UIView 的属性之一，负责渲染和动画，提供可视内容的呈现。</li>
<li>UIView 提供了对 CALayer 部分功能的封装，同时也另外负责了交互事件的处理。</li>
</ol>
<p>为什么会同时有 UIView 和 CALayer，能否合成一个？</p>
<p>通过将渲染和动画交给 CALayer 负责，可以在 iOS 和 OS X 上复用 CALayer 和 Core Animation ，而交互部分则可以交给 UIView 和 NSView 来负责。</p>
<p>渲染流水线中，CPU 会负责哪些任务？</p>
<p>Handle Events ， Commit Transaction ，Decode ， Draw Calls ，总之不是 GPU 处理的部分都是 CPU 来负责处理。</p>
<p><img src="media/16366084136083.jpg" alt="" /></p>
<p>离屏渲染为什么会有效率问题？</p>
<p><img src="media/16366084252672.jpg" alt="" /></p>
<p>离屏渲染需要先创建额外的离屏渲染缓冲区 Offscreen Buffer ， GPU 会将渲染好的内容放到里面，然后再统一处理，放到 Frame Buffer 中。可以看到需要对部分内容进行额外的渲染和保存，及在 Offscreen Buffer 和 Frame Buffer 间切换，需要更多的处理时间。</p>
<p>什么时候应该使用离屏渲染？</p>
<p>只有在可以复用渲染内容时才进行离屏渲染，可以通过开启 <code>shouldRasterize</code> 来主动开启离屏渲染。</p>
<p><code>shouldRasterize</code> 光栅化是什么？</p>
<p>有哪些常见的触发离屏渲染的情况？</p>
<ol>
<li>使用了 mask 的 layer (<code>layer.mask</code>)</li>
<li>需要进行裁剪的 layer (<code>layer.masksToBounds</code> / <code>view.clipsToBounds</code>)</li>
<li>设置了组透明度为 YES，并且透明度不为 1 的 layer (<code>layer.allowsGroupOpacity</code>/<code>layer.opacity</code>)</li>
<li>添加了投影的 layer (<code>layer.shadow*</code>)</li>
<li>采用了光栅化的 layer (<code>layer.shouldRasterize</code>)</li>
<li>绘制了文字的 layer (<code>UILabel</code>, <code>CATextLayer</code>, <code>Core Text</code> 等)</li>
</ol>
<p><code>cornerRadius</code> 设置圆角会触发离屏渲染吗？</p>
<p>如果只是设置了 <code>cornerRadius</code> 而没有设置 <code>masksToBounds</code> ，由于不需要叠加裁剪，此时是并不会触发离屏渲染的。</p>
<p>圆角触发的离屏渲染有哪些解决方案？</p>
<p>可以参考即刻的处理。</p>
<p>重写 drawRect 方法会触发离屏渲染吗？</p>
<p>不会，只是会将 GPU 中的渲染操作转移到 CPU 中，且需要额外的内存空间。</p>
<h2 id="关于-ios-离屏渲染的深入研究"><a class="header" href="#关于-ios-离屏渲染的深入研究">关于 iOS 离屏渲染的深入研究</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a></p>
<p>即刻的优化：</p>
<ul>
<li>即刻大量应用 <code>AsyncDisplayKit(Texture)</code> 作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看<a href="https://link.zhihu.com/?target=https%3A//medium.com/jike-engineering/asyncdisplaykit%25E4%25BB%258B%25E7%25BB%258D-%25E4%25B8%2580-6b871d29e005">之前的一些介绍</a></li>
<li>对于图片的圆角，统一采用 <code>precomposite</code> 的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角</li>
<li>对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的 <code>layer</code> 盖住四个角，从视觉上制造圆角的效果</li>
<li>对于 <code>view</code> 的圆形边框，如果没有 <code>backgroundColor</code> ，可以放心使用 <code>cornerRadius</code> 来做</li>
<li>对于所有的阴影，使用 <code>shadowPath</code> 来规避离屏渲染</li>
<li>对于特殊形状的 <code>view</code> ，使用 <code>layer mask</code> 并打开  <code>shouldRasterize</code> 来对渲染结果进行缓存</li>
<li>对于模糊效果，不采用系统提供的 <code>UIVisualEffect</code> ，而是另外实现模糊效果（ <code>CIGaussianBlur</code> ），并手动管理渲染结果</li>
</ul>
<h2 id="绘制像素到屏幕上"><a class="header" href="#绘制像素到屏幕上">绘制像素到屏幕上</a></h2>
<p><a href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/">Getting Pixels onto the Screen</a></p>
<p><a href="https://objccn.io/issue-3-1/">ObjC 中国 - 绘制像素到屏幕上</a></p>
<p>这篇文章说得很详细，大概分为以下几个模块：</p>
<ul>
<li>软件组成，从 GPU 到 GPU Driver 再到 OpenGL ；</li>
<li>硬件参与者，CPU 与 GPU 之间的合作，如何复用纹理；</li>
<li>如何合成纹理，不透明度，像素对齐， Mask 等都会对合成纹理的过程产生影响；</li>
<li>离屏渲染，可以被动触发，也可以强制触发，系统可以缓存相关位图；</li>
<li>Core Animation 与 OpenGL ；</li>
<li>Core Graphics 绘图；</li>
<li><code>drawRect:</code> ，异步绘图；</li>
</ul>
<p><img src="media/16366084546483.jpg" alt="" /></p>
<p>GPU 是专门为图形高并发计算而定做的处理单元。GPU Driver 是直接和 GPU 交流的代码块。再上一层则是 OpenGL ，提供了与 GPU 交流的标准化方式。</p>
<p><img src="media/16366084675533.jpg" alt="" /></p>
<p>GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。</p>
<h2 id="ios-保持界面流畅的技巧"><a class="header" href="#ios-保持界面流畅的技巧">iOS 保持界面流畅的技巧</a></h2>
<p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p>
<p>产生卡顿的原因和解决方案：</p>
<p>CPU 层级：</p>
<ol>
<li>对象创建，对象创建时会分配内存，调整属性，甚至说读取文件等操作，可以考虑使用更轻量的对象，如使用 <code>CALayer</code> 代替 <code>UIView</code> 。延迟对象的创建事件，复用机制，如 <code>UITableViewCell/UICollectionViewCell</code> ；</li>
<li>对象调整，这里特别说一下 <code>CALayer</code> ： <code>CALayer</code> 内部并没有属性，当调用属性方法时，它内部是通过运行时 <code>resolveInstanceMethod</code> 为对象临时添加一个方法，并把对应属性值保存到内部的一个 <code>Dictionary</code> 里，同时还会通知 <code>delegate</code> 、创建动画等等，非常消耗资源。 <code>UIView</code> 的关于显示相关的属性（比如 <code>frame/bounds/transform</code> ）等实际上都是 <code>CALayer</code> 属性映射来的，所以对 <code>UIView</code> 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改；</li>
<li>布局计算，视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了；</li>
<li>文本计算与渲染，文本的排版和绘制都是在主线程进行，当有大量不定高的文字内容需要进行高度计算和渲染时，会占用非常多的 CPU 的时间，可以使用 <code>TextKit</code> 或者 <code>CoreText</code> 对文本进行异步绘制，缓存绘制结果，在复用时使用；</li>
<li>图片解码与绘制，当使用 <code>UIImage</code> 或者 <code>CGImageSource</code> 创建图片时，图片数据不会立刻解码。只有当 <code>CALayer</code> 提交到 GPU 前， <code>CGImage</code> 中的数据才会进行解码，而且是发生在主线程。常见的做法是在后台线程先把图片绘制到 <code>CGBitmapContext</code> 中，然后从 <code>Bitmap</code> 直接创建图片。目前常见的网络图片库都自带这个功能。绘制则是指常用的以 <code>CG</code> 开头的方法把图像绘制到画布中，也可以通过异步绘制来进行优化：</li>
</ol>
<pre><code class="language-objectivec">- (void)display {
    dispatch_async(backgroundQueue, ^{
        CGContextRef ctx = CGBitmapContextCreate(...);
        // draw in context...
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        dispatch_async(mainQueue, ^{
            layer.contents = img;
        });
    });
}
</code></pre>
<p>GPU 层级：</p>
<ol>
<li>纹理的渲染，所有的 <code>Bitmap</code> ，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 <code>TableView</code> 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗；</li>
<li>视图的混合，当多个视图重叠在一起时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示；</li>
<li>CALayer 的 <code>border</code> 、圆角、阴影、遮罩（ <code>mask</code> ）， <code>CASharpLayer</code> 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 <code>CALayer</code> ，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 <code>CALayer.shouldRasterize</code> 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../iDev/Performance/Performance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../iDev/Performance/Size.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../iDev/Performance/Performance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../iDev/Performance/Size.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
