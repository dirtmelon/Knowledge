<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Grand Central Dispatch - Knowledge</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../About.html">关于</a></li><li class="chapter-item expanded "><a href="../../programming-languages/programming-languages.html">编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Swift/Swift.html">Swift</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Objective-C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/associated-objects.html">Associated Objects</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/initialize.html">initialize</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/load.html">load</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Block.html">Block</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Category.html">Category</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/KVO.html">KVO</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/KVC.html">KVC</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/AutoreleasePool.html">AutoreleasePool</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/dealloc.html">dealloc</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Tagged-Pointer.html">Tagged Pointer</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/weak.html">weak</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Object.html">Object</a></li></ol></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/getting-subclasses-of-objective-c-class.html">如何获取某个类的全部子类</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/objective-c-class-properties.html">Objective-C 类属性</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../iDev/iDev.html">iDev</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Multithreading/Introduction.html">多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Multithreading/NSOperation.html">NSOperation</a></li><li class="chapter-item expanded "><a href="../../iDev/Multithreading/Grand-Central-Dispatch.html" class="active">Grand Central Dispatch</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../books/books.html">阅读</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../books/Homo-Deus-A-Brief-History-of-Tomorrow.html">未来简史</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Knowledge</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dirtmelon/Knowledge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="grand-central-dispatch"><a class="header" href="#grand-central-dispatch">Grand Central Dispatch</a></h1>
<p>官方文档：</p>
<p><a href="https://developer.apple.com/documentation/dispatch">Apple Developer Documentation</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">Dispatch Queues</a></p>
<p>源代码：</p>
<p><a href="https://opensource.apple.com/source/libdispatch/">Source Browser</a></p>
<p>Dispatch ， aka Grand Central Dispatch （GCD），还有个中文名叫做大中枢派发，包括语言特性， runtime 库（上面的 lib dispatch ）和系统级别的支持，以便在 macOS ，iOS 等多核设备上编写和执行并发代码。</p>
<h2 id="gcd-详尽总结"><a class="header" href="#gcd-详尽总结">GCD 详尽总结</a></h2>
<p><a href="https://juejin.im/post/5a90de68f265da4e9b592b40">iOS多线程：『GCD』详尽总结</a></p>
<p>GCD 好处：</p>
<ul>
<li>不需要我们手动管理线程的声明周期，GCD 会帮我们进行管理；</li>
<li>充分利用多核 CPU 的性能；</li>
<li>基于 block 的 API ，便于使用。</li>
</ul>
<p><code>sync</code> 和 <code>async</code> 表示是否开启新线程，而 <code>Serial Dispatch Queue</code> 和 <code>Concurrent Dispatch Queue</code> 则表示是否具备开启新线程的能力。</p>
<p>需要注意同步/异步执行 + 并发/串行/主队列的执行情况。</p>
<h2 id="细说gcdgrand-central-dispatch如何用"><a class="header" href="#细说gcdgrand-central-dispatch如何用">细说GCD（Grand Central Dispatch）如何用</a></h2>
<p><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8">ming1016/study</a></p>
<p>GCD 的用法，没涉及到源码解析部分。</p>
<h2 id="lets-build-dispatch_queue"><a class="header" href="#lets-build-dispatch_queue">Let's Build <code>dispatch_queue</code></a></h2>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html">mikeash.com: Friday Q&amp;A 2015-09-04: Let's Build dispatch_queue</a></p>
<p>Mikeash 自己实现的一个简易版的 <code>dispatch_queue</code> ，源码：</p>
<p><a href="https://github.com/mikeash/MADispatchQueue">GitHub - mikeash/MADispatchQueue: A spiritual reimplementation of the basics of dispatch_queue, for educational purposes</a></p>
<p>支持以下功能：</p>
<ol>
<li>串行或者并发；</li>
<li>同步和异步派发；</li>
<li>底层使用同一个线程池。</li>
</ol>
<p>与 GCD 提供的 C API 不同，接口层通过 Objective-C 实现。 <code>MADispatchQueue</code> 提供了四个接口：</p>
<pre><code class="language-objectivec">@interface MADispatchQueue : NSObject
// 全局队列， GCD 支持根据不同优先级获取不同的队列， MADispatchQueue 没有实现这个功能 
+ (MADispatchQueue *)globalQueue;

// 初始化方法，通过 serial 来定义是串行还是并发
- (id)initSerial: (BOOL)serial;

// 执行异步 block
- (void)dispatchAsync: (dispatch_block_t)block;

// 执行同步 block
- (void)dispatchSync: (dispatch_block_t)block;

@end
</code></pre>
<p>线程池能力由 <code>MAThreadPool</code> 提供，只提供了一个能力：执行所提交的任务，所以对外只提供了以下接口：</p>
<pre><code class="language-objectivec">@interface MAThreadPool : NSObject

- (void)addBlock: (dispatch_block_t)block;

@end
</code></pre>
<pre><code class="language-objectivec">@implementation MAThreadPool {
    // 使用 NSCondition 来作为锁，可以通过 signal 和 wait 进行通信
    NSCondition *_lock;
    
    // 当前所开启的线程
    NSUInteger _threadCount;
    // 执行任务中的线程
    NSUInteger _activeThreadCount;
    // 最大线程数
    NSUInteger _threadCountLimit;
    // 需要执行的 block
    NSMutableArray *_blocks;
}

- (id)init {
    if((self = [super init])) {
        _lock = [[NSCondition alloc] init];
        _blocks = [[NSMutableArray alloc] init];
        _threadCountLimit = 128;
    }
    return self;
}

- (void)addBlock: (dispatch_block_t)block {
    // 加锁保证线程安全
    [_lock lock];
    // 添加 block 到 blocks 数组中
    [_blocks addObject: block];
    
	  // 判断当前空闲线程是否可以处理完所有待处理的 blocks 
    // 如果说 blocks 数量大于空闲线程数且当前线程数小于最大线程数，则可以开启新线程
    NSUInteger idleThreads = _threadCount - _activeThreadCount;
    if([_blocks count] &gt; idleThreads &amp;&amp; _threadCount &lt; _threadCountLimit) {
        [NSThread detachNewThreadSelector: @selector(workerThreadLoop:) toTarget: self withObject: nil];
        _threadCount++;
    }
    // signal 执行任务
    [_lock signal];
    [_lock unlock];
}

- (void)workerThreadLoop: (id)ignore {
    [_lock lock];
    // 线程保活，实现类似 RunLoop 的流程
    while(1) {
        while([_blocks count] == 0) {
            // wait 等待任务派发
            [_lock wait];
        }
        // 获取第一个任务
        dispatch_block_t block = [_blocks firstObject];
        [_blocks removeObjectAtIndex: 0];
        _activeThreadCount++;
        [_lock unlock];
        
        block();
        
        [_lock lock];
        _activeThreadCount--;
    }
}

@end
</code></pre>
<p><code>MADispatchQueue</code> 的实现：</p>
<pre><code class="language-objectivec">@implementation MADispatchQueue {
    NSLock *_lock;
    NSMutableArray *_pendingBlocks;
    BOOL _serial;
    // 是否在执行任务
    BOOL _serialRunning;
}

static MADispatchQueue *gGlobalQueue;
static MAThreadPool *gThreadPool;

// 借用 initialize 机制初始化 gGlobalQueue 和 gThreadPool 
// 因为 dispatch_once 是 GCD 提供的能力，作者不想通过 GCD API 来实现 GCD 的功能，所以改用通过 initialize 来实现
+ (void)initialize {
    if(self == [MADispatchQueue class]) {
        gGlobalQueue = [[MADispatchQueue alloc] initSerial: NO];
        gThreadPool = [[MAThreadPool alloc] init];
    }
}

+ (MADispatchQueue *)globalQueue {
    return gGlobalQueue;
}

- (id)initSerial: (BOOL)serial {
    if ((self = [super init])) {
        _lock = [[NSLock alloc] init];
        _pendingBlocks = [[NSMutableArray alloc] init];
        _serial = serial;
    }
    return self;
}

// 异步派发
- (void)dispatchAsync: (dispatch_block_t)block {
    [_lock lock];
    [_pendingBlocks addObject: block];
    // 如果是串行，且没有在执行 block
    if(_serial &amp;&amp; !_serialRunning) {
        _serialRunning = YES;
        [self dispatchOneBlock];
    } else if (!_serial) {
        // 并发队列，直接执行 block 即可
        [self dispatchOneBlock];
    }
    // 如果是串行且在执行 block 中，则不需要做任何处理， dispatchOneBlock 执行完后会自动检查是否还需要处理 blocks
    [_lock unlock];
}

// 同步派发，基于 async 进行任务派发，通过 condition 强行同步😂
- (void)dispatchSync: (dispatch_block_t)block {
    NSCondition *condition = [[NSCondition alloc] init];
    __block BOOL done = NO;
    [self dispatchAsync: ^{
        block();
        [condition lock];
        done = YES;
        [condition signal];
        [condition unlock];
    }];
    [condition lock];
    while (!done) {
        [condition wait];
    }
    [condition unlock];
}

// 负责处理 pendingBlocks 的任务
- (void)dispatchOneBlock {
    [gThreadPool addBlock: ^{
				// 加 lock 保证线程安全
        [_lock lock];
        dispatch_block_t block = [_pendingBlocks firstObject];
        [_pendingBlocks removeObjectAtIndex: 0];
        [_lock unlock];
        
        block();
        // 如果是串行，则判断是否还有处理中的 blocks
        if(_serial) {
            [_lock lock];
            if([_pendingBlocks count] &gt; 0) {
                [self dispatchOneBlock];
            } else {
                // 结束任务执行
                _serialRunning = NO;
            }
            [_lock unlock];
        }
    }];
}

@end
</code></pre>
<p>作者的总结：</p>
<p>全局线程池可以通过一个工作队列 （ Queue ）和自动管理线程来实现，使用共享的全局线程池，可以提供基本的调度队列 API ，支持基本的串行/并发和同步/异步调度，虽然说缺少了不少 GCD 的功能，但是可以很好地了解 GCD 的运作方式。</p>
<h2 id="dispatch_once-实现原理"><a class="header" href="#dispatch_once-实现原理">dispatch_once 实现原理</a></h2>
<p><a href="https://mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html">mikeash.com: Friday Q&amp;A 2014-06-06: Secrets of dispatch_once</a></p>
<pre><code class="language-objectivec">static dispatch_once_t predicate;    
dispatch_once(&amp;predicate, ^{
		// some one-time task
});
</code></pre>
<p><code>dispatch_once</code>  只需要提供两个参数：</p>
<ul>
<li><code>predicate</code> ，一个 <code>token</code> ，用于保证执行一次；</li>
<li><code>block</code> ，需要执行的具体操作；</li>
</ul>
<p>在单线程中， 我们使用一个 <code>if</code> 就可以保证方法只执行一次。但是在多线程中，就需要通过 <code>dispatch_once</code> 来保证 <code>block</code> 只执行一次，且其它线程需要等待 <code>dispatch_once</code> 执行完成。自己实现对应的版本并不难，但是 <code>dispatch_once</code> 的速度极快，这点比较难实现。</p>
<p>单线程版本：</p>
<pre><code class="language-objectivec">void SimpleOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		if(!*predicate) {
		    block();
        *predicate = 1;
    }
}
</code></pre>
<p><code>dispatch_once_t</code> 只是一个 <code>long</code> 的 <code>typedef</code> ，初始化为 <code>0</code> ， <code>block</code> 执行完毕后设置为 <code>1</code> 以保证不会多次执行。但是在多线程时，可能会同时进入到 <code>if</code> 条件判断中，导致多次执行。</p>
<p>关于 <code>dispatch_once</code> 的性能部分，有下面三个场景需要考虑清楚：</p>
<ol>
<li>首次调用 <code>dispatch_once</code> 的调用者会直接执行 <code>block</code> ；</li>
<li>在首次调用到 <code>block</code> 完成执行之间调用，需要等待 <code>block</code> 完成；</li>
<li>在 <code>block</code> 完成后调用，无需等待，可以直接继续后续流程；</li>
</ol>
<p>1 和 2 都不是非常重要，1 只会出现一次，而 2 基本上很少出现。</p>
<p>最重要的是第3点，在程序中会有可能出现成千上万次，每次我们都需要保证 <code>dispatch_once</code> 只执行一次。可以使用 <code>SimpleOnce</code> 作为我们性能测试的黄金准则。</p>
<h3 id="locks"><a class="header" href="#locks">Locks</a></h3>
<pre><code class="language-objectivec">void LockedOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

    pthread_mutex_lock(&amp;mutex);
    if(!*predicate) {
		    block();
        *predicate = 1;
    }
    pthread_mutex_unlock(&amp;mutex);
}
</code></pre>
<p>简易版的 <code>Lock</code> 实现，由于 <code>predicate</code> 是一个 <code>long</code> 指针，无法存放 <code>Lock</code> ，所以新建了一个全局 <code>mutex</code> 来保证线程安全，这样会导致不相关的 <code>predicate</code> 也需要互相等待，但是对于试验性的代码来说够用了。</p>
<h3 id="spinlocks"><a class="header" href="#spinlocks">Spinlocks</a></h3>
<pre><code class="language-objectivec">void SpinlockOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		static OSSpinLock lock = OS_SPINLOCK_INIT;

    OSSpinLockLock(&amp;lock);
		if(!*predicate) {
				block();
        *predicate = 1;
		}
    OSSpinLockUnlock(&amp;lock);
}
</code></pre>
<p>Spinlocks 会让线程忙等，而不是休眠，以此来减少唤醒线程的耗时。相比 <code>mutex</code> 版本有相当大的改进，但是比起单线程版本耗时还是较长。</p>
<h3 id="atomic-operations"><a class="header" href="#atomic-operations">Atomic Operations</a></h3>
<pre><code class="language-objectivec">BOOL CompareAndSwap(long *ptr, long testValue, long newValue) {
		if(*ptr == testValue) {
		    *ptr = newValue;
        return YES;
    }
    return NO;
}
</code></pre>
<p>原子操作，提供 CPU 操作，不需要进行加锁操作。 </p>
<p><code>ptr</code> 有三个值：</p>
<ul>
<li>0 表示 <code>block</code> 从未执行</li>
<li>1 表示 <code>block</code> 执行中</li>
<li>2 表示 <code>block</code> 执行中</li>
</ul>
<p>尽早退出，如果 <code>*predicate</code> 为 2 就 <code>return</code> ：</p>
<pre><code class="language-objectivec">void EarlyBailoutAtomicBuiltinsOnce(dispatch_once_t *predicate, dispatch_block_t block) {
		if(*predicate == 2) {
		    __sync_synchronize();
        return;
    }

    volatile dispatch_once_t *volatilePredicate = predicate;

    if(__sync_bool_compare_and_swap(volatilePredicate, 0, 1)) {
		    block();
	      __sync_synchronize();
        *volatilePredicate = 2;
    } else {
        while(*volatilePredicate != 2)
			  ;
        __sync_synchronize();
    }
}
</code></pre>
<p>源码：</p>
<p><a href="https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/src/once.c"></a></p>
<h2 id="dispatch_once-的死锁分析"><a class="header" href="#dispatch_once-的死锁分析"><code>dispatch_once</code> 的死锁分析</a></h2>
<p><a href="http://satanwoo.github.io/2016/04/11/dispatch-once/">滥用单例之dispatch_once死锁</a></p>
<p>延伸阅读：</p>
<p><a href="https://my.oschina.net/moooofly/blog/175019">【整理】__builtin_expect 解惑 - 摩云飞的个人页面 - OSCHINA</a></p>
<p><a href="http://lday.me/2017/11/04/0016_what_is_memory_barriers/">什么是内存屏障(Memory Barriers)</a></p>
<h2 id="gcd-源码分析"><a class="header" href="#gcd-源码分析">GCD 源码分析</a></h2>
<p>结合源码分析用法和原理，非常详尽。</p>
<p><a href="http://cocoa-chen.github.io/2018/03/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/">深入浅出GCD之基础篇 | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_queue/">深入浅出GCD之dispatch_queue | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_semaphore/">深入浅出GCD之dispatch_semaphore | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_queue/">深入浅出GCD之dispatch_queue | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_once/">深入浅出GCD之dispatch_once | cocoa_chen</a></p>
<p><a href="http://cocoa-chen.github.io/2018/03/19/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_source/">深入浅出GCD之dispatch_source | cocoa_chen</a></p>
<h2 id="gcd-注意点"><a class="header" href="#gcd-注意点">GCD 注意点</a></h2>
<p><a href="https://gist.github.com/tclementdev/6af616354912b0347cdf6db159c37057">Making efficient use of the libdispatch (GCD)</a></p>
<ul>
<li>只使用非常少，明确定义的 <code>queues</code> 。 所有的 <code>queues</code> 激活后，就会使用很多线程。 <code>queues</code> 应该根据 App 中特定的环境进行定义：UI ，存储，后台工作等，以此从多线程中获利；</li>
<li>先使用主线程，当你发现性能瓶颈时，找到原因，如果多线程可以优化性能，必须要小心地应用，同时观察系统的压力。重复使用默认的 <code>queues</code> ，如果需要添加多一个 <code>queue</code> 必须要经过测量。在大多数 Apps 中，尽量不要使用超过 3 个或者 4 个 <code>queues</code> ；</li>
<li>Queues that target other (non-global) queues are fine, these are the ones which scale. （这段不太明白）；</li>
<li>不要使用 <code>dispatch_get_global_queue()</code> ，它不能很好地处理优先级，同时会导致线程爆炸。使用自己的特定 <code>queue</code> 是最好的选择；</li>
<li>如果 <code>dispatch</code> 对应的 <code>block</code> 小于 1ms ，使用 <code>dispatch_async()</code> 会造成性能上的浪费，因为 <code>libdispatch</code> 的过载行为，很有可能会创建一个新的线程来执行这个 <code>block</code> 。使用锁来保护共享状态会是一个更好的选择；</li>
<li>一些类/库被更好地设计为复用其调用者的执行上下文，这意味这它们使用传统的锁来保证线程安全。 <code>os_unfair_lock</code> 通常是系统中的最快的锁（优先级更高，更少的上下文切换）；</li>
<li>如果并行运行，那么你的 <code>work item</code> 不应该相互竞争（竞态），否则性能会急剧下降。竞态有多种形式，锁是其中一种，这意味着使用共享资源有可能成为性能瓶颈：IPC/系统服务， <code>malloc(lock)</code> ， 共享内存， I/O ， ...</li>
<li>你不需要为了避免线程爆炸而一直使用同步方法。使用一定数量的 <code>queue</code> 而不是 <code>dispatch_get_global_queue()</code> 会是一个更好的选择；</li>
<li>异步编程的 bug 和复杂度都会增加，同步编程更容易阅读，编写和维护；</li>
<li>串行队列比并行队列优化得更好。只有在你需要性能改善时才使用并行队列，否则有可能是过早优化；</li>
<li>如果你需要在同一个队列中混合异步和同步调用，请使用 <code>dispatch_async</code> 和 <code>wait</code> 而不是 <code>dispatch_sync()</code> 。 <code>dispatch_async</code> 和 <code>wait</code> 结合使用可以减少队列切换；</li>
<li>充分利用3-4个以上的内核不是件容易的事，大多数尝试着么做的人都是在浪费精力来获得微不足道的性能；</li>
<li>测量 App 的真实性能，以此确保 App 通过优化后变得更快，而不是更慢。进行性能测试时应该进行全局的性能测试，而不是局部的性能测试，避免缓存影响和保持线程池活跃；</li>
<li><code>libdispatch</code> 非常有效率但是并不是魔术，资源是有限的。你无法忽略掉你正在使用的底层系统和硬件。不是所有代码可以并行运行。</li>
</ul>
<p>检查你代码所有 <code>dispatch_async()</code> 的调用，看看它们需要执行的任务是否值得切换至不同的上下文来执行。大多数情况下，锁都是更好的选择。</p>
<p>一旦你开始使用定义的队列和复用它们，你有可能在调用 <code>dispatch_sync()</code> 时导致死锁，在队列用于线程安全时经常会出现这种情况，再次声明一下使用锁是一个比较好的解决方案，只有在需要切换至不同的上下文时才使用 <code>dispatch_async()</code> 。</p>
<h3 id="如何取消-gcd-任务"><a class="header" href="#如何取消-gcd-任务">如何取消 GCD 任务</a></h3>
<ul>
<li>如果还未执行的子线程可以用 <code>dispatch_block_cancel</code> 来取消，需要使用 <code>dispatch_block_create</code> 创建 <code>dispatch_block_t</code> 。</li>
</ul>
<pre><code class="language-objectivec">- (void)stopSync{
    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block1 = dispatch_block_create(0, ^{
        NSLog(@&quot;block1 begin&quot;);
        [NSThread sleepForTimeInterval:3];
        NSLog(@&quot;block1 end&quot;);
    });

    dispatch_block_t block2 = dispatch_block_create(0, ^{
        NSLog(@&quot;block2 &quot;);
    });
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    //取消执行block2
    dispatch_block_cancel(block2);
}

</code></pre>
<ul>
<li>对于执行中的任务，可以通过变量判断是否需要提前 <code>return</code> 来取消任务。线程外设置__block变量，配合线程中return结束。</li>
</ul>
<pre><code class="language-objectivec">- (void)stopAsync {
    __block BOOL isFinish =NO;
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        for(long i=0; i&lt;10000; i++) {
            NSLog(@&quot;执行第 %ld 次&quot;,i);
            sleep(1);
            if(isFinish ==YES) {
                NSLog(@&quot;停止&quot;);
                return;
            }
        };
    });
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW,(int64_t)(10 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^{
        NSLog(@&quot;停止任务&quot;);
        isFinish =YES;
    });
}
</code></pre>
<h2 id="gcd-造成卡顿"><a class="header" href="#gcd-造成卡顿">GCD 造成卡顿</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/37463055">iOS App 使用 GCD 导致的卡顿问题</a></p>
<ol>
<li>
<p>iOS 系统本身是一个资源调度和分配系统，CPU，disk IO，VM 等都是稀缺资源，各个资源之间会互相影响，主线程的卡顿看似 CPU 资源出现瓶颈，但也有可能内核忙于调度其他资源，比如当前正在发生大量的磁盘读写，或者大量的内存申请和清理，都会导致下面这个简单的创建线程的内核调用出现卡顿：</p>
<p><code>libsystem_kernel.dylib __workq_kernreturn</code></p>
<p>所以解决办法只能是自己分析各 thread 的 call stack ，根据用户场景分析当前正在消耗的系统资源。后面也确实通过最近提交的代码分析，发现是由于增加了一些非常耗时的磁盘 io 任务（虽然也是放在在子线程），才出现这个看着不怎么沾边的 call stack。revert 之后卡顿警报就消失了。</p>
</li>
<li>
<p>现有的卡顿检测工具都只能在超时的情况下 dump call stack ，但出现超时有可能是任务 A，B，C 共同作用导致的，A 和 B 可能是真正耗时的任务，C 不耗时但碰巧是最后一个，所以被当成元凶，而 A 和 B 却没有出现在上报日志里。我暂时也没有想到特别好的解决办法。很明显， <code>libsystem_kernel.dylib __workq_kernreturn</code> 就是一个不怎么耗时的 C 任务。 </p>
</li>
<li>
<p>在使用 GCD 创建 queue，或者说一个 App 内部使用 GCD 执行子线程任务时，最好有一套 App 所有团队都能遵循的队列使用机制，避免创建过多的 thread ，而出现意料之外的线程资源紧缺，代码无法及时执行的情况。这很难，尤其是在大公司动则上百人的团队里面。</p>
</li>
</ol>
<h2 id="gcd-原理详解"><a class="header" href="#gcd-原理详解">GCD 原理详解</a></h2>
<p><a href="https://github.com/bestswifter/blog/blob/master/articles/objc-gcd.md">objc-gcd</a></p>
<ol>
<li><code>fastpath(x)</code> 和 <code>slowpath(x)</code> 的作用：手动提醒编译器哪种情况比较容易发生；</li>
<li><code>dispatch_queue_t</code> 源码解析，设置线程并发数， <code>target queue</code> 等；</li>
<li><code>dispatch_async</code> ，根据并发数调用不同的函数，主要流程是用链表保存所有提交的 <code>block</code> ，然后在底层线程池中取出或者新建线程，执行最早添加的 <code>block</code> ；</li>
<li><code>dispatch_sync</code> ，使用信号量来保证每次只有一个 <code>block</code> 被执行；</li>
<li><code>dispatch_semaphore</code> 通过 <code>signal</code> 和 <code>wait</code> 来进行信号量管理，；</li>
<li><code>dispatch_group</code> 基于信号量进行处理， value 恢复初始值会调用所有注册的回调， <code>dispatch_group_notify</code> 将所有回调封装成链表，在 <code>dispatch_async</code> 完成时判断 value 是否恢复初始值，如果恢复初始值就调用 <code>dispatch_async</code> 执行所有注册的回调；</li>
<li><code>dispatch_once</code> 通过一个静态变量来标记 <code>block</code> 是否执行中或者已执行，通过信号量来确保只有一个线程能执行 <code>block</code> ，执行完成后会唤醒其它等待的线程；</li>
<li><code>dispatch_barrier_async</code> 改变 <code>block</code> 的 <code>vtable</code> 标记位，会等待前面的 <code>block</code> 执行完后才执行；</li>
<li><code>dispatch_source</code> 可以用来实现定时器，所有的 source 会提交到用户指定的队列，然后提交到 manager 队列中，和 <code>NSTimer</code> 不同，没有依赖 RunLoop 。</li>
</ol>
<h2 id="gcd-总结"><a class="header" href="#gcd-总结">GCD 总结</a></h2>
<p><a href="https://folobe26.github.io/2020/09/18/gcd/">GCD</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../iDev/Multithreading/NSOperation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../books/books.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../iDev/Multithreading/NSOperation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../books/books.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
