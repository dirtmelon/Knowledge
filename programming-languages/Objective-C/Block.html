<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Block - Knowledge</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../About.html">关于</a></li><li class="chapter-item expanded "><a href="../../programming-languages/programming-languages.html">编程语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Swift/Swift.html">Swift</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Objective-C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/associated-objects.html">Associated Objects</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/initialize.html">initialize</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/load.html">load</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Block.html" class="active">Block</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Category.html">Category</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Message-Sending-And-Forwarding.html">Message Sending And Forwarding</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/KVO.html">KVO</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/KVC.html">KVC</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/AutoreleasePool.html">AutoreleasePool</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/dealloc.html">dealloc</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Tagged-Pointer.html">Tagged Pointer</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/weak.html">weak</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Object.html">Object</a></li></ol></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/Objective-C.html">Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/getting-subclasses-of-objective-c-class.html">如何获取某个类的全部子类</a></li><li class="chapter-item expanded "><a href="../../programming-languages/Objective-C/objective-c-class-properties.html">Objective-C 类属性</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../iDev/iDev.html">iDev</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Multithreading/Introduction.html">多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../iDev/Multithreading/NSOperation.html">NSOperation</a></li><li class="chapter-item expanded "><a href="../../iDev/Multithreading/Grand-Central-Dispatch.html">Grand Central Dispatch</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../books/books.html">阅读</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../books/Homo-Deus-A-Brief-History-of-Tomorrow.html">未来简史</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Knowledge</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dirtmelon/Knowledge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="block"><a class="header" href="#block">Block</a></h1>
<h2 id="深入研究-block-捕获外部变量和-__block-实现原理"><a class="header" href="#深入研究-block-捕获外部变量和-__block-实现原理">深入研究 Block 捕获外部变量和 __block 实现原理</a></h2>
<p><a href="https://halfrost.com/ios_block/">深入研究 Block 捕获外部变量和 __block 实现原理</a></p>
<p>里面有提到作用域：</p>
<p><img src="media/16295345348106.jpg" alt="" /></p>
<ul>
<li><code>_NSConcreteStackBlock</code> ：只用到外部局部变量、成员属性变量，且没有强指针引用的 <code>block</code> 都是 <code>StackBlock</code> 。 <code>StackBlock</code> 的生命周期由系统控制的，一旦返回之后，就被系统销毁了。</li>
<li><code>_NSConcreteMallocBlock</code> ：有强指针引用或 <code>copy</code> 修饰的成员属性引用的 <code>block</code> 会被复制一份到堆中成为 <code>MallocBlock</code> ，没有强指针引用即销毁，生命周期由程序员控制</li>
<li><code>_NSConcreteGlobalBlock</code> ：没有用到外界变量或只用到全局变量、静态变量的 <code>block</code> 为 <code>_NSConcreteGlobalBlock</code> ，生命周期从创建到应用程序结束。</li>
</ul>
<p><code>__block</code> 结构体 <code>__forwarding</code> ：</p>
<p><img src="media/16295347079014.jpg" alt="" /></p>
<h2 id="block-技巧与底层解析"><a class="header" href="#block-技巧与底层解析">Block 技巧与底层解析</a></h2>
<p><a href="https://triplecc.github.io/2015/07/19/2015-08-27-blockji-qiao-yu-di-ceng-jie-xi/">Block技巧与底层解析</a></p>
<p>Block 的实际结构：</p>
<pre><code class="language-objectivec">/* Revised new layout. */
struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};

struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>
<p><code>_NSConcreteMallocBlock</code> 无法直接创建，只能 <code>_NSConcreteStackBlock</code> 拷贝得到，而 Block 的拷贝最终都会调用 <code>_Block_copy_internal</code> 函数，所以从 <code>_Block_copy_internal</code> 函数中可以得出 <code>_NSConcreteMallocBlock</code> 是如何创建的：</p>
<pre><code class="language-objectivec">static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
	...
    aBlock = (struct Block_layout *)arg;
	...
    // Its a stack block.  Make a copy.
    if (!isGC) {
    	// 申请block的堆内存
        struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
        if (!result) return (void *)0;
        // 拷贝栈中block到刚申请的堆内存中
        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
        // reset refcount
        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
        result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
        // 改变isa指向_NSConcreteMallocBlock，即堆block类型
        result-&gt;isa = _NSConcreteMallocBlock;
        if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
            //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
            (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
        }
        return result;
    }
    else {
        ...
    }
}
</code></pre>
<p>函数通过 <code>memmove</code> 将栈中的 Block 的内容拷贝到了堆中，并使 <code>isa</code> 指向了 <code>_NSConcreteMallocBlock</code> 。</p>
<p>Block 的拷贝代码在 <code>_Block_copy_internal</code> 函数中，根据 Block 的类型不同，拷贝过程中的操作也不同。</p>
<p>栈 Block 的拷贝不仅是拷贝了内容，而且由于从栈拷贝到堆中，还会进行一些额外的操作：</p>
<ol>
<li>往 <code>flags</code> 中并入 <code>BLOCK_NEEDS_FREE</code> ，并将引用计数设置为 1，表示 Block 需要释放，需要自行 <code>release</code> ；</li>
<li>如果有辅助 copy 函数 ( <code>BLOCK_HAS_COPY_DISPOSE</code> )，那么就会调用辅助  copy 函数来拷贝 Block 捕获的变量。</li>
</ol>
<pre><code class="language-objectivec">...
struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;
memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
// reset refcount
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
result-&gt;isa = _NSConcreteMallocBlock;
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
    (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
}
return result;
...
</code></pre>
<p>堆 Block 由于已经拷贝至堆中，所以其拷贝操作比较简单，首先需要判断是否有 <code>BLOCK_FREE</code> ，如果是，则表示是堆 Block ，那么只需要执行 <code>latching_incr_int</code> 操作，将 Block 的引用计数加 1 即可，只需要单纯地改变引用计数：</p>
<pre><code class="language-objectivec">...
if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
      // latches on high
      latching_incr_int(&amp;aBlock-&gt;flags);
      return aBlock;
}
...
</code></pre>
<p>全局 Block 不需要执行任何操作，只是直接返回了传入的 Block ：</p>
<pre><code class="language-objectivec">...
else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
      return aBlock;
}
...
</code></pre>
<pre><code class="language-objectivec">// flags/_flags类型
enum {
        /* See function implementation for a more complete description of these fields and combinations */
        // 是一个对象
        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */
        // 是一个block
        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */
        // 被__block修饰的变量
        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */
        // 被__weak修饰的变量，只能被辅助copy函数使用
        BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */
        // block辅助函数调用（告诉内部实现不要进行retain或者copy）
        BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */
    };

// 设置不同属性对应的flags/_flags值
__block id                   128+3
__weak block id              128+3+16
__block (^Block)             128+7
__weak __block (^Block)      128+7+16

struct Block_byref {
    void *isa;
    struct Block_byref *forwarding;
    int flags; /* refcount; */
    int size;
    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
    void (*byref_destroy)(struct Block_byref *);
    /* long shared[0]; */
};

// 做下对比
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};
</code></pre>
<p><code>__block</code> 将原来的基本类型包装成了对象。因为以上两个结构体的前 4 个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>
<pre><code class="language-objectivec">// 转换成C++代码
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

// _Block_object_assign源码
void _Block_object_assign(void *destAddr, const void *object, const int flags) {
...
    else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
...
}

// _Block_byref_assign_copy源码
static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    // 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
...
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) {
        // 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0
        // 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值
        // static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;
        // 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是包装对象的初始引用计数（栈上持有+堆上持有）
        ...
        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value;
        ...
    }
    // 已经拷贝到堆了，只增加引用计数
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);
    }
    // 普通的赋值，里面最底层就*destptr = value;这句表达式
    _Block_assign(src-&gt;forwarding, (void **)destp);
}
</code></pre>
<p>对象的辅助函数：</p>
<p>没有 <code>__block</code> 修饰：</p>
<pre><code class="language-objectivec">typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}
</code></pre>
<p>首先，在没有 <code>__block</code> 修饰时，对象编译转换的结果如下：</p>
<pre><code class="language-objectivec">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  NSObject *a = __cself-&gt;a; // bound by copy
            a;
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0),
</code></pre>
<p>对象在没有 <code>__block</code> 修饰时，并没有产生 <code>__Block_byref_a_0</code> 结构体，只是将标志位修改为 <code>BLOCK_FIELD_IS_OBJECT</code> 。而在 <code>_Block_object_assign</code> 中对应的判断分支代码如下：</p>
<pre><code class="language-objectivec"> v...
else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {
    _Block_retain_object(object);
    _Block_assign((void *)object, destAddr);
}
...
</code></pre>
<p>Block 在捕获对象时会进行 <code>retain</code> 操作，增加引用计数。</p>
<p>在有 <code>__block</code> 修饰时：</p>
<pre><code class="language-objectivec">typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}

// 转换后：
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 NSObject *a;
};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 33554432, sizeof(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131,....};
Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
}

// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）
static void __Block_byref_id_object_copy_131(void *dst, void *src) {
 _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);
}
static void __Block_byref_id_object_dispose_131(void *src) {
 _Block_object_dispose(*(void * *) ((char*)src + 40), 131);
}
</code></pre>
<p><code>__Block_byref_a_0</code> 新增两个内存管理的辅助函数 <code>__Block_byref_id_object_copy</code> 和 <code>__Block_byref_id_object_dispose</code> 。最后的 <code>131</code> 参数表示 <code>BLOCK_BYREF_CALLER|BLOCK_FIELD_IS_OBJECT</code> ， <code>BLOCK_BYREF_CALLER</code> 用于表明不需要对 <code>__block</code> 修饰的 <code>a</code> 对象进行 <code>retain</code> 或者 <code>copy</code> ：</p>
<pre><code class="language-objectivec">if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {
	...
    else {
        // do *not* retain or *copy* __block variables whatever they are
        _Block_assign((void *)object, destAddr);
    }
}
</code></pre>
<p><code>_Block_byref_assign_copy</code> 函数的以下代码会对上面的辅助函数 <code>__Block_byref_id_object_copy_131</code> 进行调用， <code>570425344</code> 表示 <code>BLOCK_HAS_COPY_DISPOSE|BLOCK_HAS_DESCRIPTOR</code> ，所以会执行以下相关源码：</p>
<pre><code class="language-objectivec">if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    // Trust copy helper to copy everything of interest
    // If more than one field shows up in a byref block this is wrong XXX
    copy-&gt;byref_keep = src-&gt;byref_keep;
    copy-&gt;byref_destroy = src-&gt;byref_destroy;
    (*src-&gt;byref_keep)(copy, src);
}
</code></pre>
<h2 id="一道-block-面试题的深入挖掘"><a class="header" href="#一道-block-面试题的深入挖掘">一道 Block 面试题的深入挖掘</a></h2>
<p><a href="https://juejin.im/post/5eaa2a87e51d454db7436726">一道Block面试题的深入挖掘</a></p>
<p>借由 <code>NSNotificationCenter</code> 和 <code>token</code> 说明实际编码中 Block 需要注意的地方以及原理。</p>
<h2 id="block-语法快速查询"><a class="header" href="#block-语法快速查询">Block 语法快速查询</a></h2>
<p>由于 Objective-C 的 Block 语法实在是太难记了，反观 Swift 😂 ，所以有了这么一个快速查看 Block 语法的网站：</p>
<p><a href="http://fuckingblocksyntax.com/">How Do I Declare A Block in Objective-C?</a></p>
<h2 id="obj-c-中的-block"><a class="header" href="#obj-c-中的-block">Obj-C 中的 Block</a></h2>
<p><a href="https://kingcos.me/posts/2019/block_in_obj-c/">Obj-C 中的 Block</a></p>
<p>Objective-C 中的 Block 相当于匿名函数。</p>
<p>通过 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 转换为 C++ 代码可以查看 Block 的结构体。</p>
<p><code>__main_3_block_impl_0</code> 为具体 Block 对应的 <code>struct</code> ，包含 <code>__block_impl</code> 和 <code>__main_3_block_desc_0</code> 。</p>
<pre><code class="language-objectivec">// Block 实现的结构体
struct __block_impl {
  void *isa;     // isa 指针，即 Block 也是 id 类型，即 Obj-C 对象
  int Flags;     // 标记，默认会被初始化为 0
  int Reserved;  // 保留域（ABI 兼容），默认 0
  void *FuncPtr; // Block 代码块的函数指针
};

// ➡️ Block 结构体
struct __main_3_block_impl_0 {
  struct __block_impl impl;           // 实现（非指针）
  struct __main_3_block_desc_0* Desc; // 描述信息（指针）
  // 构造函数
  __main_3_block_impl_0(void *fp, struct __main_3_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock; // Block 作为 Obj-C 对象，那么 isa 将指向其类对象，即 _NSConcreteStackBlock
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// Block 内代码块封装在该 C 语言静态函数中，函数命名规则：__CALLER_METHOD_NAME_block_func_NUMBER
// 类似 Obj-C 实例方法参数 self 或 C++ 实例方法参数 this，__cself 为指向 Block 结构体的变量
static void __main_3_block_func_0(struct __main_3_block_impl_0 *__cself) {
  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_b9596e_mi_0);
}

// Block 描述信息的结构体静态变量
static struct __main_3_block_desc_0 {
  size_t reserved;   // 保留域，默认 0
  size_t Block_size; // Block 大小，sizeof 整个 Block 结构体 ⬇️
} __main_3_block_desc_0_DATA = { 0, sizeof(struct __main_3_block_impl_0)};

// 主函数
int main_3(int argc, const char * argv[]) {
    // 通过 __main_3_block_impl_0 结构体的构造函数初始化，参数为静态函数和描述信息静态变量的地址，将地址存储在 block 变量中
    // 忽略类型转换：block = &amp;__main_3_block_impl_0(__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));
    void(*block)(void) = ((void (*)())&amp;__main_3_block_impl_0((void *)__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));

    // 执行 Block（参数 block 即静态函数中的参数 __cself）
    // 忽略类型转换：block-&gt;FuncPtr(block);
    // 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);

    return 0;
}
</code></pre>
<p><img src="media/16295350902641.jpg" alt="" /></p>
<p>Block 对于捕获变量的不同也会有不同的处理</p>
<ol>
<li>局部变量，进行值拷贝传递，修改原有的值不影响 Block 所捕获的值；</li>
<li>显式或者隐式捕获 <code>self</code> ，Block 会持有 <code>self</code> 的引用，有可能触发我们常说的循环引用；</li>
<li>静态局部变量， 虽然作用域在代码块内，但是其生命周期是全局的，所以 Block 直接持有对变量的引用；</li>
<li>全局变量，Block 不会捕获，使用时直接进行读取。</li>
</ol>
<p>Block 的类型：</p>
<p><code>__NSGlobalBlock__</code> ，不捕获自动变量，即运行时不依赖上下文，放在内存的数据段 (Data Section) ，和全局变量同一个 Section 。对 <code>__NSGlobalBlock__</code> 执行拷贝后得到的仍是 <code>__NSGlobalBlock__</code> 。</p>
<p><code>__NSStackBlock__</code> ，当 Block 捕获了外界自动变量时，则会被分配在栈区，变成 <code>__NSStackBlock__</code> ，开发者无需关心其生命周期。</p>
<p><code>__NSMallocBlock__</code> ，Block 分配在堆区，需要开发者手动管理其生命周期，ARC 下编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 copy 到堆上，将 Block 的 <code>isa</code> 设置为 <code>_NSConcreteMallocBlock</code> ，以下操作会将 Block copy 到堆上：</p>
<ol>
<li>强指针或者属性指向的 Block ；</li>
<li>Block 作为函数值会自动拷贝；</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code>  的参数时会自动拷贝；</li>
<li>Block 作为 GCD API 参数时会被自动拷贝；</li>
</ol>
<p><code>__block</code> 声明的变量：</p>
<p>Block 内可以直接修改</p>
<p><code>__block</code> 声明会将变量封装为对应的结构体，而不同的变量就会生成不同的结构体。 <code>__block</code> 变量从声明后，无论在 Block 内外去访问均是通过结构体的 <code>__forwarding</code> 指针即 <code>blockVar.__forwarding-&gt;blockVar</code> 。当 <code>__block</code> 变量在栈上时， <code>blockVar.__forwarding-&gt;blockVar</code> 就等同于直接通过 <code>blockVar-&gt;blockVar</code> 来访问的，因为此时 <code>__forwarding</code> 就指向栈上的结构体本身；而当 Block 拷贝到堆上时， <code>__block</code> 变量也会被拷贝到堆上，此时栈上的 <code>__forwarding</code> 将替换为指向堆上的结构体，而堆上的结构体里的 <code>__forwarding</code> 将指向堆上的结构体本身，从而保证后续的数据变动均是在堆上。</p>
<p>上面说到 Block 会生成不同的结构体，也就说使用 Block 实现的功能代码量会较多。</p>
<p><img src="media/16295351225941.jpg" alt="" /></p>
<p>循环引用：</p>
<pre><code class="language-objectivec">typedef void(^BlockType_5)(void);

@interface Foo_9 : NSObject
@property (nonatomic, assign) NSUInteger bar;
@property (nonatomic, copy) BlockType_5 block;
@end

@implementation Foo_9
- (void)dealloc
{
#if !__has_feature(objc_arc)
    [super dealloc];
#endifNSLog(@&quot;dealloc&quot;);
}

- (void)foo_1 {
    // Block 捕获了 self，其强引用了 Block，导致双方都无法释放
    self.block = ^{
        // WARNING: Capturing 'self' strongly in this block is likely to lead to a retain cycle
        NSLog(@&quot;%lu&quot;, (unsigned long)self.bar);
        // WARNING: Block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior
        NSLog(@&quot;%lu&quot;, (unsigned long)_bar); // self-&gt;_bar
    };
}
@end

int main_22(int argc, const char * argv[]) {
#if __has_feature(objc_arc)
    Foo_9 *f = [[Foo_9 alloc] init];
    f.bar = 20;

    f.block = ^{
        // Block 捕获了 f，其强引用了 Block，导致双方都无法释放
        // WARNING: Capturing 'f' strongly in this block is likely to lead to a retain cycle
        NSLog(@&quot;%lu&quot;, (unsigned long)f.bar);
    };

    f.block();
    [f foo_1];

    // Never call dealloc
#endifreturn 0;
}

// OUTPUT:
// 20
</code></pre>
<p><img src="media/16295351549792.jpg" alt="" /></p>
<h2 id="用-block-实现-delegate-方法"><a class="header" href="#用-block-实现-delegate-方法">用 Block 实现 delegate 方法</a></h2>
<p><a href="https://triplecc.github.io/2017/07/28/2017-07-28-blockhe-nsmethodsignature/">用 Block 实现委托方法</a></p>
<p>使用 <code>NSInvocation</code> ，消息转化机制和 Block 结构体获取 <code>NSMethodSignature</code> 。</p>
<p><code>NSInvocation</code> 需要注意的地方：</p>
<p>方法的自定义参数从 index 2 开始，前两个参数是接收消息的对象和方法的 SEL ；</p>
<p><code>-getArgument:atIndex:</code> 和 <code>-getReturnvalue:</code> 方法中获取的对象不会进行 <code>retain</code> ，所以不能直接使用具体的对象指针，只能使用 <code>vod *</code> ：</p>
<pre><code class="language-objectivec">// 错误代码
NSString *bar = nil;
[invocation getArgument:&amp;bar atIndex:2];

NSString *result = nil;
[invocation getReturnValue:&amp;result];

// 正确代码
void *bar = nil;
//__unsafe_unretained NSString *bar = nil;
//__weak NSString *bar = nil;
[invocation getArgument:&amp;bar atIndex:2];

void *result = nil;
//__unsafe_unretained NSString *result = nil;
//__weak NSString *result = nil;
[invocation getReturnValue:&amp;result];
</code></pre>
<p>如果是在两个 <code>NSInvocation</code> 对象间传递参数/返回值，可以直接传入指针获取和设置目标地址：</p>
<pre><code class="language-objectivec">....
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
NSInvocation *shadowInvocation = [NSInvocation invocationWithMethodSignature:signature];
....
void *resultBuffer = malloc(invocation.methodSignature.methodReturnLength);
memset(resultBuffer, 0, invocation.methodSignature.methodReturnLength);

[invocation getReturnValue:resultBuffer];
[shadowInvocation setReturnValue:resultBuffer];
....
free(resultBuffer);
</code></pre>
<p>从协议中获取方法签名，利用 <code>protocol_getMethodDescription</code> 函数，可以获取到描述类型的 C 字符串，再通过这个字符串构造方法签名。针对协议中的接口有 <code>required</code> 和 <code>optional</code> 两种，并且不允许重复这一特点，可以创建构造方法签名的函数：</p>
<pre><code class="language-objectivec">static NSMethodSignature *tbv_getProtocolMethodSignature(Protocol *protocol, SEL selector, BOOL isInstanceMethod) {
    struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, YES, isInstanceMethod);
    if (!methodDescription.name) {
        methodDescription = protocol_getMethodDescription(protocol, selector, NO, isInstanceMethod);
    }
    return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
}
</code></pre>
<p>第三个参数表示是否为 <code>required</code> ，如果从 <code>required</code> 中获取不到对应的 <code>objc_method_description</code> ，再从 <code>optional</code> 中获取：</p>
<p><a href="https://developer.apple.com/documentation/objectivec/1418830-protocol_getmethoddescription">Apple Developer Documentation</a></p>
<p>从 Block 中获取方法签名，虽然苹果没有提供公开的 API 给开发者获取，但是可以通过自定义一个与 Block 结构相同的 <code>struct</code> ，通过这个 <code>struct</code> 来获取方法签名：</p>
<pre><code class="language-objectivec">// Block internals.
typedef NS_OPTIONS(int, TBVBlockFlags) {
    TBVBlockFlagsHasCopyDisposeHelpers = (1 &lt;&lt; 25),
    TBVBlockFlagsHasSignature          = (1 &lt;&lt; 30)
};
typedef struct tbv_block {
    __unused Class isa;
    TBVBlockFlags flags;
    __unused int reserved;
    void (__unused *invoke)(struct tbv_block *block, ...);
    struct {
        unsigned long int reserved;
        unsigned long int size;
        // requires TBVBlockFlagsHasCopyDisposeHelpers
        void (*copy)(void *dst, const void *src);
        void (*dispose)(const void *);
        // requires TBVBlockFlagsHasSignature
        const char *signature;
        const char *layout;
    } *descriptor;
    // imported variables
} *TBVBlockRef;

// 使用自定义的 TBVBlockRef 获取 descriptor
static NSMethodSignature *tbv_signatureForBlock(id block) {
    TBVBlockRef layout = (__bridge TBVBlockRef)(block);
    
    // 没有签名，直接返回空
    if (!(layout-&gt;flags &amp; TBVBlockFlagsHasSignature)) {
        return nil;
    }
    
    // 获取 descriptor 指针
    void *desc = layout-&gt;descriptor;
    
    // 跳过 reserved 和 size 成员
    desc += 2 * sizeof(unsigned long int);
    
    // 如果有 Helpers 函数， 跳过 copy 和 dispose 成员
    if (layout-&gt;flags &amp; TBVBlockFlagsHasCopyDisposeHelpers) {
        desc += 2 * sizeof(void *);
    }
    
    // desc 为 signature 指针的地址，转换下给 objcTypes
    char *objcTypes = (*(char **)desc);
    
    return [NSMethodSignature signatureWithObjCTypes:objcTypes];
}
</code></pre>
<p>为了确保 Block 和方法两者的参数是相同的，需要对两者的签名进行匹配，即检验返回值类型和参数类型是否相同：</p>
<pre><code class="language-objectivec">static BOOL tbv_isCompatibleBlockSignature(NSMethodSignature *blockSignature, NSMethodSignature *methodSignature) {
    NSCParameterAssert(blockSignature);
    NSCParameterAssert(methodSignature);
    
    if ([blockSignature isEqual:methodSignature]) {
        return YES;
    }
    
    // block 参数个数需要小于 method 的参数个数 (针对 block 调用替换 method 调用)
    // 两者返回类型需要一致
    if (blockSignature.numberOfArguments &gt;= methodSignature.numberOfArguments ||
        blockSignature.methodReturnType[0] != methodSignature.methodReturnType[0]) {
        return NO;
    }
    
    // 参数类型需要一致
    BOOL compatibleSignature = YES;
    
    // 自定义参数从第二个开始
    for (int idx = 2; idx &lt; blockSignature.numberOfArguments; idx++) {

        // block 相比 method ，默认参数少了 SEL
        // method: id(@) SEL(:) ....
        // block: block(@?) ....
        const char *methodArgument = [methodSignature getArgumentTypeAtIndex:idx];
        const char *blockArgument = [blockSignature getArgumentTypeAtIndex:idx - 1];
        if (!methodArgument || !blockArgument || methodArgument[0] != blockArgument[0]) {
            compatibleSignature = NO;
            break;
        }
    }
    
    return compatibleSignature;
}
</code></pre>
<p>调用 Block 的 <code>NSInvocation</code> ，由于直接调用的是 <code>delegate</code> 方法，在转发时接收到的是方法对应的 <code>NSInvocation</code> ，所以需要将其的参数和返回值传递给 Block 的 <code>NSInvocation</code> ：</p>
<pre><code class="language-objectivec">- (void)invokeWithMethodInvocation:(NSInvocation *)methodInvocation {
    NSParameterAssert(methodInvocation);
    NSAssert([self.methodSignature isEqual:methodInvocation.methodSignature], @&quot;Method invocation's signature is not compatible with block signature&quot;);
    
    NSMethodSignature *methodSignature = methodInvocation.methodSignature;
    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];
    
    void *argumentBuffer = NULL;
    for (int idx = 2; idx &lt; methodSignature.numberOfArguments; idx++) {
        
        // 获取参数类型
        const char *type = [methodSignature getArgumentTypeAtIndex:idx];
        NSUInteger size = 0;
        
        // 获取参数大小
        NSGetSizeAndAlignment(type, &amp;size, NULL);
        
        // 参数缓存
        if (!(argumentBuffer = reallocf(argumentBuffer, size))) {
            return;
        }
        
        // 把 method 的参数传递给 block
        [methodInvocation getArgument:argumentBuffer atIndex:idx];
        [blockInvocation setArgument:argumentBuffer atIndex:idx - 1];
    }
    
    // 调用 block
    [blockInvocation invokeWithTarget:self.block];
    
    // 返回值缓存
    if (methodSignature.methodReturnLength &amp;&amp;
        (argumentBuffer = reallocf(argumentBuffer, methodSignature.methodReturnLength))) {
        
        // 把 block 的返回值传递给 method
        [blockInvocation getReturnValue:argumentBuffer];
        [methodInvocation setReturnValue:argumentBuffer];
    }
    
    // 释放缓存
    free(argumentBuffer);
}

// reallocf 函数是 realloc 函数的增强版，它可以在后者无法申请到堆空间时，释放旧的堆空间：
void *reallocf(void *p, size_t s) {
    void *tmp = realloc(p, s);
    if(tmp) return tmp;
    free(p);
    return NULL;
}
</code></pre>
<p>最后是通过消息转发的 <code>forwardInvocaion:</code> 方法进行转发：</p>
<pre><code class="language-objectivec">- (void)forwardInvocation:(NSInvocation *)invocation {
    TBVBlockInvocation *blockInvocation = self.selectorInvocationMap[NSStringFromSelector(invocation.selector)];
    [blockInvocation invokeWithMethodInvocation:invocation];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    return self.selectorInvocationMap[NSStringFromSelector(sel)].methodSignature;
}

- (BOOL)respondsToSelector:(SEL)aSelector {
    return !!self.selectorInvocationMap[NSStringFromSelector(aSelector)];
}
</code></pre>
<h2 id="如何获取-block-捕获的对象"><a class="header" href="#如何获取-block-捕获的对象">如何获取 Block 捕获的对象</a></h2>
<p><a href="https://triplecc.github.io/2019/08/15/%E8%81%8A%E8%81%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%A3%80%E6%B5%8B/">聊聊循环引用的检测</a></p>
<p>由于 Objective-C 使用引用计数作为内存管理方法，且 Block 会强引用所捕获的对象，所以 Block 经常会造成引用循环。本文讲述了如何通过 Block 的布局，捕获变量排序来获取 Block 强引用的对象。</p>
<p>Block 捕获的对象会统一放在 layout 的 <code>descriptor</code> 后面，即 <code>sr_block_layout</code> 结构体的 <code>imported variables</code> 部分，这种操作可以看作在 <code>sr_block_layout</code> 尾部定义了一个 0 长数组，可以根据实际捕获变量的大小，给捕获区域申请对应的内存空间，只不过这一操作由编译器完成 :</p>
<pre><code class="language-objectivec">struct sr_block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct sr_block_descriptor *descriptor;
    char captured[0];
};

// 标志位不一样，这个结构的实际布局也会有差别，这里简单地放在一起好阅读
struct sr_block_descriptor {
    unsigned long reserved; // Block_descriptor_1
    unsigned long size; // Block_descriptor_1
    void (*)(void *dst, void *src);  // Block_descriptor_2 BLOCK_HAS_COPY_DISPOSE
    void (*dispose)(void *); // Block_descriptor_2
    const char *signature; // Block_descriptor_3 BLOCK_HAS_SIGNATURE
    const char *layout; // Block_descriptor_3 contents depend on BLOCK_HAS_EXTENDED_LAYOUT
};
</code></pre>
<p>Block 的捕获区域布局有特定的排序规则：</p>
<p><a href="https://github.com/llvm-mirror/clang/blob/e870496ea61feb01aa0eb4dc599be0ddf2d03878/lib/CodeGen/CGBlocks.cpp#L366-L384">llvm-mirror/clang</a></p>
<p>在对齐字节数 ( <code>alignment</code> ) 不相等时，捕获的实体按照 <code>alignment</code> 降序排序 ( C 结构体比较特殊，即使整体占用空间比指针变量大，也排在对象指针后面)，否则按照以下类型排序：</p>
<ol>
<li><code>__strong</code> 修饰对象指针变量</li>
<li><code>__block</code> 修饰对象指针变量</li>
<li><code>__weak</code> 修饰对象指针变量</li>
<li>其他变量</li>
</ol>
<p>一个例子：</p>
<pre><code class="language-objectivec">NSObject *o1 = [NSObject new];
__weak NSObject *o2 = o1;
__block NSObject *o3 = o1;
unsigned long long j = 4;
int i = 3;
char c = 'a';
void (^blk)(void) = ^{
    i;
    c;
    o1;
    o2;
    o3;
    j;
};
</code></pre>
<p>输出：</p>
<pre><code class="language-objectivec">(lldb) x/69bx layout
0x10200d940: 0x70 0x21 0x7b 0xa6 0xff 0x7f 0x00 0x00
0x10200d948: 0x02 0x00 0x00 0xc3 0x00 0x00 0x00 0x00
0x10200d950: 0xf0 0x1b 0x00 0x00 0x01 0x00 0x00 0x00
0x10200d958: 0xf8 0x20 0x00 0x00 0x01 0x00 0x00 0x00
0x10200d960: 0xa0 0xf6 0x00 0x02 0x01 0x00 0x00 0x00  // o1
0x10200d968: 0x90 0xd9 0x00 0x02 0x01 0x00 0x00 0x00  // o3
0x10200d970: 0xa0 0xf6 0x00 0x02 0x01 0x00 0x00 0x00  // o2
0x10200d978: 0x04 0x00 0x00 0x00 0x00 0x00 0x00 0x00  // j
0x10200d980: 0x03 0x00 0x00 0x00 0x61                 // i c
(lldb) p o1
(NSObject *) $1 = 0x000000010200f6a0
</code></pre>
<p>可以看到，小端模式下，捕获的 o1 和 o2 指针变量值为 <code>0x10200f6a0</code> ，对应内存地址为 <code>0x10200d960</code> 和 <code>0x10200d970</code> ，而 o3 因为被 <code>__block</code> 修饰，编译器为 o3 捕获变量包装了一层 <code>byref</code> 结构，所以其值为 <code>byref</code> 结构的地址 0x102000d990 ，而不是 0x10200f6a0 ，捕获的 j 变量地址为 0x10200d978，i 变量地址为 0x10200d980，c 字符变量紧随其后。</p>
<p>通过分析 <code>descriptor</code> 的 <code>layout</code> 信息则可以获取捕获到的对象个数。</p>
<p><a href="https://github.com/tripleCC/Laboratory/blob/d5d98d343a918d3883a2d5274da212cd44f50414/AppleSources/libclosure-73/Block_private.h#L283-L314">tripleCC/Laboratory</a></p>
<p><a href="https://github.com/llvm-mirror/clang/blob/e5d2fdc902b0fb4e0a8f5a7d549728e1f2a648ad/lib/CodeGen/CGObjCMac.cpp#L2614-L2865">llvm-mirror/clang</a></p>
<pre><code class="language-objectivec">// block
// Extended layout encoding.

// Values for Block_descriptor_3-&gt;layout with BLOCK_HAS_EXTENDED_LAYOUT
// and for Block_byref_3-&gt;layout with BLOCK_BYREF_LAYOUT_EXTENDED

// If the layout field is less than 0x1000, then it is a compact encoding 
// of the form 0xXYZ: X strong pointers, then Y byref pointers, 
// then Z weak pointers.

// If the layout field is 0x1000 or greater, it points to a 
// string of layout bytes. Each byte is of the form 0xPN.
// Operator P is from the list below. Value N is a parameter for the operator.

enum {
    ...
    BLOCK_LAYOUT_NON_OBJECT_BYTES = 1,    // N bytes non-objects
    BLOCK_LAYOUT_NON_OBJECT_WORDS = 2,    // N words non-objects
    BLOCK_LAYOUT_STRONG           = 3,    // N words strong pointers
    BLOCK_LAYOUT_BYREF            = 4,    // N words byref pointers
    BLOCK_LAYOUT_WEAK             = 5,    // N words weak pointers
    ...
};

// clang 
/// InlineLayoutInstruction - This routine produce an inline instruction for the
/// block variable layout if it can. If not, it returns 0. Rules are as follow:
/// If ((uintptr_t) layout) &lt; (1 &lt;&lt; 12), the layout is inline. In the 64bit world,
/// an inline layout of value 0x0000000000000xyz is interpreted as follows:
/// x captured object pointers of BLOCK_LAYOUT_STRONG. Followed by
/// y captured object of BLOCK_LAYOUT_BYREF. Followed by
/// z captured object of BLOCK_LAYOUT_WEAK. If any of the above is missing, zero
/// replaces it. For example, 0x00000x00 means x BLOCK_LAYOUT_STRONG and no
/// BLOCK_LAYOUT_BYREF and no BLOCK_LAYOUT_WEAK objects are captured.`
</code></pre>
<p><code>descriptor-&gt;layout</code> 会包含捕获的对象个数，且会根据 <code>__strong</code> ， <code>__block</code> 和 <code>__weak</code> 进行区分。</p>
<pre><code class="language-objectivec">NSObject *o1 = [NSObject new];
__block NSObject *o3 = o1;
__weak NSObject *o2 = o1;
NSObject *o4 = o1;
... // 5 - 18
NSObject *o19 = o1;
void (^blk)(void) = ^{
    o1;
    o2;
    o3;
    o4;
    ... // 5 - 18
    o19;
};
</code></pre>
<pre><code class="language-objectivec">(lldb) p/x (long)layout-&gt;descriptor-&gt;layout
(long) $0 = 0x0000000100002f44
(lldb) x/8bx layout-&gt;descriptor-&gt;layout
0x100002f44: 0x3f 0x30 0x40 0x50 0x00 0x76 0x31 0x36
</code></pre>
<p>由于结构体的布局顺序在生命时就确定了，无法像 Block 那样在编译时再根据变量类型，修饰符进行调整，所以如果结构体中有类型为对象指针的字段，就需要额外的信息来进行记录，这也会影响 <code>layout</code> 。</p>
<p>使用 <code>__block</code> 修饰的捕获变量首先会转换成 <code>byref</code> 结构，然后再由这个结构去持有实际的变量， Block 只负责管理 <code>byref</code> ：</p>
<pre><code class="language-objectivec">struct sr_block_byref {
    void *isa;
    struct sr_block_byref *forwarding;
    volatile int32_t flags; // contains ref count
    uint32_t size;
    // requires BLOCK_BYREF_HAS_COPY_DISPOSE
    void (*byref_keep)(struct sr_block_byref *dst, struct sr_block_byref *src);
    void (*byref_destroy)(struct sr_block_byref *);
    // requires BLOCK_BYREF_LAYOUT_EXTENDED
    const char *layout;
};
</code></pre>
<p>这里使用 <code>layout</code> 的原因是需要根据不同的捕获变量记录不同的信息，具体的实现可以查看原文。</p>
<p>了解完 Block 的捕获区域的内存布局后，就可以通过内存布局来获取强引用对象了：</p>
<ol>
<li>被 Block 强引用</li>
<li>被 byref 结构强引用</li>
</ol>
<p>完整的代码在这里：</p>
<p><a href="https://github.com/tripleCC/Laboratory/blob/9982b333c6b8d1cd7cb9ed17430906afebf1f8bb/BlockStrongReferenceObject/BlockStrongReferenceObject/SRBlockStrongReferenceCollector.m">tripleCC/Laboratory</a></p>
<h2 id="另一种获取-block-强引用对象的方式"><a class="header" href="#另一种获取-block-强引用对象的方式">另一种获取 Block 强引用对象的方式</a></h2>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/FBRetainCycleDetector/iOS%20%E4%B8%AD%E7%9A%84%20block%20%E6%98%AF%E5%A6%82%E4%BD%95%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84.md">draveness/analyze</a></p>
<p><a href="https://github.com/facebook/FBRetainCycleDetector/blob/ecd369ed1e03eb22178199091fecdba6c9964189/FBRetainCycleDetector/Layout/Blocks/FBBlockStrongLayout.m#L29-L102">facebook/FBRetainCycleDetector</a></p>
<p>FBRetainCycleDetector 也提供了获取 Block 强引用对象的功能，与上面的分析 Block 捕获区域的内存布局方式不同，使用了一种比较取巧的方式。</p>
<p>获取 <code>dispose_helper</code> ， <code>dispose_helper</code> 作为 Block 的辅助函数，在 Block 析构时会调用，然后给强引用对象发送 <code>release</code> 消息，借用这个特性进行处理。</p>
<pre><code class="language-objectivec">struct BlockDescriptor {
	unsigned long int reserved;                // NULL
	unsigned long int size;
	// optional helper functions
	void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25)
	void (*dispose_helper)(void *src);         // IFF (1&lt;&lt;25)
	const char *signature;                     // IFF (1&lt;&lt;30)
};
</code></pre>
<p>另外一个辅助类就是 <code>FBBlockStrongRelationDetector</code> ， <code>FBBlockStrongRelationDetector</code> 重写了 <code>release</code> 方法和新增了一个 <code>trueRelease</code> 方法：</p>
<pre><code class="language-objectivec">- (oneway void)release
{
  _strong = YES;
}

- (oneway void)trueRelease
{
  [super release];
}
</code></pre>
<p><code>FBBlockStrongRelationDetector</code> 同时也可以被当作 Block 来处理，当 Block  中又引用了 Block 时，它会尝试调用 <code>byref_dispose</code> ，所以 <code>FBBlockStrongRelationDetector</code> 也定义了和 Block 相同的变量布局：</p>
<pre><code class="language-objectivec">struct _block_byref_block;
@interface FBBlockStrongRelationDetector : NSObject
{
  // __block fakery
  void *forwarding;
  int flags;   //refcount;
  int size;
  void (*byref_keep)(struct _block_byref_block *dst, struct _block_byref_block *src);
  void (*byref_dispose)(struct _block_byref_block *);
  void *captured[16];
}
</code></pre>
<p>在获取强引用对象索引的实现中，会在自动释放迟中执行 <code>dispose_helper(obj)</code> 方法，给每个 强引用对象对应的 <code>FBBlockStrongRelationDetector</code> 发送 <code>release</code> 消息，这样就可以拿到它们的索引值，从而获取对应的对象。</p>
<pre><code class="language-objectivec">static NSIndexSet *_GetBlockStrongLayout(void *block) {
	...
	void (*dispose_helper)(void *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;
	const size_t ptrSize = sizeof(void *);	
	const size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize;
	
	void *obj[elements];
	void *detectors[elements];
	
	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];
		obj[i] = detectors[i] = detector;
	}
	
	@autoreleasepool {
		dispose_helper(obj);
	}
	NSMutableIndexSet *layout = [NSMutableIndexSet indexSet];
	
	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);
		if (detector.isStrong) {
			[layout addIndex:i];
		}
		
		[detector trueRelease];
	}
	
	return layout;
}
</code></pre>
<h2 id="llvm-关于-block-的文档"><a class="header" href="#llvm-关于-block-的文档">LLVM 关于 Block 的文档</a></h2>
<p><a href="https://clang.llvm.org/docs/Block-ABI-Apple.html">Clang 12 documentation</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../programming-languages/Objective-C/load.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../programming-languages/Objective-C/Category.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../programming-languages/Objective-C/load.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../programming-languages/Objective-C/Category.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
